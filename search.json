[
  {
    "objectID": "portal.html",
    "href": "portal.html",
    "title": "Portal",
    "section": "",
    "text": "Portal\nCertain instructions:\n\nAn important point to note is the sensitiveness of the portal to the kind of output that you produce. If the expected output is \\(7.0\\), then the actual output should also be \\(7.0\\). If you print \\(7\\), that would turn out to be a wrong answer, even though it may be mathematically correct. This is because, the portal does a strict string-matching between the output that you produce (actual output) and the configured output (expected output). To see how strict the comparison is, try to add a space after the number that you are expected to print. Though you won’t be able to see the space in the actual output area, the portal will call it a wrong answer. This is because, the space is an extra character and is not present in the configured answer.\nAnother thing to avoid is the following:\n\nx = float(input('Enter a real number:'))\nAvoid passing a string into the input command while coding on the portal. This string gets printed in the actual output area, which would result in a wrong answer."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.4.html",
    "href": "notes/chapter-4/lesson-4.4.html",
    "title": "Lesson-4.4",
    "section": "",
    "text": "Consider the following program:\ndef first():\n    second()\n    print('first')\n\ndef second():\n    third()\n    print('second')\n\ndef third():\n    print('third')\n    \nfirst()\nWhen the code given above is executed, the output is as follows:\nthird\nsecond\nfirst\nWe have already seen that a function can be called from inside another function. In the code snippet given above, we have a slightly complex version. Let us try to understand this visually. This method of visualization is novel and is called the traffic-signal method. You will see why it has been christened this way.\nConsider a simple function which doesn’t call any other function within its body. Most of the functions we have seen so far are like this. The call corresponding to this function could be in one of these two states: ongoing or completed.\n\nOngoing if the control is inside the body of the function, executing one of its lines.\nCompleted if all the lines in the body of the function have been executed and control has exited out of the function, either because a return statement was encountered or because the control reached the last line in the function, in which case None is returned by default.\n\nA function which calls another function inside it could find itself in one of the three states: ongoing, suspended or completed. They are color coded as follows. Now you see why it is called the traffic-signal theory:\n\nOngoing and completed have the same meaning. To understand the suspended state, consider the following diagrams that correspond to the code given above:\n\nEach column here is called a stack. They all represent the same stack at different instants of time, i.e., the columns here show the state of the stack at three different time instants. The horizontal arrow shows the passage of time. The vertical arrow indicates that each new function call gets added onto the top of the stack.\n\nRe-introducing the code for reference:\ndef first():\n    second()\n    print('first')\n\ndef second():\n    third()\n    print('second')\n\ndef third():\n    print('third')\n    \nfirst()\nAs third() doesn’t call any other function, it never enters the suspended state. Line-10 is the first print statement to be executed; this is why we see third as the first entry in the output. The job of the function third is done and it turns red. Now, the call transfers to the most recent suspended function - second. The execution of second resumes from the point where it got suspended; the print statement at line-7 is executed following which second turns red. Finally, control transfers to first, the print statement at line-3 is executed and first turns red.\n\n\n\nA recursive function is one which calls itself inside the body of the function. A typical example of recursion is the factorial function:\ndef fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\nIn the fact function given above, when the interpreter comes to line-4, it sees a recursive call to fact. In such a case, it suspends or temporarily halts the execution of fact(n) and starts executing fact(n - 1). Let us take a concrete example. This is what happens when fact(4) is called:\n\nWhen fact(0) is called, there are no more recursive calls. This is because, the condition in line-2 evaluates to True and the value 1 is returned. This condition is called the base-case of the recursion. In the absence of a base-case, the recursion continues indefinitely and never terminates.\n\nOnce the base-case kicks in, fact(0) is done with its duty. So, the call transfers to the most recent suspended function. On the stack, we see that this is fact(1). fact(1) now becomes active. When it returns the value 1, its life comes to an end, so the control transfers to the most recent suspended function, which is fact(2). This goes on until we reach fact(4). When fact(4) returns the value 24, all calls have been completed and we are done!\n\n\n\nThis section discusses some finer aspects of recursion.\n\n\nLet us take another popular example, the Fibonacci series: \\[\n1, 1, 2, 3, 5, 8, ...\n\\] Each term in this series is obtained by summing the two terms immediately to its left. We can mathematically express this as follows. If \\(x_1 = x_2 = 1\\), then for all \\(n &gt; 2, n \\in \\mathbb{N}\\), we have the following recurrence relation: \\[\nx_n = x_{n - 1} + x_{n - 2}\n\\] We can now compute the \\(n^{th}\\) term of the Fibonacci series using a recursive function:\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    return fibo(n - 1) + fibo(n - 2)\nNow, try calling fibo(40). You will notice that it takes a very long time to compute the value. Why does this happen? This is because a lot of wasteful computation happens. Let us see why:\n\nThis is a different representation of the recursive computation and is called a recursion tree. Notice how some function calls appear multiple times. fibo(3) and fibo(1) are being computed twice, fibo(2) is being computed thrice. For a larger value of n such as 50, there would be even more wasteful computation.\nPractically, how can we estimate the time that it takes for this program to run? One way would be to sit in front of the computer with a stopwatch in hand. But that is so un-Pythonic. Thankfully, the time library provides a good solution to this problem:\nimport time\n\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    return fibo(n - 1) + fibo(n - 2)\n\nstart = time.time()\nfibo(40)\nend = time.time()\nprint(f'It took approximately {round(end - start)} seconds.')\nIn a standard Python repl, it takes almost a minute! Coming back to the problem of Fibonacci series, we see that naive recursion doesn’t give us an efficient solution. We can instead look at the following iterative solution:\nimport time\n\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    x_prev, x_curr = 1, 1\n    while n &gt; 2:\n        x_prev, x_curr = x_curr, x_prev + x_curr\n        n -= 1\n    return x_curr\n\nstart = time.time()\nfibo(40)\nend = time.time()\nprint(f'It took approximately {round(end - start)} seconds.')\nLine-8 in the above code may be a little confusing. This is nothing but multiple assignment in the same line done simultaneously. The RHS of the assignment statement will be evaluated first, these two values will then be simultaneously assigned to their respective containers on the LHS. A better and more accurate explanation will be given in the next chapter when we discuss tuples.\n\n\n\nHow do we compute the number of times a function is called? We can do this using a global variable:\ndef fact(n):\n    global count\n    count = count + 1\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\n\ncount = 0\nfact(4)\nprint(count)\nThis is one of the potential uses of global variables.\n\n\n\nWhat happens if we have a recursive function without a base case? The simplest example of such a pathological function is:\n##### Alarm! Bad code snippet! #####\ndef foo():\n    foo()\n##### Alarm! Bad code snippet! #####\nWhen the above function is called with foo(), we get a RecursionError with the following message: maximum recursion depth exceeded. The limit is usually set to 1000 in most systems, i.e., If there are more than 1000 recursive calls, then that is going to result in this error. To verify what the limit is, you can run the following code:\nimport sys\nprint(sys.getrecursionlimit())"
  },
  {
    "objectID": "notes/chapter-4/lesson-4.4.html#function-calling-function",
    "href": "notes/chapter-4/lesson-4.4.html#function-calling-function",
    "title": "Lesson-4.4",
    "section": "",
    "text": "Consider the following program:\ndef first():\n    second()\n    print('first')\n\ndef second():\n    third()\n    print('second')\n\ndef third():\n    print('third')\n    \nfirst()\nWhen the code given above is executed, the output is as follows:\nthird\nsecond\nfirst\nWe have already seen that a function can be called from inside another function. In the code snippet given above, we have a slightly complex version. Let us try to understand this visually. This method of visualization is novel and is called the traffic-signal method. You will see why it has been christened this way.\nConsider a simple function which doesn’t call any other function within its body. Most of the functions we have seen so far are like this. The call corresponding to this function could be in one of these two states: ongoing or completed.\n\nOngoing if the control is inside the body of the function, executing one of its lines.\nCompleted if all the lines in the body of the function have been executed and control has exited out of the function, either because a return statement was encountered or because the control reached the last line in the function, in which case None is returned by default.\n\nA function which calls another function inside it could find itself in one of the three states: ongoing, suspended or completed. They are color coded as follows. Now you see why it is called the traffic-signal theory:\n\nOngoing and completed have the same meaning. To understand the suspended state, consider the following diagrams that correspond to the code given above:\n\nEach column here is called a stack. They all represent the same stack at different instants of time, i.e., the columns here show the state of the stack at three different time instants. The horizontal arrow shows the passage of time. The vertical arrow indicates that each new function call gets added onto the top of the stack.\n\nRe-introducing the code for reference:\ndef first():\n    second()\n    print('first')\n\ndef second():\n    third()\n    print('second')\n\ndef third():\n    print('third')\n    \nfirst()\nAs third() doesn’t call any other function, it never enters the suspended state. Line-10 is the first print statement to be executed; this is why we see third as the first entry in the output. The job of the function third is done and it turns red. Now, the call transfers to the most recent suspended function - second. The execution of second resumes from the point where it got suspended; the print statement at line-7 is executed following which second turns red. Finally, control transfers to first, the print statement at line-3 is executed and first turns red."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.4.html#recursion",
    "href": "notes/chapter-4/lesson-4.4.html#recursion",
    "title": "Lesson-4.4",
    "section": "",
    "text": "A recursive function is one which calls itself inside the body of the function. A typical example of recursion is the factorial function:\ndef fact(n):\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\nIn the fact function given above, when the interpreter comes to line-4, it sees a recursive call to fact. In such a case, it suspends or temporarily halts the execution of fact(n) and starts executing fact(n - 1). Let us take a concrete example. This is what happens when fact(4) is called:\n\nWhen fact(0) is called, there are no more recursive calls. This is because, the condition in line-2 evaluates to True and the value 1 is returned. This condition is called the base-case of the recursion. In the absence of a base-case, the recursion continues indefinitely and never terminates.\n\nOnce the base-case kicks in, fact(0) is done with its duty. So, the call transfers to the most recent suspended function. On the stack, we see that this is fact(1). fact(1) now becomes active. When it returns the value 1, its life comes to an end, so the control transfers to the most recent suspended function, which is fact(2). This goes on until we reach fact(4). When fact(4) returns the value 24, all calls have been completed and we are done!"
  },
  {
    "objectID": "notes/chapter-4/lesson-4.4.html#caution-in-recursion",
    "href": "notes/chapter-4/lesson-4.4.html#caution-in-recursion",
    "title": "Lesson-4.4",
    "section": "",
    "text": "This section discusses some finer aspects of recursion.\n\n\nLet us take another popular example, the Fibonacci series: \\[\n1, 1, 2, 3, 5, 8, ...\n\\] Each term in this series is obtained by summing the two terms immediately to its left. We can mathematically express this as follows. If \\(x_1 = x_2 = 1\\), then for all \\(n &gt; 2, n \\in \\mathbb{N}\\), we have the following recurrence relation: \\[\nx_n = x_{n - 1} + x_{n - 2}\n\\] We can now compute the \\(n^{th}\\) term of the Fibonacci series using a recursive function:\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    return fibo(n - 1) + fibo(n - 2)\nNow, try calling fibo(40). You will notice that it takes a very long time to compute the value. Why does this happen? This is because a lot of wasteful computation happens. Let us see why:\n\nThis is a different representation of the recursive computation and is called a recursion tree. Notice how some function calls appear multiple times. fibo(3) and fibo(1) are being computed twice, fibo(2) is being computed thrice. For a larger value of n such as 50, there would be even more wasteful computation.\nPractically, how can we estimate the time that it takes for this program to run? One way would be to sit in front of the computer with a stopwatch in hand. But that is so un-Pythonic. Thankfully, the time library provides a good solution to this problem:\nimport time\n\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    return fibo(n - 1) + fibo(n - 2)\n\nstart = time.time()\nfibo(40)\nend = time.time()\nprint(f'It took approximately {round(end - start)} seconds.')\nIn a standard Python repl, it takes almost a minute! Coming back to the problem of Fibonacci series, we see that naive recursion doesn’t give us an efficient solution. We can instead look at the following iterative solution:\nimport time\n\ndef fibo(n):\n    if n == 1 or n == 2:\n        return 1\n    x_prev, x_curr = 1, 1\n    while n &gt; 2:\n        x_prev, x_curr = x_curr, x_prev + x_curr\n        n -= 1\n    return x_curr\n\nstart = time.time()\nfibo(40)\nend = time.time()\nprint(f'It took approximately {round(end - start)} seconds.')\nLine-8 in the above code may be a little confusing. This is nothing but multiple assignment in the same line done simultaneously. The RHS of the assignment statement will be evaluated first, these two values will then be simultaneously assigned to their respective containers on the LHS. A better and more accurate explanation will be given in the next chapter when we discuss tuples.\n\n\n\nHow do we compute the number of times a function is called? We can do this using a global variable:\ndef fact(n):\n    global count\n    count = count + 1\n    if n == 0:\n        return 1\n    return n * fact(n - 1)\n\ncount = 0\nfact(4)\nprint(count)\nThis is one of the potential uses of global variables.\n\n\n\nWhat happens if we have a recursive function without a base case? The simplest example of such a pathological function is:\n##### Alarm! Bad code snippet! #####\ndef foo():\n    foo()\n##### Alarm! Bad code snippet! #####\nWhen the above function is called with foo(), we get a RecursionError with the following message: maximum recursion depth exceeded. The limit is usually set to 1000 in most systems, i.e., If there are more than 1000 recursive calls, then that is going to result in this error. To verify what the limit is, you can run the following code:\nimport sys\nprint(sys.getrecursionlimit())"
  },
  {
    "objectID": "notes/chapter-4/lesson-4.1.html",
    "href": "notes/chapter-4/lesson-4.1.html",
    "title": "Lesson-4.1",
    "section": "",
    "text": "In mathematics, a function is an object that accepts one or more inputs and produces one or more outputs. For example, \\(f(x) = x^2\\), is a function that accepts a number and returns the square of that number. Functions in Python play a similar role, but are much more richer than their mathematical counterparts. Let us quickly convert the mathematical function, \\(f(x) = x^2\\), into a Python function:\ndef f(x):\n    y = x ** 2\n    return y\nThe code given above is called the definition of function f. #!py def is the keyword used to define functions. f is the name of the function. x is a parameter of the function. Lines 2 and 3 make up the body of the function and are indented. The body of a function is a collection of statements that describe what the function does. At line 3, the value stored in variable y is returned. #!py return is the keyword used for this purpose.\nIf we run the above code, we will not get any output. Functions are not executed unless they are called. The following code demonstrates what a function call looks like:\ndef square(x):\n    y = x ** 2\n    return y\n\nprint(square(2))\nThe output is:\n4\n#!py square(2) is a function call. We use the name of the function, square, and pass the number 2 as an argument to it. The x in the function definition is called the parameter. The value that is passed to the function in the call is called the argument. This is a convention that we will follow throughout this lesson.\nA visual representation of the terms we have defined so far is given below:\n\n\n\nfunctions\n\n\nA mental model to understand functions:\n\nParameters can be thought of as the function’s inputs.\nThe body of the function can be pictured as the sequence of steps that transform the input into the output.\nThe return statement can be thought of as a means of communicating the output to the rest of the code.\n\n\n\n\nWe will look at a wide variety of function definitions. The focus will be on the syntactical aspects of function definitions.\n\nFunctions could have multiple parameters:\n\n# This function computes the area of a rectangle.\n# Length and breadth are the parameters\ndef area(l, b):\n    return l * b\n\nFunctions could have no parameters:\n\ndef foo():\n    return \"I don't like arguments visiting me!\"\n\nFunctions could have no return value:\n\ndef foo():\n    print(\"I don't like talking to the outside world!\")\n    \nfoo()\nWhen the code given above is executed, we get the following output:\nI don't like talking to the outside world!\nNote that we didn’t have to type #!py print(foo()). We just had to call the function — foo() — since it already has the print statement inside it. But what happens if we type #!py print(foo())? We get the following output:\nI don't like talking to the outside world!\nNone\nIf no explicit return statement is present in a function, None is the default value returned by it. When the interpreter comes across the #!py print(foo()) statement, first the function foo() is evaluated. This results in the first line of the output. Since foo() has no explicit return statement, it returns None by default. That is why the second line in the output is None.\n\nA minimal Python function looks like the one given below:\n\ndef foo():\n    pass\n#!py pass is a keyword in Python. When the interpreter comes across a #!py pass statement, it doesn’t perform any computation and moves on to the next line. The reason this is minimal is because it has only those features that are absolutely essential for a function definition to be syntactically valid: function name and at least one statement in the body.\nSuch functions might seem useless at first sight, but they do have their place in programming. While writing a complex piece of code, a coder may realize that they need to define a function to perform a specific task. But they might not know the exact details of the implementation or it may not be an urgent requirement. In such a scenario, they will add a minimal function like the one given above in their code and name it appropriately. Implementing this function will become a task on their to-do list and will be taken up as and when the need arises.\n\nFunctions could have multiple return statements, but the moment the first return is executed, control exits from the function:\n\ndef foo():\n    return 1\n    return 2\nfoo() will always return 1. Line 3 is redundant. An example of a function having multiple returns that are not redundant:\ndef evenOrOdd(n):\n    if n % 2 == 0:\n        return 'even'\n    else:\n        return 'odd'\n\nprint(evenOrOdd(10))\nprint(evenOrOdd(11))\nThe output is:\neven\nodd\nWhen evenOrOdd is called with an even number as argument, the return statement in line 3 is executed. When the same function is called with an odd number as argument, the return statement in line 5 is executed.\n\nFunctions could return multiple values:\n\n# Accept only positive floating point numbers\ndef bound(x):\n    lower = int(x)\n    upper = lower + 1\n    return lower, upper\n\ny = 7.3\nl, u = bound(y)\nprint(f'{l} &lt; {y} &lt; {u}')\nThe exact mechanism of what happens here will become clear when we come to the lesson on tuples. In line 8, the first value returned by bound is stored in l and the second value returned by bound is stored in u.\n\nFunctions have to be defined before they can be called. The function call cannot come before the definition. For example:\n\n##### Alarm! Wrong code snippet! #####\nprint(f(5))\n\ndef f(x):\n    return x ** 2\n##### Alarm! Wrong code snippet! #####\nWhen the above code is executed, it throws a NameError. Why does this happen? The Python interpreter executes the code from top to bottom. At line 2, f is a name that the interpreter has never seen before and therefore it throws a NameError. Recall that NameError occurs when we try to reference a name that the interpreter has not seen before.\n\nFunction calls could be used in expressions:\n\ndef square(a):\n    return a ** 2\n\nx, y, z = int(input()), int(input()), int(input())\nif square(x) + square(y) == square(z):\n    print(f'{x}, {y} and {z} form the sides of a right triangle with {z} as the hypotenuse')\n\nFunction calls cannot be assigned values:\n\n##### Alarm! Wrong code snippet! #####\ndef foo():\n    return True\n\nfoo() = 1\n##### Alarm! Wrong code snippet! #####\nThe above code throws a SyntaxError.\n\nFunctions can be called from within other functions:\n\ndef foo():\n    print('I am inside foo')\n    \ndef bar():\n    print('I am inside bar')\n    print('I am going to call foo')\n    foo()\n    \nprint('I am outside both foo and bar')\nbar()\nprint('I am outside both foo and bar')\n\nFunctions can be defined inside other functions:\n\ndef foo():\n    def bar():\n        print('bar is inside foo')\n    bar()\n\nfoo()\nTry calling bar() outside foo(). What do you observe?\n\n\n\n\nConsider the following function:\ndef square(x):\n    \"\"\"Return the square of x.\"\"\"\n    return x ** 2\nThe string immediately below the function definition is called a docstring. From the Python docs:\n\nA docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the __doc__ special attribute of that object.\n\nIgnore unfamiliar terms such as “module” and “class”. For now, it is sufficient to focus on functions. Adding the docstring to functions is a good practice. It may not be needed for simple and obvious functions like the one defined above. As the complexity of the functions you write increases, docstrings can be a life safer for other programmers reading your code.\nThe docstring associated with a given function can be accessed using the __doc__ attribute:\nprint(square.__doc__)\nThis gives Return the square of x. as output."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.1.html#functions",
    "href": "notes/chapter-4/lesson-4.1.html#functions",
    "title": "Lesson-4.1",
    "section": "",
    "text": "In mathematics, a function is an object that accepts one or more inputs and produces one or more outputs. For example, \\(f(x) = x^2\\), is a function that accepts a number and returns the square of that number. Functions in Python play a similar role, but are much more richer than their mathematical counterparts. Let us quickly convert the mathematical function, \\(f(x) = x^2\\), into a Python function:\ndef f(x):\n    y = x ** 2\n    return y\nThe code given above is called the definition of function f. #!py def is the keyword used to define functions. f is the name of the function. x is a parameter of the function. Lines 2 and 3 make up the body of the function and are indented. The body of a function is a collection of statements that describe what the function does. At line 3, the value stored in variable y is returned. #!py return is the keyword used for this purpose.\nIf we run the above code, we will not get any output. Functions are not executed unless they are called. The following code demonstrates what a function call looks like:\ndef square(x):\n    y = x ** 2\n    return y\n\nprint(square(2))\nThe output is:\n4\n#!py square(2) is a function call. We use the name of the function, square, and pass the number 2 as an argument to it. The x in the function definition is called the parameter. The value that is passed to the function in the call is called the argument. This is a convention that we will follow throughout this lesson.\nA visual representation of the terms we have defined so far is given below:\n\n\n\nfunctions\n\n\nA mental model to understand functions:\n\nParameters can be thought of as the function’s inputs.\nThe body of the function can be pictured as the sequence of steps that transform the input into the output.\nThe return statement can be thought of as a means of communicating the output to the rest of the code.\n\n\n\n\nWe will look at a wide variety of function definitions. The focus will be on the syntactical aspects of function definitions.\n\nFunctions could have multiple parameters:\n\n# This function computes the area of a rectangle.\n# Length and breadth are the parameters\ndef area(l, b):\n    return l * b\n\nFunctions could have no parameters:\n\ndef foo():\n    return \"I don't like arguments visiting me!\"\n\nFunctions could have no return value:\n\ndef foo():\n    print(\"I don't like talking to the outside world!\")\n    \nfoo()\nWhen the code given above is executed, we get the following output:\nI don't like talking to the outside world!\nNote that we didn’t have to type #!py print(foo()). We just had to call the function — foo() — since it already has the print statement inside it. But what happens if we type #!py print(foo())? We get the following output:\nI don't like talking to the outside world!\nNone\nIf no explicit return statement is present in a function, None is the default value returned by it. When the interpreter comes across the #!py print(foo()) statement, first the function foo() is evaluated. This results in the first line of the output. Since foo() has no explicit return statement, it returns None by default. That is why the second line in the output is None.\n\nA minimal Python function looks like the one given below:\n\ndef foo():\n    pass\n#!py pass is a keyword in Python. When the interpreter comes across a #!py pass statement, it doesn’t perform any computation and moves on to the next line. The reason this is minimal is because it has only those features that are absolutely essential for a function definition to be syntactically valid: function name and at least one statement in the body.\nSuch functions might seem useless at first sight, but they do have their place in programming. While writing a complex piece of code, a coder may realize that they need to define a function to perform a specific task. But they might not know the exact details of the implementation or it may not be an urgent requirement. In such a scenario, they will add a minimal function like the one given above in their code and name it appropriately. Implementing this function will become a task on their to-do list and will be taken up as and when the need arises.\n\nFunctions could have multiple return statements, but the moment the first return is executed, control exits from the function:\n\ndef foo():\n    return 1\n    return 2\nfoo() will always return 1. Line 3 is redundant. An example of a function having multiple returns that are not redundant:\ndef evenOrOdd(n):\n    if n % 2 == 0:\n        return 'even'\n    else:\n        return 'odd'\n\nprint(evenOrOdd(10))\nprint(evenOrOdd(11))\nThe output is:\neven\nodd\nWhen evenOrOdd is called with an even number as argument, the return statement in line 3 is executed. When the same function is called with an odd number as argument, the return statement in line 5 is executed.\n\nFunctions could return multiple values:\n\n# Accept only positive floating point numbers\ndef bound(x):\n    lower = int(x)\n    upper = lower + 1\n    return lower, upper\n\ny = 7.3\nl, u = bound(y)\nprint(f'{l} &lt; {y} &lt; {u}')\nThe exact mechanism of what happens here will become clear when we come to the lesson on tuples. In line 8, the first value returned by bound is stored in l and the second value returned by bound is stored in u.\n\nFunctions have to be defined before they can be called. The function call cannot come before the definition. For example:\n\n##### Alarm! Wrong code snippet! #####\nprint(f(5))\n\ndef f(x):\n    return x ** 2\n##### Alarm! Wrong code snippet! #####\nWhen the above code is executed, it throws a NameError. Why does this happen? The Python interpreter executes the code from top to bottom. At line 2, f is a name that the interpreter has never seen before and therefore it throws a NameError. Recall that NameError occurs when we try to reference a name that the interpreter has not seen before.\n\nFunction calls could be used in expressions:\n\ndef square(a):\n    return a ** 2\n\nx, y, z = int(input()), int(input()), int(input())\nif square(x) + square(y) == square(z):\n    print(f'{x}, {y} and {z} form the sides of a right triangle with {z} as the hypotenuse')\n\nFunction calls cannot be assigned values:\n\n##### Alarm! Wrong code snippet! #####\ndef foo():\n    return True\n\nfoo() = 1\n##### Alarm! Wrong code snippet! #####\nThe above code throws a SyntaxError.\n\nFunctions can be called from within other functions:\n\ndef foo():\n    print('I am inside foo')\n    \ndef bar():\n    print('I am inside bar')\n    print('I am going to call foo')\n    foo()\n    \nprint('I am outside both foo and bar')\nbar()\nprint('I am outside both foo and bar')\n\nFunctions can be defined inside other functions:\n\ndef foo():\n    def bar():\n        print('bar is inside foo')\n    bar()\n\nfoo()\nTry calling bar() outside foo(). What do you observe?\n\n\n\n\nConsider the following function:\ndef square(x):\n    \"\"\"Return the square of x.\"\"\"\n    return x ** 2\nThe string immediately below the function definition is called a docstring. From the Python docs:\n\nA docstring is a string literal that occurs as the first statement in a module, function, class, or method definition. Such a docstring becomes the __doc__ special attribute of that object.\n\nIgnore unfamiliar terms such as “module” and “class”. For now, it is sufficient to focus on functions. Adding the docstring to functions is a good practice. It may not be needed for simple and obvious functions like the one defined above. As the complexity of the functions you write increases, docstrings can be a life safer for other programmers reading your code.\nThe docstring associated with a given function can be accessed using the __doc__ attribute:\nprint(square.__doc__)\nThis gives Return the square of x. as output."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.1.html",
    "href": "notes/chapter-5/lesson-5.1.html",
    "title": "Lesson-5.1",
    "section": "",
    "text": "A list in Python is a data structure that is used to store a sequence of objects. Some examples are given below:\nnumbers = [1, 2, 3, 4, 5]\nletters = ['a', 'b', 'c', 'd']\nwords = ['this', 'is', 'a', 'list']\n\nLists can be printed, just like the other types we have seen so far. print(numbers) will give the following output:\n\n[1, 2, 3, 4, 5]\n\nLists could contain objects of different data types. Python permits lists such as this:\n\nmixture = [1, 1.0, '1', True]\n\nLists have a separate data type - list. We can also check if a given variable holds an object of type list:\n\nnumbers = [1, 2, 3]\nprint(type(numbers))\nprint(isinstance(numbers, list))\n\nThe len function can be used to find the number of elements in a list:\n\nnumbers = [1, 2, 3]\nprint(f'This list has {len(numbers)} elements in it')\n\nLists support indexing and slicing. These two operations work exactly the same way as they did for strings:\n\nnumbers = [1, 2, 3, 4]\nprint(numbers[0], numbers[1], numbers[2], numbers[3])\nprint(numbers[1 : 3])\nprint(numbers[-2])\n\n\n\nAs a list is a sequence, we can iterate through it using for. This is one of the primary uses of the for loop:\n# Method-1\nnumbers = [1, 2, 3, 4]\nfor num in numbers:\n    print(num)\nThe loop variable — num — picks one item at a time from the sequence. In the body of the loop, we are just printing this item. We can rewrite the code given above using a while loop:\n# Method-2\nnumbers = [1, 2, 3, 4]\nindex = 0\nwhile index &lt; len(numbers):\n    print(numbers[index])\n    index += 1\nFinally, we can also use the for loop to iterate through the indices of the list. For this, we take the help of the range function.\n# Method-3\nnumbers = [1, 2, 3, 4]\nfor index in range(len(numbers)):\n    print(numbers[index])\nIn the example given above, len(numbers) is equal to 4. So, the range sequence will be 0, 1, 2, 3. index is the loop variable that iterates through this sequence.\nMethods 2 and 3 are very similar. Both iterate through the sequence of indices, and use list indexing to access the corresponding element in the list. The only difference is that method-2 uses while, while method-3 uses for. Method-1 stands out from the other two as it directly pulls elements from the sequence.\n\n\n\nLists are typically used in problems where we wish to store a collection of items. Usually, we start with an empty list. Python provides two ways to create an empty list:\nlist1 = []\nlist2 = list()\nBoth list1 and list2 are empty lists. The interpreter doesn’t mind spaces between the opening and closing braces, so list1 = [  ] also works. Given an empty list, how do we add items to it? Python provides two ways to do this:\nlist1 = list1 + [1]\nprint(list1)\nlist2 = list2.append(1)\nprint(list2)\nBoth lists end up having just the one element. The first method is called list concatenation, i.e., two lists are being concatenated or combined together. Treat concatenation like joining two compartments of a train together. It is very similar to string concatenation. The second way uses a method called append that is essentially a function defined for the list type. Append adds elements at the end of the list.\nConsider the following problem:\n\nGenerate the list of positive integers less than 100 that are divisible by 3.\n\nThere are at least two ways of doing this. The first one uses while:\n# Method-1\nnum = 3\nnums_div = []\nwhile num &lt; 100:\n    nums_div.append(num)\n    num += 3\nThe next method uses for:\n# Method-2\nnums_div = []\nfor num in range(3, 100, 3):\n    nums_div.append(num)\n\n\n\nWe have already seen how the + operator works with lists:\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist12 = list1 + list2\nprint(list12)\nlist21 = list2 + list1\nprint(list21)\nThis gives the concatenated output:\n[1, 2, 3, 4, 5, 6]\n[4, 5, 6, 1, 2, 3]\nThe order matters when two lists are being concatenated! The next is the * operator:\nlist1 = [0] * 5\nprint(list1)\nlist2 = [1, 2, 3] * 3\nprint(list2)\nThis replicates the list. The following is the output:\n[0, 0, 0, 0, 0]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\nTwo lists are equal if they have the same sequence of elements:\nl1 = [1, 2, 3]\nl2 = [1, 2, 3]\nl3 = [3, 2, 1]\nprint(l1 == l2)\nprint(l2 == l3)\nThis results in:\nTrue\nFalse\nFinally, two lists can be compared with the &gt; or the &lt; operator. List comparison works very similar to string comparison, in that it uses lexicographic ordering. We looked at this in the first chapter:\n\nLexicographic ordering\nFirst element from both lists are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second element of both the lists are compared. This process continues until either list is exhausted.\n\nSome example comparisons:\nprint([1, 2] &lt; [2, 1])\nprint([1] &lt; [1, 2, 3])\nprint([2, 3, 4] &lt; [3])\nprint([] &lt; [1])\nAll four of them result in True.\n\n\n\nLet us look at some built-in functions that operate on lists:\n\nsum: this is used to find the sum of the elements in a list of numbers:\n\na = [1, 2, 3]\nprint(sum(a))\n\nmax and min: these two functions find the maximum and minimum value in a list respectively.\n\na = [1, 2, 3]\nprint(min(a), max(a))\nWhat happens if a is a list of strings? What would max(a) and min(a) produce?\n\nsorted: this function returns a sorted list\n\na = [2, 1, 3]\nprint(sorted(a))\nWe have come across the range object and seen how useful it was in iterating through a sequence. So far range has been associated with the for loop. Its time has come to break out of the loopy prison:\nnumbers = range(10)\nprint(numbers)\nThis gives range(0, 10) as an output. This is a sequence that we can iterate over. Python provides a way of turning this object into a list:\nnumbers = list(range(10))\nprint(numbers)\nThis gives [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] as the output."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.1.html#lists",
    "href": "notes/chapter-5/lesson-5.1.html#lists",
    "title": "Lesson-5.1",
    "section": "",
    "text": "A list in Python is a data structure that is used to store a sequence of objects. Some examples are given below:\nnumbers = [1, 2, 3, 4, 5]\nletters = ['a', 'b', 'c', 'd']\nwords = ['this', 'is', 'a', 'list']\n\nLists can be printed, just like the other types we have seen so far. print(numbers) will give the following output:\n\n[1, 2, 3, 4, 5]\n\nLists could contain objects of different data types. Python permits lists such as this:\n\nmixture = [1, 1.0, '1', True]\n\nLists have a separate data type - list. We can also check if a given variable holds an object of type list:\n\nnumbers = [1, 2, 3]\nprint(type(numbers))\nprint(isinstance(numbers, list))\n\nThe len function can be used to find the number of elements in a list:\n\nnumbers = [1, 2, 3]\nprint(f'This list has {len(numbers)} elements in it')\n\nLists support indexing and slicing. These two operations work exactly the same way as they did for strings:\n\nnumbers = [1, 2, 3, 4]\nprint(numbers[0], numbers[1], numbers[2], numbers[3])\nprint(numbers[1 : 3])\nprint(numbers[-2])\n\n\n\nAs a list is a sequence, we can iterate through it using for. This is one of the primary uses of the for loop:\n# Method-1\nnumbers = [1, 2, 3, 4]\nfor num in numbers:\n    print(num)\nThe loop variable — num — picks one item at a time from the sequence. In the body of the loop, we are just printing this item. We can rewrite the code given above using a while loop:\n# Method-2\nnumbers = [1, 2, 3, 4]\nindex = 0\nwhile index &lt; len(numbers):\n    print(numbers[index])\n    index += 1\nFinally, we can also use the for loop to iterate through the indices of the list. For this, we take the help of the range function.\n# Method-3\nnumbers = [1, 2, 3, 4]\nfor index in range(len(numbers)):\n    print(numbers[index])\nIn the example given above, len(numbers) is equal to 4. So, the range sequence will be 0, 1, 2, 3. index is the loop variable that iterates through this sequence.\nMethods 2 and 3 are very similar. Both iterate through the sequence of indices, and use list indexing to access the corresponding element in the list. The only difference is that method-2 uses while, while method-3 uses for. Method-1 stands out from the other two as it directly pulls elements from the sequence.\n\n\n\nLists are typically used in problems where we wish to store a collection of items. Usually, we start with an empty list. Python provides two ways to create an empty list:\nlist1 = []\nlist2 = list()\nBoth list1 and list2 are empty lists. The interpreter doesn’t mind spaces between the opening and closing braces, so list1 = [  ] also works. Given an empty list, how do we add items to it? Python provides two ways to do this:\nlist1 = list1 + [1]\nprint(list1)\nlist2 = list2.append(1)\nprint(list2)\nBoth lists end up having just the one element. The first method is called list concatenation, i.e., two lists are being concatenated or combined together. Treat concatenation like joining two compartments of a train together. It is very similar to string concatenation. The second way uses a method called append that is essentially a function defined for the list type. Append adds elements at the end of the list.\nConsider the following problem:\n\nGenerate the list of positive integers less than 100 that are divisible by 3.\n\nThere are at least two ways of doing this. The first one uses while:\n# Method-1\nnum = 3\nnums_div = []\nwhile num &lt; 100:\n    nums_div.append(num)\n    num += 3\nThe next method uses for:\n# Method-2\nnums_div = []\nfor num in range(3, 100, 3):\n    nums_div.append(num)\n\n\n\nWe have already seen how the + operator works with lists:\nlist1 = [1, 2, 3]\nlist2 = [4, 5, 6]\nlist12 = list1 + list2\nprint(list12)\nlist21 = list2 + list1\nprint(list21)\nThis gives the concatenated output:\n[1, 2, 3, 4, 5, 6]\n[4, 5, 6, 1, 2, 3]\nThe order matters when two lists are being concatenated! The next is the * operator:\nlist1 = [0] * 5\nprint(list1)\nlist2 = [1, 2, 3] * 3\nprint(list2)\nThis replicates the list. The following is the output:\n[0, 0, 0, 0, 0]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\nTwo lists are equal if they have the same sequence of elements:\nl1 = [1, 2, 3]\nl2 = [1, 2, 3]\nl3 = [3, 2, 1]\nprint(l1 == l2)\nprint(l2 == l3)\nThis results in:\nTrue\nFalse\nFinally, two lists can be compared with the &gt; or the &lt; operator. List comparison works very similar to string comparison, in that it uses lexicographic ordering. We looked at this in the first chapter:\n\nLexicographic ordering\nFirst element from both lists are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second element of both the lists are compared. This process continues until either list is exhausted.\n\nSome example comparisons:\nprint([1, 2] &lt; [2, 1])\nprint([1] &lt; [1, 2, 3])\nprint([2, 3, 4] &lt; [3])\nprint([] &lt; [1])\nAll four of them result in True.\n\n\n\nLet us look at some built-in functions that operate on lists:\n\nsum: this is used to find the sum of the elements in a list of numbers:\n\na = [1, 2, 3]\nprint(sum(a))\n\nmax and min: these two functions find the maximum and minimum value in a list respectively.\n\na = [1, 2, 3]\nprint(min(a), max(a))\nWhat happens if a is a list of strings? What would max(a) and min(a) produce?\n\nsorted: this function returns a sorted list\n\na = [2, 1, 3]\nprint(sorted(a))\nWe have come across the range object and seen how useful it was in iterating through a sequence. So far range has been associated with the for loop. Its time has come to break out of the loopy prison:\nnumbers = range(10)\nprint(numbers)\nThis gives range(0, 10) as an output. This is a sequence that we can iterate over. Python provides a way of turning this object into a list:\nnumbers = list(range(10))\nprint(numbers)\nThis gives [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] as the output."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.4.html",
    "href": "notes/chapter-5/lesson-5.4.html",
    "title": "Lesson-5.4",
    "section": "",
    "text": "We have looked at list methods like append, count and index so far. There are some more interesting methods that will come in handy. insert can be used to insert an element in a list at a given position:\nL = [1, 1, 2, 3, 8]\nL.insert(4, 5)\nprint(L)\nlist.insert(index, object) inserts the object before index in the list. In the code given above, the element 5 is inserted before the index 4 in the list L. Let us try a few more inserts:\nL = [10, 20, 30]\nL.insert(0, 5)          # L becomes [5, 10, 20, 30]\nL.insert(2, 15)         # L becomes [5, 10, 15, 20, 30]\nL.insert(4, 25)         # L becomes [5, 10, 15, 20, 25, 30]\nL.insert(len(L), 35)    # L becomes [5, 10, 15, 20, 25, 30, 35]\nL.insert(20, 40)        # L becomes [5, 10, 15, 20, 25, 30, 35, 40]\nIf the index is greater than the length of the current list, then the element gets added to the end. insert is most useful when an element needs to be inserted at the beginning of a list. Inserting an element at the end can be done using append.\n\n\n\nConsider the following code:\nL = ['a', 'b', 'c', 'd', 'e', 'f']\nindex = 1\nx = L.pop(index)\nprint(f'The element {x} at index {index} was removed from the list')\nprint(f'The current list is {L}')\nL.pop(index) removes the element at index in L and returns it. If no argument is provided to pop, index defaults to -1. index is thus a default argument for the method pop. A default value of -1 means that the last element in the list is removed. To see this an action, execute the following code:\nL = ['a', 'b', 'c', 'd', 'e', 'f']\nx = L.pop()\nprint(f'The current list is {L}')\nWhat happens if you enter an index that is out of range?\n\n\n\nA list can be reversed in-place using the following method:\nL = [1, 2, 3, 4, 5]\nprint('Before:', L, id(L))\nL.reverse()\nprint('After:', L, id(L))\nIt is called in-place because the list before and after have the same id, i.e., they correspond to the same object. One must be careful while using methods that perform operations in-place. A common error is to do something like this:\nL = [1, 2, 3, 4, 5]\nL = L.reverse()\nprint(L)\nThis prints None, which is expected as reverse doesn’t return a list. But sometimes, one may want to hold on to the original copy as well as its reverse. In such cases, we could do the following:\nL = [1, 2, 3, 4, 5]\nL_reversed = L.copy()\nL_reversed.reverse()\nprint('Original list:', L)\nprint('Reversed list:', L_reversed)\nWhy did we have to make a copy in line-2?\n\n\n\nAnother useful method is sort which is used to sort lists in-place:\nL = [2, 1, 5, 6, 4, 3]\nprint('Before', L)\nL.sort()\nprint('After', L)\nThough this appears to be such a simple function to call, sorting is a non-trivial algorithm. We will be studying various algorithms to sort a sequence of items in the next course on data structures and algorithms.\n\n\n\nNow for some destructive functions:\nL = [1, 2, 3, 4, 5] * 2\nprint('Before', L)\nL.remove(1)\nprint('After', L)\nL.remove(x) removes the first (leftmost) occurrence of the element x in the list L. Trying to remove an element that is not there in the list will raise a ValueError with the message list.remove(x): x not in list. A safe way to remove items is as follows:\n# x is the item to be removed; L is the list\nif x in L:\n    L.remove(x)\nHow is remove different from pop?\n\n\n\n\nA list along with the methods append and pop simulate a data structure called stack. A stack is a storage mechanism where the last item added to it is the first item to be removed. This is analogous to a stack of books. The topmost book in the stack is the most recent addition. When we want to remove books from this stack, the topmost book is the first to be removed. There is a catchy mnemonic for this, LIFO: Last In First Out.\n# Start with an empty stack\nstack = [ ]\n# Append items to end of the stack; also called a push operation\nstack.append('Harry Potter and the Philosopher\\'s Stone')\nstack.append('Harry Potter and the Chamber of Secrets')\n# State of the stack \nprint(stack)\n# Remove items from the end of the stack; also called a pop operation\nstack.pop()\n# State of the stack\nprint(stack)\n\n\n\nA list along with the methods insert and pop simulate a data structure called queue. A queue is a storage mechanism where the first item added to it is the first to be removed. This is analogous to any queue that we encounter in real life, say at a billing counter. The first person to stand in the queue, is the first to be served, and naturally the first to exit the queue. The mnemonic for this is FIFO: First in First Out.\n# Start with an empty queue\nqueue = [ ]\n# Insert elements at the beginning of the queue\nqueue.insert(0, 'Customer-1')\nqueue.insert(0, 'Customer-2')\n# State of the queue\nprint(queue)\n# Remove items from the queue\nqueue.pop()\n# State of the queue\nprint(queue)\n\n\n\n\n\nLists make a frequent appearance while processing strings. Consider the following problem:\n\nAccept a sentence as input and find the number of words in it. Assume that it is a simple sentence with a single space separating consecutive words. There are no other punctuation marks in the sentence.\n\nLet us look at a “list-less” solution first:\nSolution-1\nsentence = 'this sentence is false' # a simple sentence\ncount = 1\nfor char in sentence:\n    if char == ' ':\n        count += 1\nprint(count)\nWe just scanned the sentence character by character and checked the number of spaces. The total number of words is one more than the number of spaces. As an aside, the sentence that we are dealing with is an example of a paradoxical statement. It can’t be true or false: if it is true then it is false, if it is false then it is true! Back to Python, we shall look at the solution that uses lists.\nSolution-2\nsentence = 'this sentence is false' # a simple sentence\nwords = sentence.split(' ')         # space is the delimiter used\ncount = len(words)\nprint(count)\nsplit is a string method that splits a string along a delimiter. A delimiter string is one or more characters that specify where to split the string. The output of the split operation is a list of strings that are split along the delimiter. If we print the list words, we get the following list: ['this', 'sentence', 'is', 'false']. Let us take another example:\ncomma_words = 'one,two,three,four'\nnumbers = comma_words.split(',')\nprint(numbers)\nWe get ['one', 'two', 'three', 'four'] as the output. Note that we have specified ',' as the delimiter. The delimiter is not limited to characters, it can be any string. For example:\nsome_string = 'allISwell'\nwords = some_string.split('IS')\nprint(words)\nThe output is: ['all', 'well'].\n\n\n\nJust as we went from a string to a list, we can also move from a list of strings to a string. Consider the following problem:\n\nAccept a sequence of words as input and construct a sentence out of it.\n\nWe will first look at a solution that doesn’t use lists:\nSolution-1\nwords = ['this', 'sentence', 'is', 'false']\nsentence = ''\nfor word in words:\n    sentence += word + ' '\nprint(sentence)\nThough this solution seems correct, it is wrong by one character! Print the last character in the sentence:\nprint(sentence[-1])\nIt is not the letter e but a space. We ended up printing an extra space at the end. This might seem trivial, but programming is all about precision. A better solution is given below:\nSolution-2\nwords = ['this', 'sentence', 'is', 'false']\nsentence = words[0]\nfor word in words[1 : ]:\n    sentence += ' ' + word\nprint(sentence)\nThis is more accurate. But it seems clumsy as we had to iterate from the second word in the list. The final solution uses a simple method and is quite sophisticated.\nSolution-3\nwords = ['this', 'sentence', 'is', 'false']\nsentence = ' '.join(words)\nprint(sentence)\nIsn’t that a thing of beauty! Just as split chops a string along a delimiter, join stitches together the strings in a list, and the thread it uses is a space in this case. We could also stitch them together using any other string, let us use a comma instead:\nwords = ['one', 'two', 'three']\nsentence = ','.join(words)\nprint(sentence)\nThis output is one,two,three. The stitching seems too tight. Let us give it some space:\nwords = ['one', 'two', 'three']\nsentence = ', '.join(words)\nprint(sentence)\nNotice the space after the comma. The output is one, two, three."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.4.html#lists",
    "href": "notes/chapter-5/lesson-5.4.html#lists",
    "title": "Lesson-5.4",
    "section": "",
    "text": "We have looked at list methods like append, count and index so far. There are some more interesting methods that will come in handy. insert can be used to insert an element in a list at a given position:\nL = [1, 1, 2, 3, 8]\nL.insert(4, 5)\nprint(L)\nlist.insert(index, object) inserts the object before index in the list. In the code given above, the element 5 is inserted before the index 4 in the list L. Let us try a few more inserts:\nL = [10, 20, 30]\nL.insert(0, 5)          # L becomes [5, 10, 20, 30]\nL.insert(2, 15)         # L becomes [5, 10, 15, 20, 30]\nL.insert(4, 25)         # L becomes [5, 10, 15, 20, 25, 30]\nL.insert(len(L), 35)    # L becomes [5, 10, 15, 20, 25, 30, 35]\nL.insert(20, 40)        # L becomes [5, 10, 15, 20, 25, 30, 35, 40]\nIf the index is greater than the length of the current list, then the element gets added to the end. insert is most useful when an element needs to be inserted at the beginning of a list. Inserting an element at the end can be done using append.\n\n\n\nConsider the following code:\nL = ['a', 'b', 'c', 'd', 'e', 'f']\nindex = 1\nx = L.pop(index)\nprint(f'The element {x} at index {index} was removed from the list')\nprint(f'The current list is {L}')\nL.pop(index) removes the element at index in L and returns it. If no argument is provided to pop, index defaults to -1. index is thus a default argument for the method pop. A default value of -1 means that the last element in the list is removed. To see this an action, execute the following code:\nL = ['a', 'b', 'c', 'd', 'e', 'f']\nx = L.pop()\nprint(f'The current list is {L}')\nWhat happens if you enter an index that is out of range?\n\n\n\nA list can be reversed in-place using the following method:\nL = [1, 2, 3, 4, 5]\nprint('Before:', L, id(L))\nL.reverse()\nprint('After:', L, id(L))\nIt is called in-place because the list before and after have the same id, i.e., they correspond to the same object. One must be careful while using methods that perform operations in-place. A common error is to do something like this:\nL = [1, 2, 3, 4, 5]\nL = L.reverse()\nprint(L)\nThis prints None, which is expected as reverse doesn’t return a list. But sometimes, one may want to hold on to the original copy as well as its reverse. In such cases, we could do the following:\nL = [1, 2, 3, 4, 5]\nL_reversed = L.copy()\nL_reversed.reverse()\nprint('Original list:', L)\nprint('Reversed list:', L_reversed)\nWhy did we have to make a copy in line-2?\n\n\n\nAnother useful method is sort which is used to sort lists in-place:\nL = [2, 1, 5, 6, 4, 3]\nprint('Before', L)\nL.sort()\nprint('After', L)\nThough this appears to be such a simple function to call, sorting is a non-trivial algorithm. We will be studying various algorithms to sort a sequence of items in the next course on data structures and algorithms.\n\n\n\nNow for some destructive functions:\nL = [1, 2, 3, 4, 5] * 2\nprint('Before', L)\nL.remove(1)\nprint('After', L)\nL.remove(x) removes the first (leftmost) occurrence of the element x in the list L. Trying to remove an element that is not there in the list will raise a ValueError with the message list.remove(x): x not in list. A safe way to remove items is as follows:\n# x is the item to be removed; L is the list\nif x in L:\n    L.remove(x)\nHow is remove different from pop?\n\n\n\n\nA list along with the methods append and pop simulate a data structure called stack. A stack is a storage mechanism where the last item added to it is the first item to be removed. This is analogous to a stack of books. The topmost book in the stack is the most recent addition. When we want to remove books from this stack, the topmost book is the first to be removed. There is a catchy mnemonic for this, LIFO: Last In First Out.\n# Start with an empty stack\nstack = [ ]\n# Append items to end of the stack; also called a push operation\nstack.append('Harry Potter and the Philosopher\\'s Stone')\nstack.append('Harry Potter and the Chamber of Secrets')\n# State of the stack \nprint(stack)\n# Remove items from the end of the stack; also called a pop operation\nstack.pop()\n# State of the stack\nprint(stack)\n\n\n\nA list along with the methods insert and pop simulate a data structure called queue. A queue is a storage mechanism where the first item added to it is the first to be removed. This is analogous to any queue that we encounter in real life, say at a billing counter. The first person to stand in the queue, is the first to be served, and naturally the first to exit the queue. The mnemonic for this is FIFO: First in First Out.\n# Start with an empty queue\nqueue = [ ]\n# Insert elements at the beginning of the queue\nqueue.insert(0, 'Customer-1')\nqueue.insert(0, 'Customer-2')\n# State of the queue\nprint(queue)\n# Remove items from the queue\nqueue.pop()\n# State of the queue\nprint(queue)\n\n\n\n\n\nLists make a frequent appearance while processing strings. Consider the following problem:\n\nAccept a sentence as input and find the number of words in it. Assume that it is a simple sentence with a single space separating consecutive words. There are no other punctuation marks in the sentence.\n\nLet us look at a “list-less” solution first:\nSolution-1\nsentence = 'this sentence is false' # a simple sentence\ncount = 1\nfor char in sentence:\n    if char == ' ':\n        count += 1\nprint(count)\nWe just scanned the sentence character by character and checked the number of spaces. The total number of words is one more than the number of spaces. As an aside, the sentence that we are dealing with is an example of a paradoxical statement. It can’t be true or false: if it is true then it is false, if it is false then it is true! Back to Python, we shall look at the solution that uses lists.\nSolution-2\nsentence = 'this sentence is false' # a simple sentence\nwords = sentence.split(' ')         # space is the delimiter used\ncount = len(words)\nprint(count)\nsplit is a string method that splits a string along a delimiter. A delimiter string is one or more characters that specify where to split the string. The output of the split operation is a list of strings that are split along the delimiter. If we print the list words, we get the following list: ['this', 'sentence', 'is', 'false']. Let us take another example:\ncomma_words = 'one,two,three,four'\nnumbers = comma_words.split(',')\nprint(numbers)\nWe get ['one', 'two', 'three', 'four'] as the output. Note that we have specified ',' as the delimiter. The delimiter is not limited to characters, it can be any string. For example:\nsome_string = 'allISwell'\nwords = some_string.split('IS')\nprint(words)\nThe output is: ['all', 'well'].\n\n\n\nJust as we went from a string to a list, we can also move from a list of strings to a string. Consider the following problem:\n\nAccept a sequence of words as input and construct a sentence out of it.\n\nWe will first look at a solution that doesn’t use lists:\nSolution-1\nwords = ['this', 'sentence', 'is', 'false']\nsentence = ''\nfor word in words:\n    sentence += word + ' '\nprint(sentence)\nThough this solution seems correct, it is wrong by one character! Print the last character in the sentence:\nprint(sentence[-1])\nIt is not the letter e but a space. We ended up printing an extra space at the end. This might seem trivial, but programming is all about precision. A better solution is given below:\nSolution-2\nwords = ['this', 'sentence', 'is', 'false']\nsentence = words[0]\nfor word in words[1 : ]:\n    sentence += ' ' + word\nprint(sentence)\nThis is more accurate. But it seems clumsy as we had to iterate from the second word in the list. The final solution uses a simple method and is quite sophisticated.\nSolution-3\nwords = ['this', 'sentence', 'is', 'false']\nsentence = ' '.join(words)\nprint(sentence)\nIsn’t that a thing of beauty! Just as split chops a string along a delimiter, join stitches together the strings in a list, and the thread it uses is a space in this case. We could also stitch them together using any other string, let us use a comma instead:\nwords = ['one', 'two', 'three']\nsentence = ','.join(words)\nprint(sentence)\nThis output is one,two,three. The stitching seems too tight. Let us give it some space:\nwords = ['one', 'two', 'three']\nsentence = ', '.join(words)\nprint(sentence)\nNotice the space after the comma. The output is one, two, three."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.5.html",
    "href": "notes/chapter-5/lesson-5.5.html",
    "title": "Lesson-5.5",
    "section": "",
    "text": "Recall the runs list that we generated with the help of the random library:\nimport random\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], \n                      weights = [30, 30, 20, 5, 10, 0, 5], \n                      k = 120)\nassert len(runs) == 120\nAn assert statement is used whenever we wish to verify if some aspect of our code is working as intended. For example, in line-5 of the code given above, we are making sure that the length of the list is 120. This is a useful check to have as subsequent computation will depend upon this. If the conditional expression following the assert keyword is True, then control transfers to the next line. If it is False, the interpreter raises an AssertionError.\nLet us look at a different way of organizing the information contained in runs:\novers = list()\nnew_over = list()\nfor ball, run in enumerate(runs):\n    new_over.append(run)\n    if (ball + 1) % 6 == 0:\n        overs.append(new_over)\n        new_over = list()\novers is a nested list, which is nothing but a list of lists. Each element in overs corresponds to an over in the match and is represented by a list that contains the runs scored in that over. The following code does a quick check if the sizes of the outer and inner lists are 20 and 6 respectively.\nassert len(overs) == 20\nfor over in overs:\n    assert len(over) == 6\nWith this representation in place, how many runs were scored in the fourth ball of the third over?\nanswer = overs[2][3]    # zero-indexing\nprint(answer)\nThe first index corresponds to the outer list while the second index corresponds to the inner list. If this is still confusing, print the following code to convince yourself:\nthird_over = overs[2]\nprint(third_over)\nfourth_ball = third_over[3]\nprint(fourth_ball)\nassert fourth_ball == overs[2][3]\n\n\n\nMatrices are 2D objects. We can represent them as nested lists. Let us first populate a \\(3 \\times 3\\) matrix of zeros:\n\n\n\nMatrices\n\n\nmat = [ ]\nfor i in range(3):\n    mat.append([ ])     # we are appending an empty list\n    for _ in range(3):\n        mat[i].append(0)\nprint(mat)\nThis gives the following output:\n[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\nDo you find anything odd in line-4? We have used _ as a loop variable. The inner-loop variable is insignificant and never gets used anywhere. As a convention, we use the _ to represent such variables whose sole purpose is to uphold the syntax of the language. Let us now construct another matrix:\nmat = [ ]\nnum = 1\nfor i in range(3):\n    mat.append([ ])\n    for _ in range(3):\n        mat[i].append(num)\n        num += 1\nprint(mat)\nThis gives the following output:\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nThe code given above to construct this matrix could be written in the following manner as well:\nmat = [ ]\nnum = 1\nfor _ in range(3):\n    row = [ ]\n    for _ in range(3):\n        row.append(num)\n        num += 1\n    mat.append(row)\nprint(mat)\n\n\n\nConsider the following code:\nmat1 = [[1, 2], [3, 4]]\nmat2 = mat1\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\nWe already know what will happen here. Lists are mutable. mat2 is just an alias for mat1 and both point to the same object. Modifying any one of them will modify both. We also saw three different methods to copy lists so that modifying one doesn’t modify the other. Let us try one of them:\nmat2 = mat1.copy()\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\nNo problems so far. But try this:\nmat1 = [[1, 2], [3, 4]]\nmat2 = mat1.copy()\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\nThis is the output we get:\n[[100, 2], [3, 4]]\n[[100, 2], [3, 4]]\nWhat is happening here? mat1 has also changed! Wasn’t copy supposed to get rid of this difficulty? We have a mutable object inside another mutable object. In such a case copy just does a shallow copy; only a new outer-list object is produced. This means that the inner lists in mat1 and mat2 are still the same objects:\nprint(mat1[0] is mat2[0])\nprint(mat1[1] is mat2[1])\nBoth lines print True. In order to make a copy where both the inner and outer lists are new objects, we turn to deepcopy:\nfrom copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\nThis gives the output:\n[[1, 2], [3, 4]]\n[[100, 2], [3, 4]]\nFinally we have two completely different objects:\nfrom copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nprint(mat1 is not mat2)\nprint(mat1[0] is not mat2[0])\nprint(mat1[1] is not mat2[1])\nAll three print True! deepcopy is a function from the library copy. We won’t enter into how it works. Suffice to say that when using nested lists or any collection of mutable objects, use deepcopy if you wish to make a clean copy."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.5.html#lists",
    "href": "notes/chapter-5/lesson-5.5.html#lists",
    "title": "Lesson-5.5",
    "section": "",
    "text": "Recall the runs list that we generated with the help of the random library:\nimport random\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], \n                      weights = [30, 30, 20, 5, 10, 0, 5], \n                      k = 120)\nassert len(runs) == 120\nAn assert statement is used whenever we wish to verify if some aspect of our code is working as intended. For example, in line-5 of the code given above, we are making sure that the length of the list is 120. This is a useful check to have as subsequent computation will depend upon this. If the conditional expression following the assert keyword is True, then control transfers to the next line. If it is False, the interpreter raises an AssertionError.\nLet us look at a different way of organizing the information contained in runs:\novers = list()\nnew_over = list()\nfor ball, run in enumerate(runs):\n    new_over.append(run)\n    if (ball + 1) % 6 == 0:\n        overs.append(new_over)\n        new_over = list()\novers is a nested list, which is nothing but a list of lists. Each element in overs corresponds to an over in the match and is represented by a list that contains the runs scored in that over. The following code does a quick check if the sizes of the outer and inner lists are 20 and 6 respectively.\nassert len(overs) == 20\nfor over in overs:\n    assert len(over) == 6\nWith this representation in place, how many runs were scored in the fourth ball of the third over?\nanswer = overs[2][3]    # zero-indexing\nprint(answer)\nThe first index corresponds to the outer list while the second index corresponds to the inner list. If this is still confusing, print the following code to convince yourself:\nthird_over = overs[2]\nprint(third_over)\nfourth_ball = third_over[3]\nprint(fourth_ball)\nassert fourth_ball == overs[2][3]\n\n\n\nMatrices are 2D objects. We can represent them as nested lists. Let us first populate a \\(3 \\times 3\\) matrix of zeros:\n\n\n\nMatrices\n\n\nmat = [ ]\nfor i in range(3):\n    mat.append([ ])     # we are appending an empty list\n    for _ in range(3):\n        mat[i].append(0)\nprint(mat)\nThis gives the following output:\n[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\nDo you find anything odd in line-4? We have used _ as a loop variable. The inner-loop variable is insignificant and never gets used anywhere. As a convention, we use the _ to represent such variables whose sole purpose is to uphold the syntax of the language. Let us now construct another matrix:\nmat = [ ]\nnum = 1\nfor i in range(3):\n    mat.append([ ])\n    for _ in range(3):\n        mat[i].append(num)\n        num += 1\nprint(mat)\nThis gives the following output:\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nThe code given above to construct this matrix could be written in the following manner as well:\nmat = [ ]\nnum = 1\nfor _ in range(3):\n    row = [ ]\n    for _ in range(3):\n        row.append(num)\n        num += 1\n    mat.append(row)\nprint(mat)\n\n\n\nConsider the following code:\nmat1 = [[1, 2], [3, 4]]\nmat2 = mat1\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\nWe already know what will happen here. Lists are mutable. mat2 is just an alias for mat1 and both point to the same object. Modifying any one of them will modify both. We also saw three different methods to copy lists so that modifying one doesn’t modify the other. Let us try one of them:\nmat2 = mat1.copy()\nmat2.append([5, 6])\nprint(mat1)\nprint(mat2)\nprint(mat1 is mat2)\nNo problems so far. But try this:\nmat1 = [[1, 2], [3, 4]]\nmat2 = mat1.copy()\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\nThis is the output we get:\n[[100, 2], [3, 4]]\n[[100, 2], [3, 4]]\nWhat is happening here? mat1 has also changed! Wasn’t copy supposed to get rid of this difficulty? We have a mutable object inside another mutable object. In such a case copy just does a shallow copy; only a new outer-list object is produced. This means that the inner lists in mat1 and mat2 are still the same objects:\nprint(mat1[0] is mat2[0])\nprint(mat1[1] is mat2[1])\nBoth lines print True. In order to make a copy where both the inner and outer lists are new objects, we turn to deepcopy:\nfrom copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nmat2[0][0] = 100\nprint(mat1)\nprint(mat2)\nThis gives the output:\n[[1, 2], [3, 4]]\n[[100, 2], [3, 4]]\nFinally we have two completely different objects:\nfrom copy import deepcopy\nmat1 = [[1, 2], [3, 4]]\nmat2 = deepcopy(mat1)\nprint(mat1 is not mat2)\nprint(mat1[0] is not mat2[0])\nprint(mat1[1] is not mat2[1])\nAll three print True! deepcopy is a function from the library copy. We won’t enter into how it works. Suffice to say that when using nested lists or any collection of mutable objects, use deepcopy if you wish to make a clean copy."
  },
  {
    "objectID": "notes/chapter-6/lesson-6.1.html",
    "href": "notes/chapter-6/lesson-6.1.html",
    "title": "Lesson-6.1",
    "section": "",
    "text": "Let us assume that we want to store the following information in Python:\n\n\n\n\nCountry\nCapital\n\n\n\n\nBrazil\nBrasilia\n\n\nRussia\nMoscow\n\n\nIndia\nNew Delhi\n\n\nChina\nBeijing\n\n\nSouth Africa\nCape Town\n\n\n\n\nA minor geographical observation: South Africa has three capitals; we have only mentioned the legislative capital for convenience. A geopolitical point: these five countries form a part of a block called BRICS [refer].\nComing back to Python, a dictionary is possibly the most interesting data structure offered by Python. It is basically a look-up table. This is how we would store the details of the BRICS nations and their capitals:\nbrics = {\n            'Brazil': 'Brasilia', \n            'Russia': 'Moscow', \n            'India': 'New Delhi', \n            'China': 'Beijing', \n            'South Africa': 'Cape Town'\n}\nA dictionary is a collection of key-value pairs. In the code given above, brics is a dictionary. It has countries mapped to their respective capitals. For instance, #!py 'India' is mapped to #!py 'New Delhi'. Here, #!py 'India' is the key and #!py 'New Delhi' is the value. That is, the country is the key and its capital is the value. A dictionary object is of type #!py dict:\nprint(type(brics))\nprint(isinstance(brics, dict))\nTo access the value corresponding to a given key, we do the following:\nprint(brics['India'], 'is the capital of', 'India')\nprint(brics['China'], 'is the capital of', 'China')\nThe value corresponding to a given key can be updated:\n# Moving to a different capital for South Africa\nbrics['South Africa'] = 'Pretoria'\n# Or we could also store all three capitals\nbrics['South Africa'] = ('Pretoria', 'Cape Town', 'Bloemfontein')\nNew key-value pairs can be added to a dictionary. Let us expand the horizons of our dictionary to include countries outside the BRICS nations. It no longer makes sense to call this brics, so let us create a new dictionary called globe which starts off as a copy of brics. Recall the #!py copy() method that we used to copy lists. A similar method is defined for dictionaries:\nbrics = {\n            'Brazil': 'Brasilia', \n            'Russia': 'Moscow', \n            'India': 'New Delhi', \n            'China': 'Beijing', \n            'South Africa': 'Cape Town'\n        }\nglobe = brics.copy()\nglobe['Spain'] = 'Madrid' \nAdding a new key-value pair is as simple as the statement given in line 9 of the code given above. Keys of a dictionary are unique. This means that a dictionary cannot have two or more identical keys mapped to different values. On the other hand, two different keys could have the same value. For example:\nsome_dict = {'key_1': 0, 'key_2': 0}\nTrying to access a key that is not present in the dictionary will result in a #!py KeyError:\n##### Alarm! Wrong code snippet! ######\nsome_dict = {'0': 'zero', '1': 'one'}\nprint(some_dict[0])\n##### Alarm! Wrong code snippet! ######\n\n\n\nThe key of a dictionary can be any immutable object. There is a small catch here. We will return to this constraint in the next section. Let us look at different combinations key-value pairs that are possible beginning with the basic types: #!py int, #!py str, #!py float, #!py bool:\n# int &lt;&gt; int\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n# str &lt;&gt; int\nmonths = {'Jan': 31, 'March': 31, 'May': 31, 'Nov': 30}\n# int &lt;&gt; str\nroll_numbers = {1: 'CS001', 2: 'CS002', 3: 'CS003'}\n# str &lt;&gt; str\nnames = {'Rohit': 'Sharma', 'Saina': 'Nehwal'}\n# str &lt;&gt; float\nconstants = {'pi': 3.14, 'e': 2.71}\n# float &lt;&gt; str\nfractions = {0.5: 'half', 0.25: 'quarter', 0.3: 'one-third'}\n# int &lt;&gt; bool\nbinary = {0: True, 1: False}\nNext, we have dictionaries that have #!py list and #!py tuple as the type of their values:\n# str &lt;&gt; list\noutcomes = {'IND VS AUS': ['IND', 'AUS', 'IND', 'IND'], 'IND VS ENG': ['IND', 'ENG']}\n# float &lt;&gt; tuple\nbounds = {1.7: (1, 2), 4.3: (4, 5), -1.2: (-2, -1)}\nTuples can be keys, provided they don’t contain any mutable objects within them:\n# tuple &lt;&gt; list\nT1, T2 = (0, 1), (1, 2)\nrandom_numbers = {T1: [0.1, 0.4, 0.9], T2: [1.1, 1.9]}\nTowards the end, we will look at an example where a tuple cannot be a key. Finally, the richness of dictionaries comes out in the following example:\n# mixed\nreport_card = {\n                'name': 'Ramanujan',\n                'age': 18,\n                'school': 'KV',\n                'marks': (75, 80, 60, 95, 100)\n              }\n\n\n\nEarlier, we have mentioned that the keys of dictionaries have to be immutable, but this statement is not entirely accurate. In this section, we will explore why. What happens if we use a list as a key?\n##### Alarm! Wrong code snippet #####\nsome_list = [0, 1]\nbad_dict = {some_list: 0}\n##### Alarm! Wrong code snippet #####\nIt throws a #!py TypeError with the following message: unhashable type: 'list'. A list cannot be a key in a dictionary; but the error message doesn’t talk about immutability, instead it says that the #!py list type is unhashable. A more accurate statement about keys in a dictionary is given below:\n\nThe keys of a dictionary must be hashable.\n\nTo understand what we mean by the term hashable, we shall briefly look at the way Python implements dictionaries. The following section on hash tables is a bit involved and can be skipped.\n\n\nPython dictionaries are implemented using a data structure called a hash table. It is best to think about a hash table as a book-rack that has a number of rows. Picture the key-value pairs as books that are going to be stored in these racks. To access a book, we need to know the row number in which it is present. This is where the idea of a hash function comes in. The hash function is denoted by \\(h\\) and converts the key to the row number.\nThe hash function accepts a key \\(k\\) as input and returns a value, \\(h(k)\\), as output. This is called the hash value. In our analogy, the hash value is synonymous with the rack number. Once we know the rack number, the book (key-value) stored in it can be easily retrieved. The description is somewhat naive, but you get the point.\nNow, an object in Python is hashable if it has a hash value which never changes during its lifetime and can be compared to other objects. Most of the immutable objects that we have seen so far are hashable: #!py int, #!py float, #!py str, #!py bool. Mutable containers such as lists are not hashable. So, can we just go back to the original definition and claim that all immutable objects can be used as keys in dictionaries? No! Consider the following example:\n##### Alarm! Wrong code snippet #####\nsome_tuple = ([0, 1], [2, 3])\nbad_dict = {some_tuple: 0}\n##### Alarm! Wrong code snippet #####\nThough some_tuple is immutable, it contains a sequence of lists which are mutable. According to the Python documentation, immutable containers are hashable only if their elements are hashable. So, some_tuple is not hashable, and hence it cannot be used as a key! For a better explanation, check out the docs.\n\n\n\n\nWe can iterate over the keys of a dictionary:\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key in squares.keys():\n    print(f'The square of {key} is {squares[key]}')\n#!py squares.keys() returns a sequence of keys over which we can iterate. Python makes things even more simple and lets us drop the keys method.\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key in squares:\n    print(f'The square of {key} is {squares[key]}')\nWe can also iterate over the key-value pairs in a dictionary:\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key, value in squares.items():\n    print(f'The square of {key} is {value}')\n\n\n\nAn empty dictionary can be defined in one of the following ways:\nD1 = dict()\nD1[0] = 1\nD2 = { }\nD2[0] = 1\nLet us now solve the following problem:\n!!! question ” ” Ceate a dictionary from a list of words that maps words to their lengths.\n??? success \"Solution\"\n\n    ```python\n    words = ['interstellar', 'dunkirk', 'inception', 'tenet']\n    lengths = dict()\n    for word in words:\n        lengths[word] = len(word)\n    print(lengths)\n    ```\n\n    A piece of trivia: what is common among the words in the list `words`? \n\n\n\n\nLike lists dictionaries are mutable objects. To see the mutability of #!py dict objects in action, consider the following code:\ndict_1 = {'one': 1, 'two': 2, 'three': 3}\ndict_2 = dict_1\ndict_2['four'] = 4\nprint(dict_1, dict_2)\nprint(dict_1 is dict_2)\nWe see that dict_2 is alias of dict_1 and both point to the same object. If we want a new #!py dict object with the same contents as dict_1, we could either use the #!py copy() method or the #!py dict built-in function:\ndict_1 = {'one': 1, 'two': 2, 'three': 3}\ndict_2 = dict_1.copy()      # dict(dict_1) also works\ndict_2['four'] = 4\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nThe last line prints True which confirms that we have two different objects. So modifying one doesn’t affect the other. But note that #!py copy() only produces a shallow copy. As long as the values are immutable, this doesn’t matter. But if we have mutable values, then we have a problem:\ndict_1 = {'one': [1], 'two': [1, 1], 'three': [1, 1, 1]}\ndict_2 = dict_1.copy()\ndict_2['one'].append(100)\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nprint(dict_1['one'] is dict_2['one'])\nHere, we see that the value corresponding to the key #!py 'one' in both dictionaries gets affected. This is because #!py dict_1['one'] and #!py dict_2['one'] are still the same object. This can be seen from the last statement of the code given above. To set this right, we need to do a deepcopy:\nfrom copy import deepcopy\ndict_1 = {'one': [1], 'two': [1, 1], 'three': [1, 1, 1]}\ndict_2 = deepcopy(dict_1)\ndict_2['one'].append(100)\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nprint(dict_1['one'] is not dict_2['one'])"
  },
  {
    "objectID": "notes/chapter-6/lesson-6.1.html#dictionaries",
    "href": "notes/chapter-6/lesson-6.1.html#dictionaries",
    "title": "Lesson-6.1",
    "section": "",
    "text": "Let us assume that we want to store the following information in Python:\n\n\n\n\nCountry\nCapital\n\n\n\n\nBrazil\nBrasilia\n\n\nRussia\nMoscow\n\n\nIndia\nNew Delhi\n\n\nChina\nBeijing\n\n\nSouth Africa\nCape Town\n\n\n\n\nA minor geographical observation: South Africa has three capitals; we have only mentioned the legislative capital for convenience. A geopolitical point: these five countries form a part of a block called BRICS [refer].\nComing back to Python, a dictionary is possibly the most interesting data structure offered by Python. It is basically a look-up table. This is how we would store the details of the BRICS nations and their capitals:\nbrics = {\n            'Brazil': 'Brasilia', \n            'Russia': 'Moscow', \n            'India': 'New Delhi', \n            'China': 'Beijing', \n            'South Africa': 'Cape Town'\n}\nA dictionary is a collection of key-value pairs. In the code given above, brics is a dictionary. It has countries mapped to their respective capitals. For instance, #!py 'India' is mapped to #!py 'New Delhi'. Here, #!py 'India' is the key and #!py 'New Delhi' is the value. That is, the country is the key and its capital is the value. A dictionary object is of type #!py dict:\nprint(type(brics))\nprint(isinstance(brics, dict))\nTo access the value corresponding to a given key, we do the following:\nprint(brics['India'], 'is the capital of', 'India')\nprint(brics['China'], 'is the capital of', 'China')\nThe value corresponding to a given key can be updated:\n# Moving to a different capital for South Africa\nbrics['South Africa'] = 'Pretoria'\n# Or we could also store all three capitals\nbrics['South Africa'] = ('Pretoria', 'Cape Town', 'Bloemfontein')\nNew key-value pairs can be added to a dictionary. Let us expand the horizons of our dictionary to include countries outside the BRICS nations. It no longer makes sense to call this brics, so let us create a new dictionary called globe which starts off as a copy of brics. Recall the #!py copy() method that we used to copy lists. A similar method is defined for dictionaries:\nbrics = {\n            'Brazil': 'Brasilia', \n            'Russia': 'Moscow', \n            'India': 'New Delhi', \n            'China': 'Beijing', \n            'South Africa': 'Cape Town'\n        }\nglobe = brics.copy()\nglobe['Spain'] = 'Madrid' \nAdding a new key-value pair is as simple as the statement given in line 9 of the code given above. Keys of a dictionary are unique. This means that a dictionary cannot have two or more identical keys mapped to different values. On the other hand, two different keys could have the same value. For example:\nsome_dict = {'key_1': 0, 'key_2': 0}\nTrying to access a key that is not present in the dictionary will result in a #!py KeyError:\n##### Alarm! Wrong code snippet! ######\nsome_dict = {'0': 'zero', '1': 'one'}\nprint(some_dict[0])\n##### Alarm! Wrong code snippet! ######\n\n\n\nThe key of a dictionary can be any immutable object. There is a small catch here. We will return to this constraint in the next section. Let us look at different combinations key-value pairs that are possible beginning with the basic types: #!py int, #!py str, #!py float, #!py bool:\n# int &lt;&gt; int\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n# str &lt;&gt; int\nmonths = {'Jan': 31, 'March': 31, 'May': 31, 'Nov': 30}\n# int &lt;&gt; str\nroll_numbers = {1: 'CS001', 2: 'CS002', 3: 'CS003'}\n# str &lt;&gt; str\nnames = {'Rohit': 'Sharma', 'Saina': 'Nehwal'}\n# str &lt;&gt; float\nconstants = {'pi': 3.14, 'e': 2.71}\n# float &lt;&gt; str\nfractions = {0.5: 'half', 0.25: 'quarter', 0.3: 'one-third'}\n# int &lt;&gt; bool\nbinary = {0: True, 1: False}\nNext, we have dictionaries that have #!py list and #!py tuple as the type of their values:\n# str &lt;&gt; list\noutcomes = {'IND VS AUS': ['IND', 'AUS', 'IND', 'IND'], 'IND VS ENG': ['IND', 'ENG']}\n# float &lt;&gt; tuple\nbounds = {1.7: (1, 2), 4.3: (4, 5), -1.2: (-2, -1)}\nTuples can be keys, provided they don’t contain any mutable objects within them:\n# tuple &lt;&gt; list\nT1, T2 = (0, 1), (1, 2)\nrandom_numbers = {T1: [0.1, 0.4, 0.9], T2: [1.1, 1.9]}\nTowards the end, we will look at an example where a tuple cannot be a key. Finally, the richness of dictionaries comes out in the following example:\n# mixed\nreport_card = {\n                'name': 'Ramanujan',\n                'age': 18,\n                'school': 'KV',\n                'marks': (75, 80, 60, 95, 100)\n              }\n\n\n\nEarlier, we have mentioned that the keys of dictionaries have to be immutable, but this statement is not entirely accurate. In this section, we will explore why. What happens if we use a list as a key?\n##### Alarm! Wrong code snippet #####\nsome_list = [0, 1]\nbad_dict = {some_list: 0}\n##### Alarm! Wrong code snippet #####\nIt throws a #!py TypeError with the following message: unhashable type: 'list'. A list cannot be a key in a dictionary; but the error message doesn’t talk about immutability, instead it says that the #!py list type is unhashable. A more accurate statement about keys in a dictionary is given below:\n\nThe keys of a dictionary must be hashable.\n\nTo understand what we mean by the term hashable, we shall briefly look at the way Python implements dictionaries. The following section on hash tables is a bit involved and can be skipped.\n\n\nPython dictionaries are implemented using a data structure called a hash table. It is best to think about a hash table as a book-rack that has a number of rows. Picture the key-value pairs as books that are going to be stored in these racks. To access a book, we need to know the row number in which it is present. This is where the idea of a hash function comes in. The hash function is denoted by \\(h\\) and converts the key to the row number.\nThe hash function accepts a key \\(k\\) as input and returns a value, \\(h(k)\\), as output. This is called the hash value. In our analogy, the hash value is synonymous with the rack number. Once we know the rack number, the book (key-value) stored in it can be easily retrieved. The description is somewhat naive, but you get the point.\nNow, an object in Python is hashable if it has a hash value which never changes during its lifetime and can be compared to other objects. Most of the immutable objects that we have seen so far are hashable: #!py int, #!py float, #!py str, #!py bool. Mutable containers such as lists are not hashable. So, can we just go back to the original definition and claim that all immutable objects can be used as keys in dictionaries? No! Consider the following example:\n##### Alarm! Wrong code snippet #####\nsome_tuple = ([0, 1], [2, 3])\nbad_dict = {some_tuple: 0}\n##### Alarm! Wrong code snippet #####\nThough some_tuple is immutable, it contains a sequence of lists which are mutable. According to the Python documentation, immutable containers are hashable only if their elements are hashable. So, some_tuple is not hashable, and hence it cannot be used as a key! For a better explanation, check out the docs.\n\n\n\n\nWe can iterate over the keys of a dictionary:\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key in squares.keys():\n    print(f'The square of {key} is {squares[key]}')\n#!py squares.keys() returns a sequence of keys over which we can iterate. Python makes things even more simple and lets us drop the keys method.\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key in squares:\n    print(f'The square of {key} is {squares[key]}')\nWe can also iterate over the key-value pairs in a dictionary:\nsquares = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}    # key is a number, value is its square\nfor key, value in squares.items():\n    print(f'The square of {key} is {value}')\n\n\n\nAn empty dictionary can be defined in one of the following ways:\nD1 = dict()\nD1[0] = 1\nD2 = { }\nD2[0] = 1\nLet us now solve the following problem:\n!!! question ” ” Ceate a dictionary from a list of words that maps words to their lengths.\n??? success \"Solution\"\n\n    ```python\n    words = ['interstellar', 'dunkirk', 'inception', 'tenet']\n    lengths = dict()\n    for word in words:\n        lengths[word] = len(word)\n    print(lengths)\n    ```\n\n    A piece of trivia: what is common among the words in the list `words`? \n\n\n\n\nLike lists dictionaries are mutable objects. To see the mutability of #!py dict objects in action, consider the following code:\ndict_1 = {'one': 1, 'two': 2, 'three': 3}\ndict_2 = dict_1\ndict_2['four'] = 4\nprint(dict_1, dict_2)\nprint(dict_1 is dict_2)\nWe see that dict_2 is alias of dict_1 and both point to the same object. If we want a new #!py dict object with the same contents as dict_1, we could either use the #!py copy() method or the #!py dict built-in function:\ndict_1 = {'one': 1, 'two': 2, 'three': 3}\ndict_2 = dict_1.copy()      # dict(dict_1) also works\ndict_2['four'] = 4\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nThe last line prints True which confirms that we have two different objects. So modifying one doesn’t affect the other. But note that #!py copy() only produces a shallow copy. As long as the values are immutable, this doesn’t matter. But if we have mutable values, then we have a problem:\ndict_1 = {'one': [1], 'two': [1, 1], 'three': [1, 1, 1]}\ndict_2 = dict_1.copy()\ndict_2['one'].append(100)\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nprint(dict_1['one'] is dict_2['one'])\nHere, we see that the value corresponding to the key #!py 'one' in both dictionaries gets affected. This is because #!py dict_1['one'] and #!py dict_2['one'] are still the same object. This can be seen from the last statement of the code given above. To set this right, we need to do a deepcopy:\nfrom copy import deepcopy\ndict_1 = {'one': [1], 'two': [1, 1], 'three': [1, 1, 1]}\ndict_2 = deepcopy(dict_1)\ndict_2['one'].append(100)\nprint(dict_1, dict_2)\nprint(dict_1 is not dict_2)\nprint(dict_1['one'] is not dict_2['one'])"
  },
  {
    "objectID": "notes/chapter-6/lesson-6.3.html",
    "href": "notes/chapter-6/lesson-6.3.html",
    "title": "Lesson-6.3",
    "section": "",
    "text": "Assume that we wish to compute the following mapping between letters of the English alphabet and numbers from 1 to 26:\n\nLetter | Number |\n|: —- :|: —- :| | a | 1 | | b | 2 | | … | … | | z | 26 |\n\nEach letter in the alphabet is mapped to a unique number from 1 to 26. In the table given above, the mapping is a simple linear mapping: #!py 'a' is mapped to #!py 1, #!py 'b' to #!py 2 and so on. This mapping can be computed in the most uninteresting and lousy way given below:\nmapping = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5,\n           'f': 6 , 'g': 7, 'h': 8, 'i': 9, 'j': 10, \n           'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,\n           'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20,\n           'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25,\n           'z': 26\n          }\n\nfor letter, count in mapping.items():\n    print(letter, count)\nPhew! If you type the whole thing out, it will take you two full dull minutes. Your finger will curse you for the mechanical key-presses while your eyes will chide you for staring at the screen without blinking. You could cheese your way past the challenge by hitting the clipboard button and pasting it but will you really open up this textbook everytime you need to make this mapping?\nLet us try a roundabout but interesting way. Consider the following line:\n\nthe quick brown fox jumps over the lazy dog\n\nThis sentence is called a pangram. A pangram is a sentence that uses all the letters of the alphabet. Does that ring any bell?\npangram = 'the quick brown fox jumps over the lazy dog'\nwords = pangram.split(' ')          # get list of words in the sentence\nletters = ''.join(words)            # join the words back; eliminates spaces\nsorted_letters = sorted(letters)    # sort letters\nmapping, count = dict(), 0\nfor letter in sorted_letters:\n    # check if letter is not present in dict\n    # to avoid counting same letter multiple times\n    if letter not in mapping:\n        count += 1\n        mapping[letter] = count     # map the letter to count\n\nfor letter, count in mapping.items():\n    print(letter, count)\nPlenty of things to learn from those 14 lines of code. Not all diversions are bad. Now that we have an interesting dictionary in place, let us jump into some methods that are bundled along with dict.\n\n\n\nWe have already seen keys and items. Both these are methods that return a view object over which we can iterate. According to the Python documentation, &gt; [View objects] provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes.\npython linenums=\"15\" keys = mapping.keys() print(keys)\nThis gives the following output:\ndict_keys(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'])\nUsing the #!py list() function, both the keys and items views can be converted into lists:\npython linenums=\"17\" keys_list = list(mapping.keys()) print(keys) items_list = list(mapping.items()) print(items)\nThe output is as follows:\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8), ('i', 9), ('j', 10), ('k', 11), ('l', 12), ('m', 13), ('n', 14), ('o', 15), ('p', 16), ('q', 17), ('r', 18), ('s', 19), ('t', 20), ('u', 21), ('v', 22), ('w', 23), ('x', 24), ('y', 25), ('z', 26)]\nkeys_list is a list of keys in the dictionary mapping. items_list is a list of tuples, where each tuple is a key-value pair. Another useful method is values. This returns a view on the values:\npython linenums=\"21\" view = mapping.values() view_list = list(view)\nAll three views - keys, items, values - support membership tests:\npython linenums=\"23\" print('a' in mapping.keys()) print(1 in mapping.values()) print(('a', 1) in mapping.items())\nAll three return True. Membership tests for keys can be done in a simpler way:\npython linenums=\"26\" print('a' in mapping) print('x' in mapping) print('ab' not in mapping)\nNote that we dropped the keys method and it still worked! Now, to delete a key from a dictionary, we use the familiar pop method:\npython linenums=\"29\" mapping['ab'] = 3           # some noise added to mapping value = mapping.pop('ab') print(value) print('ab' not in mapping)\nIf key is a key in a dictionary D, D.pop(key) removes the key key in D and returns the value associated with it. Removing a key naturally removes the value associated with it. Dictionaries are aristocratic data structures: keys are higher up in the hierarchy and values depend on the keys for their existence."
  },
  {
    "objectID": "notes/chapter-6/lesson-6.3.html#dictionaries",
    "href": "notes/chapter-6/lesson-6.3.html#dictionaries",
    "title": "Lesson-6.3",
    "section": "",
    "text": "Assume that we wish to compute the following mapping between letters of the English alphabet and numbers from 1 to 26:\n\nLetter | Number |\n|: —- :|: —- :| | a | 1 | | b | 2 | | … | … | | z | 26 |\n\nEach letter in the alphabet is mapped to a unique number from 1 to 26. In the table given above, the mapping is a simple linear mapping: #!py 'a' is mapped to #!py 1, #!py 'b' to #!py 2 and so on. This mapping can be computed in the most uninteresting and lousy way given below:\nmapping = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5,\n           'f': 6 , 'g': 7, 'h': 8, 'i': 9, 'j': 10, \n           'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,\n           'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20,\n           'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25,\n           'z': 26\n          }\n\nfor letter, count in mapping.items():\n    print(letter, count)\nPhew! If you type the whole thing out, it will take you two full dull minutes. Your finger will curse you for the mechanical key-presses while your eyes will chide you for staring at the screen without blinking. You could cheese your way past the challenge by hitting the clipboard button and pasting it but will you really open up this textbook everytime you need to make this mapping?\nLet us try a roundabout but interesting way. Consider the following line:\n\nthe quick brown fox jumps over the lazy dog\n\nThis sentence is called a pangram. A pangram is a sentence that uses all the letters of the alphabet. Does that ring any bell?\npangram = 'the quick brown fox jumps over the lazy dog'\nwords = pangram.split(' ')          # get list of words in the sentence\nletters = ''.join(words)            # join the words back; eliminates spaces\nsorted_letters = sorted(letters)    # sort letters\nmapping, count = dict(), 0\nfor letter in sorted_letters:\n    # check if letter is not present in dict\n    # to avoid counting same letter multiple times\n    if letter not in mapping:\n        count += 1\n        mapping[letter] = count     # map the letter to count\n\nfor letter, count in mapping.items():\n    print(letter, count)\nPlenty of things to learn from those 14 lines of code. Not all diversions are bad. Now that we have an interesting dictionary in place, let us jump into some methods that are bundled along with dict.\n\n\n\nWe have already seen keys and items. Both these are methods that return a view object over which we can iterate. According to the Python documentation, &gt; [View objects] provide a dynamic view on the dictionary’s entries, which means that when the dictionary changes, the view reflects these changes.\npython linenums=\"15\" keys = mapping.keys() print(keys)\nThis gives the following output:\ndict_keys(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'])\nUsing the #!py list() function, both the keys and items views can be converted into lists:\npython linenums=\"17\" keys_list = list(mapping.keys()) print(keys) items_list = list(mapping.items()) print(items)\nThe output is as follows:\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8), ('i', 9), ('j', 10), ('k', 11), ('l', 12), ('m', 13), ('n', 14), ('o', 15), ('p', 16), ('q', 17), ('r', 18), ('s', 19), ('t', 20), ('u', 21), ('v', 22), ('w', 23), ('x', 24), ('y', 25), ('z', 26)]\nkeys_list is a list of keys in the dictionary mapping. items_list is a list of tuples, where each tuple is a key-value pair. Another useful method is values. This returns a view on the values:\npython linenums=\"21\" view = mapping.values() view_list = list(view)\nAll three views - keys, items, values - support membership tests:\npython linenums=\"23\" print('a' in mapping.keys()) print(1 in mapping.values()) print(('a', 1) in mapping.items())\nAll three return True. Membership tests for keys can be done in a simpler way:\npython linenums=\"26\" print('a' in mapping) print('x' in mapping) print('ab' not in mapping)\nNote that we dropped the keys method and it still worked! Now, to delete a key from a dictionary, we use the familiar pop method:\npython linenums=\"29\" mapping['ab'] = 3           # some noise added to mapping value = mapping.pop('ab') print(value) print('ab' not in mapping)\nIf key is a key in a dictionary D, D.pop(key) removes the key key in D and returns the value associated with it. Removing a key naturally removes the value associated with it. Dictionaries are aristocratic data structures: keys are higher up in the hierarchy and values depend on the keys for their existence."
  },
  {
    "objectID": "notes/chapter-6/lesson-6.2.html",
    "href": "notes/chapter-6/lesson-6.2.html",
    "title": "Lesson-6.2",
    "section": "",
    "text": "The following paragraph is an excerpt from a talk given by Guido. The full text can be found here.\n\nIn reality, programming languages are how programmers express and communicate ideas — and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program — people who will never read or even know about the program, but who nevertheless are affected by it.\n\nText processing plays an important role in analyzing text data. Given a piece of text, the following are some of the basic questions that we can ask:\n\nHow many sentences are there in the text?\nHow many words are there in the text?\nHow many of them are unique?\nWhich word appears the most number of times?\n\nAre these meaningful questions to ask? Do they lead us anywhere? Yes, they do! Consider the task of classifying articles. Some sample categories could be: lifestyle, science and technology, literature, films. If we want to understand what category an article falls under, one way to go about it is to read the entire article. We can do it for one or two articles, but what if we have to do this for hundreds of them? A better solution would be to computationally process each article, find the top five most common words and use that to get an idea of what the text is about.\nWe could program a solution to do exactly this. In the next few sections, we will gradually write, one step at a time, the code that answers all of the above questions. Follow along with an IDE or text editor of your choice and run the code at each step. Let’s start off by storing the string in a variable text.\ntext = \"In reality, programming languages are how programmers express and communicate ideas — and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program — people who will never read or even know about the program, but who nevertheless are affected by it.\"\n\n\nSentences could end with one of the following tokens: full stop, exclamation mark or question mark. For simplicity, let us assume that all sentences in our text ends with a full stop. We can split the string using full stop as a delimiter to get a list of sentences:\npython linenums=\"2\" sentences = text.split('.') Let’s now look into the list using some temporary code. It’s very important as a programmer to know what your code is doing and printing out the contents of your variables will give a good look of what’s happening.\n# Prints one sentence in each line\nfor sentence in sentences:\n    print(sentence)\nprint(f'There are {len(sentences)} sentences in this text.')\n\n\nIn reality, programming languages are how programmers express and communicate ideas — and the audience for those ideas is other programmers, not computers\nThe reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops\nIn fact, ideas expressed in a programming language also often reach the end users of the program — people who will never read or even know about the program, but who nevertheless are affected by it\n\nThere are 4 sentences in this text.\nNotice that there are only three sentences, but we get the output to be four in the last line. On closer inspection, we see that #!py sentences[-1] is not a sentence but an empty string. This is because, when a string is split using a delimiter which is present in the string, two substrings get generated, one to the left of the delimiter and the other to its right. As the full stop is the last character in the text, the substring to its right is an empty string. One way to correct this is to remove all empty strings in sentences:\npython linenums=\"3\" while '' in sentences:     sentences.remove('') print(f'There are {len(sentences)} sentences in this text.')\n\n\n\nThere are 3 sentences in this text.\nOne problem solved!\n\n\n\n\nTo get the number of words, we can split each sentence by space:\npython linenums=\"6\" words = [ ] for sentence in sentences:     words_ = sentence.split(' ')    # words_ contains words in sentence     words.extend(words_)            # words is the collection of all words\nIf we print out #!py len(words), we get the number of words to be 86. Is that correct? wordcounter.net claims that there are 82 words in this text. Clearly, something is wrong with our code. Let us print each word along with its index in separate lines and see what we have:\nfor index, word in enumerate(words):\n    print(index, word)\nSifting through the output, we notice the following offenders:\n11 —\n23 \n49\n67 —\nIndices 11 and 67 are em dashes (—) while 23 and 49 correspond to empty strings. Since we have two different characters to remove, let us clean up the list in the following way:\npython linenums=\"10\" proc_words = [ ] for word in words:     if not(word == '' or word == '—'):         proc_words.append(word) print(f'There are {len(proc_words)} words in this text')\nAnd we have 82 words as expected. One more problem solved!\n\n\n\nYou might be wondering why this lesson has come under Chapter 6 if there are no dictionaries floating around. This section will assuage that worry, because we will now use a dictionary to keep track of the number of unique words along with their frequency.\npython linenums=\"15\" uniq_words = dict() for word in proc_words:     if word not in uniq_words:         uniq_words[word] = 0     uniq_words[word] += 1 print(f'There are {len(uniq_words)} unique words in this text')\nApparently, there are 62 unique words in our text. Upon manual inspection, the word “programmers” occurs four times in the text. What does our dict have to say?\nprint(uniq_words['programmers'])\nWe get 2 as the output, another wrong answer! Programming doesn’t seem like magic after all. We are making mistakes far too often. Note that this is not the exception, but the norm. The nice part of making mistakes is that they are almost always an opportunity to learn something. An error in the code is hidden knowledge, an insight into a flaw in our logic that we are yet to unmask. Now, back to the drawing board. Let us search for all entries in the list proc_words that have the substring “programmers” in them:\nfor word in proc_words:\n    if 'programmers' in word:\n        print(word)\n\n\nprogrammers\nprogrammers,\nprogrammers\nprogrammers,\nSo, the problem is with the special character: comma.\nAnother problem is introduced by the capitalization of words, usually at the beginning of sentences. Now that the problems have been identified, let us go ahead and fix them. Of course, this means we have to go back and modify the code we have already written. This is a perfectly normal process in programming - You start writing your solution, you gain a new insight in the process, you go back and change what you had just written (or sometimes even throw away the whole thing and start from scratch!). Let’s now generate proc_words the right way:\npython linenums=\"10\" proc_words = [ ] for word_ in words:     word = word_.lower()     if not(word == '' or word == '—'):         if not word_.isalnum():             word = word_[:-1]         proc_words.append(word) print(f'There are {len(proc_words)} words in this text')\nSeveral things are happening here. In line 12, every word is converted to lower case. In line , em dashes and empty strings are being ignored. Line 14 checks if a word contains a special character. If it does, then it is unburdened of that dangling character in line 15. Here we assume that special characters usually appear at the end of the word. In this text, there are two cases: “programmers,” and “reason:”. All processed words are finally added to proc_words in line 16. Now that we have a cleaned up proc_words, we can go back and generate uniq_words:\n\npython linenums=\"18\" uniq_words = dict() for word in proc_words:     if word not in uniq_words:         uniq_words[word] = 0     uniq_words[word] += 1 print(f'There are {len(uniq_words)} unique words in this text')\nLovely! There are 58 unique words in the text. We can check if this is right by printing all the words and their counts:\nfor word, freq in uniq_words.items():\n    print(word, freq)\nWe can see that there is no erroneous repetition of any word. As a test, we can also see if the sum of the counts gives back the total number of words:\ntotal = 0\nfor word in uniq_words:\n    total += uniq_words[word]\nassert total == len(proc_words)\nAs the code doesn’t raise any #!py AssertionError, we are correct!\n\n\n\n\nNow onto the last problem - let us find the top three most frequently occurring words:\npython linenums=\"24\" first_word = second_word = third_word = '' first_val = second_val = third_val = 0 for word, freq in uniq_words.items():     if freq &gt; first_val:         first_val, second_val, third_val = freq, first_val, second_val         first_word, second_word, third_word = word, first_word, second_word     elif freq &gt; second_val and freq &lt; first_val:         second_val, third_val = freq, second_val         second_word, third_word = word, second_word     elif freq &gt; third_val and freq &lt; second_val:         third_val = freq         third_word = word print(first_word, first_val) print(second_word, second_val) print(third_word, third_val)\n\n\nthe 6\nprogrammers 4\nin 3\nWe see that “programmers” is the second most frequent word. First and third most frequent words are “the” and “in” respectively. Such common words are called stop-words. If they are removed from the text, “programmers” becomes the most frequent non-trivial word. So, without reading this text, one can guess that it should be something about programmers, thanks to Python!\n\n\n\n\nThe main takeaway from this lesson is the kind of mistakes we made and the way we fixed each one of them. In almost every problem, we started off with a solution, then tested it. We figured out that something was wrong, so we went back and tried to fix the problem."
  },
  {
    "objectID": "notes/chapter-6/lesson-6.2.html#text-processing",
    "href": "notes/chapter-6/lesson-6.2.html#text-processing",
    "title": "Lesson-6.2",
    "section": "",
    "text": "The following paragraph is an excerpt from a talk given by Guido. The full text can be found here.\n\nIn reality, programming languages are how programmers express and communicate ideas — and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program — people who will never read or even know about the program, but who nevertheless are affected by it.\n\nText processing plays an important role in analyzing text data. Given a piece of text, the following are some of the basic questions that we can ask:\n\nHow many sentences are there in the text?\nHow many words are there in the text?\nHow many of them are unique?\nWhich word appears the most number of times?\n\nAre these meaningful questions to ask? Do they lead us anywhere? Yes, they do! Consider the task of classifying articles. Some sample categories could be: lifestyle, science and technology, literature, films. If we want to understand what category an article falls under, one way to go about it is to read the entire article. We can do it for one or two articles, but what if we have to do this for hundreds of them? A better solution would be to computationally process each article, find the top five most common words and use that to get an idea of what the text is about.\nWe could program a solution to do exactly this. In the next few sections, we will gradually write, one step at a time, the code that answers all of the above questions. Follow along with an IDE or text editor of your choice and run the code at each step. Let’s start off by storing the string in a variable text.\ntext = \"In reality, programming languages are how programmers express and communicate ideas — and the audience for those ideas is other programmers, not computers. The reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops. In fact, ideas expressed in a programming language also often reach the end users of the program — people who will never read or even know about the program, but who nevertheless are affected by it.\"\n\n\nSentences could end with one of the following tokens: full stop, exclamation mark or question mark. For simplicity, let us assume that all sentences in our text ends with a full stop. We can split the string using full stop as a delimiter to get a list of sentences:\npython linenums=\"2\" sentences = text.split('.') Let’s now look into the list using some temporary code. It’s very important as a programmer to know what your code is doing and printing out the contents of your variables will give a good look of what’s happening.\n# Prints one sentence in each line\nfor sentence in sentences:\n    print(sentence)\nprint(f'There are {len(sentences)} sentences in this text.')\n\n\nIn reality, programming languages are how programmers express and communicate ideas — and the audience for those ideas is other programmers, not computers\nThe reason: the computer can take care of itself, but programmers are always working with other programmers, and poorly communicated ideas can cause expensive flops\nIn fact, ideas expressed in a programming language also often reach the end users of the program — people who will never read or even know about the program, but who nevertheless are affected by it\n\nThere are 4 sentences in this text.\nNotice that there are only three sentences, but we get the output to be four in the last line. On closer inspection, we see that #!py sentences[-1] is not a sentence but an empty string. This is because, when a string is split using a delimiter which is present in the string, two substrings get generated, one to the left of the delimiter and the other to its right. As the full stop is the last character in the text, the substring to its right is an empty string. One way to correct this is to remove all empty strings in sentences:\npython linenums=\"3\" while '' in sentences:     sentences.remove('') print(f'There are {len(sentences)} sentences in this text.')\n\n\n\nThere are 3 sentences in this text.\nOne problem solved!\n\n\n\n\nTo get the number of words, we can split each sentence by space:\npython linenums=\"6\" words = [ ] for sentence in sentences:     words_ = sentence.split(' ')    # words_ contains words in sentence     words.extend(words_)            # words is the collection of all words\nIf we print out #!py len(words), we get the number of words to be 86. Is that correct? wordcounter.net claims that there are 82 words in this text. Clearly, something is wrong with our code. Let us print each word along with its index in separate lines and see what we have:\nfor index, word in enumerate(words):\n    print(index, word)\nSifting through the output, we notice the following offenders:\n11 —\n23 \n49\n67 —\nIndices 11 and 67 are em dashes (—) while 23 and 49 correspond to empty strings. Since we have two different characters to remove, let us clean up the list in the following way:\npython linenums=\"10\" proc_words = [ ] for word in words:     if not(word == '' or word == '—'):         proc_words.append(word) print(f'There are {len(proc_words)} words in this text')\nAnd we have 82 words as expected. One more problem solved!\n\n\n\nYou might be wondering why this lesson has come under Chapter 6 if there are no dictionaries floating around. This section will assuage that worry, because we will now use a dictionary to keep track of the number of unique words along with their frequency.\npython linenums=\"15\" uniq_words = dict() for word in proc_words:     if word not in uniq_words:         uniq_words[word] = 0     uniq_words[word] += 1 print(f'There are {len(uniq_words)} unique words in this text')\nApparently, there are 62 unique words in our text. Upon manual inspection, the word “programmers” occurs four times in the text. What does our dict have to say?\nprint(uniq_words['programmers'])\nWe get 2 as the output, another wrong answer! Programming doesn’t seem like magic after all. We are making mistakes far too often. Note that this is not the exception, but the norm. The nice part of making mistakes is that they are almost always an opportunity to learn something. An error in the code is hidden knowledge, an insight into a flaw in our logic that we are yet to unmask. Now, back to the drawing board. Let us search for all entries in the list proc_words that have the substring “programmers” in them:\nfor word in proc_words:\n    if 'programmers' in word:\n        print(word)\n\n\nprogrammers\nprogrammers,\nprogrammers\nprogrammers,\nSo, the problem is with the special character: comma.\nAnother problem is introduced by the capitalization of words, usually at the beginning of sentences. Now that the problems have been identified, let us go ahead and fix them. Of course, this means we have to go back and modify the code we have already written. This is a perfectly normal process in programming - You start writing your solution, you gain a new insight in the process, you go back and change what you had just written (or sometimes even throw away the whole thing and start from scratch!). Let’s now generate proc_words the right way:\npython linenums=\"10\" proc_words = [ ] for word_ in words:     word = word_.lower()     if not(word == '' or word == '—'):         if not word_.isalnum():             word = word_[:-1]         proc_words.append(word) print(f'There are {len(proc_words)} words in this text')\nSeveral things are happening here. In line 12, every word is converted to lower case. In line , em dashes and empty strings are being ignored. Line 14 checks if a word contains a special character. If it does, then it is unburdened of that dangling character in line 15. Here we assume that special characters usually appear at the end of the word. In this text, there are two cases: “programmers,” and “reason:”. All processed words are finally added to proc_words in line 16. Now that we have a cleaned up proc_words, we can go back and generate uniq_words:\n\npython linenums=\"18\" uniq_words = dict() for word in proc_words:     if word not in uniq_words:         uniq_words[word] = 0     uniq_words[word] += 1 print(f'There are {len(uniq_words)} unique words in this text')\nLovely! There are 58 unique words in the text. We can check if this is right by printing all the words and their counts:\nfor word, freq in uniq_words.items():\n    print(word, freq)\nWe can see that there is no erroneous repetition of any word. As a test, we can also see if the sum of the counts gives back the total number of words:\ntotal = 0\nfor word in uniq_words:\n    total += uniq_words[word]\nassert total == len(proc_words)\nAs the code doesn’t raise any #!py AssertionError, we are correct!\n\n\n\n\nNow onto the last problem - let us find the top three most frequently occurring words:\npython linenums=\"24\" first_word = second_word = third_word = '' first_val = second_val = third_val = 0 for word, freq in uniq_words.items():     if freq &gt; first_val:         first_val, second_val, third_val = freq, first_val, second_val         first_word, second_word, third_word = word, first_word, second_word     elif freq &gt; second_val and freq &lt; first_val:         second_val, third_val = freq, second_val         second_word, third_word = word, second_word     elif freq &gt; third_val and freq &lt; second_val:         third_val = freq         third_word = word print(first_word, first_val) print(second_word, second_val) print(third_word, third_val)\n\n\nthe 6\nprogrammers 4\nin 3\nWe see that “programmers” is the second most frequent word. First and third most frequent words are “the” and “in” respectively. Such common words are called stop-words. If they are removed from the text, “programmers” becomes the most frequent non-trivial word. So, without reading this text, one can guess that it should be something about programmers, thanks to Python!\n\n\n\n\nThe main takeaway from this lesson is the kind of mistakes we made and the way we fixed each one of them. In almost every problem, we started off with a solution, then tested it. We figured out that something was wrong, so we went back and tried to fix the problem."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.6.html",
    "href": "notes/chapter-3/lesson-3.6.html",
    "title": "Lesson 3.6",
    "section": "",
    "text": "Before closing this chapter, let us spend some time at the intersection of mathematics and programming.\n\n\nConsider the following number:\n\\[\n\\sqrt{2} - 1\n\\]\nIt is known that \\(1 &lt; \\sqrt{2} &lt; 2\\). From this, it follows that \\(0 &lt; \\sqrt{2} - 1 &lt; 1\\). Now, consider the following sequence:\n\\[\na_n = \\left( \\sqrt{2} - 1 \\right)^n\n\\]\nAs \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically:\n\nimport math\nn = int(input())                # sequence length\nCONST = math.pow(2, 0.5) - 1    # basic term in the sequence\na_n = 1                         # zeroth term\nfor i in range(n):\n    a_n = a_n * CONST           # computing the nth term\nprint(a_n)\nTry this out for a few values of \\(n\\). For \\(n = 100\\), the value is \\(5.27 \\times 10^{-39}\\), which is so small that for all practical purposes, it is as good as zero.\n\n\n\nNow, here is another fact. For every number \\(n\\), there are unique integers \\(x\\) and \\(y\\) such that: \\[\n(\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2}\n\\] For \\(n = 1\\), this is obvious: \\(x = -1, y = 1\\). What about higher values of \\(n\\)? . We can prove this using mathematical induction. The following is a sketch of the inductive proof. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\), then: \\[\n(\\sqrt{2} - 1)^{n + 1} = (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\\\\n= (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\\\\n= x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2}\n\\] The equation given above defines what is called a recurrence relation: each new term in the sequence is a function of the preceding terms. In this sequence we have \\(x_1 = -1, y_1 = 1\\). For \\(n &gt; 0\\), the pair of equations given below forms the recurrence relation: \\[\n\\begin{align}\nx_{n + 1} &= 2 y_n - x_n\\\\\ny_{n + 1} &= x_n - y_n\n\\end{align}\n\\] Loops are useful tools when it comes to computing terms in such sequences:\nn = int(input())    # sequence length\nx_n, y_n = -1, 1    # x_1 and y_1\nfor i in range(n - 1):\n    x_n, y_n = 2 * y_n - x_n, x_n - y_n\n\n\n\nThis in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: \\[\n\\sqrt{2} \\approx \\frac{-x_n}{y_n}\n\\] As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! \\[\n\\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709}\n\\] Is any of this useful? I don’t know. But honestly, who cares? We don’t do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.6.html#math-and-programming",
    "href": "notes/chapter-3/lesson-3.6.html#math-and-programming",
    "title": "Lesson 3.6",
    "section": "",
    "text": "Before closing this chapter, let us spend some time at the intersection of mathematics and programming.\n\n\nConsider the following number:\n\\[\n\\sqrt{2} - 1\n\\]\nIt is known that \\(1 &lt; \\sqrt{2} &lt; 2\\). From this, it follows that \\(0 &lt; \\sqrt{2} - 1 &lt; 1\\). Now, consider the following sequence:\n\\[\na_n = \\left( \\sqrt{2} - 1 \\right)^n\n\\]\nAs \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically:\n\nimport math\nn = int(input())                # sequence length\nCONST = math.pow(2, 0.5) - 1    # basic term in the sequence\na_n = 1                         # zeroth term\nfor i in range(n):\n    a_n = a_n * CONST           # computing the nth term\nprint(a_n)\nTry this out for a few values of \\(n\\). For \\(n = 100\\), the value is \\(5.27 \\times 10^{-39}\\), which is so small that for all practical purposes, it is as good as zero.\n\n\n\nNow, here is another fact. For every number \\(n\\), there are unique integers \\(x\\) and \\(y\\) such that: \\[\n(\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2}\n\\] For \\(n = 1\\), this is obvious: \\(x = -1, y = 1\\). What about higher values of \\(n\\)? . We can prove this using mathematical induction. The following is a sketch of the inductive proof. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\), then: \\[\n(\\sqrt{2} - 1)^{n + 1} = (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\\\\n= (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\\\\n= x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2}\n\\] The equation given above defines what is called a recurrence relation: each new term in the sequence is a function of the preceding terms. In this sequence we have \\(x_1 = -1, y_1 = 1\\). For \\(n &gt; 0\\), the pair of equations given below forms the recurrence relation: \\[\n\\begin{align}\nx_{n + 1} &= 2 y_n - x_n\\\\\ny_{n + 1} &= x_n - y_n\n\\end{align}\n\\] Loops are useful tools when it comes to computing terms in such sequences:\nn = int(input())    # sequence length\nx_n, y_n = -1, 1    # x_1 and y_1\nfor i in range(n - 1):\n    x_n, y_n = 2 * y_n - x_n, x_n - y_n\n\n\n\nThis in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: \\[\n\\sqrt{2} \\approx \\frac{-x_n}{y_n}\n\\] As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! \\[\n\\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709}\n\\] Is any of this useful? I don’t know. But honestly, who cares? We don’t do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.2.html",
    "href": "notes/chapter-3/lesson-3.2.html",
    "title": "Lesson-3.2",
    "section": "",
    "text": "Let us look at a simple problem of printing numbers. We would like to print the first 5 non-negative integers. We could do this using a while loop but let’s try a different kind of a loop now, the #!py for loop:\nfor i in range(5):\n    print(i)\n# A dummy line\nThe output is:\n0\n1\n2\n3\n4\n#!py for and #!py in are keywords in Python. #!py range is an object that represents a sequence of numbers. Line-2 is the body of the loop. An intuitive understanding of the code given above is as follows:\n\nIn each iteration of the loop, an element in the sequence is picked up and is printed to the console.\nAssuming that the sequence is ordered from left to right, the leftmost element is the first to be picked up.\nThe sequence is processed from left to right.\nOnce the rightmost element has been printed to the console, control returns to line 1 for one last time. Since there are no more elements to be read in the sequence, the control exits the loop and moves to line 3.\n\nA visual representation is given below:\n\n\n\ncontrol flow of for loop\n\n\nSimilar to #!py while loops and #!py if-#!py else blocks, the body of a #!py for loop should be indented.\n\n\n\nNow let’s dive a bit deeper into this #!py range() function that we have been using. This function predictably returns a sequence, or a range if you will, of numbers. #!py range(5) results in the following sequence: \\(0, 1, 2, 3, 4\\). In general, #!py range(n) creates the sequence: \\(0, 1, ..., n - 1\\). #!py range is quite versatile. The following code prints all two digit numbers greater than zero:\nfor i in range(10, 100):\n    print(i)\n#!py range(10, 100) represents the sequence \\(10, 11, ..., 99\\). In general, #!py range(start, stop) represents the sequence start, start + 1, ..., stop - 1. Let us add another level of complexity. The following code prints all even two digit natural numbers:\nfor i in range(10, 100, 2):\n    print(i)\nrange(10, 100, 2) represents the sequence 10, 12, ..., 98. In general, range(start, stop, step) represents the sequence start, start + step, start + 2 * step, ..., last, where last is the largest element in this sequence that is less than stop. This is true when the step parameter is positive.\nThe following are equivalent:\n\n#!py range(n)\n#!py range(0, n)\n#!py range(0, n, 1)\n\nSo far we have seen only increasing sequences. With the help of a negative step size, we can also come up with decreasing sequences. The following code prints all two-digit even numbers greater than zero in descending order:\nfor i in range(98, 9, -2):\n    print(i)\nFor a negative step value, #!py range(start, stop, step) represents the sequence start, start + step, start + 2 * step, ..., last, where last is the smallest element in the sequence greater than stop.\nNow, consider the following code:\nfor i in range(5, 5):\n    print(i)\n#!py range(5, 5) is an empty sequence. So, the above code will not print anything. Another instance of an empty sequence:\nfor i in range(10, 5):\n    print(i)\nThe point to note is that neither of these code snippets produces any error. Finally, try executing the following snippet and observe the output.\n##### Alarm! Wrong code snippet! #####\nfor i in range(0.0, 10.0):\n    print(i)\n##### Alarm! Wrong code snippet! #####\n\n\n\nSince a string is a sequence of characters, we can use the #!py for loop to iterate through strings. The following code will print each character of the string x in one line:\nword = 'good'\nfor char in word:\n    print(char)\nThe output is:\ng\no\no\nd\nWe can add some more code to enrich the output:\nword = 'good'\ncount = 1\nfor char in word:\n    print(char, 'occurs at position', count, 'in the string', word)\n    count = count + 1\nThe output is:\ng occurs at position 1 in the string good\no occurs at position 2 in the string good\no occurs at position 3 in the string good\nd occurs at position 4 in the string good"
  },
  {
    "objectID": "notes/chapter-3/lesson-3.2.html#loops",
    "href": "notes/chapter-3/lesson-3.2.html#loops",
    "title": "Lesson-3.2",
    "section": "",
    "text": "Let us look at a simple problem of printing numbers. We would like to print the first 5 non-negative integers. We could do this using a while loop but let’s try a different kind of a loop now, the #!py for loop:\nfor i in range(5):\n    print(i)\n# A dummy line\nThe output is:\n0\n1\n2\n3\n4\n#!py for and #!py in are keywords in Python. #!py range is an object that represents a sequence of numbers. Line-2 is the body of the loop. An intuitive understanding of the code given above is as follows:\n\nIn each iteration of the loop, an element in the sequence is picked up and is printed to the console.\nAssuming that the sequence is ordered from left to right, the leftmost element is the first to be picked up.\nThe sequence is processed from left to right.\nOnce the rightmost element has been printed to the console, control returns to line 1 for one last time. Since there are no more elements to be read in the sequence, the control exits the loop and moves to line 3.\n\nA visual representation is given below:\n\n\n\ncontrol flow of for loop\n\n\nSimilar to #!py while loops and #!py if-#!py else blocks, the body of a #!py for loop should be indented.\n\n\n\nNow let’s dive a bit deeper into this #!py range() function that we have been using. This function predictably returns a sequence, or a range if you will, of numbers. #!py range(5) results in the following sequence: \\(0, 1, 2, 3, 4\\). In general, #!py range(n) creates the sequence: \\(0, 1, ..., n - 1\\). #!py range is quite versatile. The following code prints all two digit numbers greater than zero:\nfor i in range(10, 100):\n    print(i)\n#!py range(10, 100) represents the sequence \\(10, 11, ..., 99\\). In general, #!py range(start, stop) represents the sequence start, start + 1, ..., stop - 1. Let us add another level of complexity. The following code prints all even two digit natural numbers:\nfor i in range(10, 100, 2):\n    print(i)\nrange(10, 100, 2) represents the sequence 10, 12, ..., 98. In general, range(start, stop, step) represents the sequence start, start + step, start + 2 * step, ..., last, where last is the largest element in this sequence that is less than stop. This is true when the step parameter is positive.\nThe following are equivalent:\n\n#!py range(n)\n#!py range(0, n)\n#!py range(0, n, 1)\n\nSo far we have seen only increasing sequences. With the help of a negative step size, we can also come up with decreasing sequences. The following code prints all two-digit even numbers greater than zero in descending order:\nfor i in range(98, 9, -2):\n    print(i)\nFor a negative step value, #!py range(start, stop, step) represents the sequence start, start + step, start + 2 * step, ..., last, where last is the smallest element in the sequence greater than stop.\nNow, consider the following code:\nfor i in range(5, 5):\n    print(i)\n#!py range(5, 5) is an empty sequence. So, the above code will not print anything. Another instance of an empty sequence:\nfor i in range(10, 5):\n    print(i)\nThe point to note is that neither of these code snippets produces any error. Finally, try executing the following snippet and observe the output.\n##### Alarm! Wrong code snippet! #####\nfor i in range(0.0, 10.0):\n    print(i)\n##### Alarm! Wrong code snippet! #####\n\n\n\nSince a string is a sequence of characters, we can use the #!py for loop to iterate through strings. The following code will print each character of the string x in one line:\nword = 'good'\nfor char in word:\n    print(char)\nThe output is:\ng\no\no\nd\nWe can add some more code to enrich the output:\nword = 'good'\ncount = 1\nfor char in word:\n    print(char, 'occurs at position', count, 'in the string', word)\n    count = count + 1\nThe output is:\ng occurs at position 1 in the string good\no occurs at position 2 in the string good\no occurs at position 3 in the string good\nd occurs at position 4 in the string good"
  },
  {
    "objectID": "notes/chapter-3/lesson-3.3.html",
    "href": "notes/chapter-3/lesson-3.3.html",
    "title": "Lesson-3.3",
    "section": "",
    "text": "Consider the following problem:\n!!! question ” ” Find the number of ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs.\nSolution\ncount = 0\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            count = count + 1\nprint(count)\nThe code given above is an example of a nested loop. Lines 2-5 form the outer loop while lines 3-5 form the inner-loop. There are multiple levels of indentation here. Line-3 is the beginning of a new #!py for loop, so line 4 is indented with respect to line 3. As line 4 is an if statement, line 5 is indented with respect to line 4.\nThis problem could have been solved without using a nested loop. The nested loop is not an efficient solution. It is left as an exercise to the reader to come up with a more efficient solution to this problem. Let us look at one more problem:\n!!! question ” ” Find the number of prime numbers less than \\(n\\), where \\(n\\) is some positive integer.\nSolution\nn = int(input())\ncount = 0\nfor i in range(2, n + 1):\n    flag = True\n    for j in range(2, i):\n        if i % j == 0:\n            flag = False\n            break\n    if flag:\n        count = count + 1\nprint(count)\nThe basic idea behind the solution is as follows:\n\nThe outer for loop goes through each element in the sequence \\(2, 3, ..., n\\). i is the loop variable for this sequence.\nWe begin with the guess that i is prime. In code, we do this by setting flag to be True.\nNow, we go through all potential divisors of i. This is represented by the sequence \\(2, 3, ..., i - 1\\). Variable j is the loop variable for this sequence. Notice how the sequence for the inner loop is dependent on i, the loop variable for the outer loop.\nIf j divides i, then i cannot be a prime. We correct our initial assumption by updating flag to False whenever this happens. As we know that i is not prime, there is no use of continuing with the inner-loop, so we break out of it.\nIf j doesn’t divide i for any j in this sequence, then i is a prime. In such a situation, our initial assumption is right, and flag stays True.\nOnce we are outside the inner-loop, we check if flag is True. if that is the case, then we increment count as we have hit upon a prime number.\n\nSome important points regarding nested loops:\n\nNesting is not restricted to #!py for loops. Any one of the following combinations is possible:\n\n#!py for inside #!py for\n#!py for inside #!py while\n#!py while inside #!py while\n#!py while inside #!py for\n\nMultiple levels of nesting is possible.\n\n\n\n\n#!py for loops are typically used in situations where the number of iterations can be quantified, whereas #!py while loops are used in situations where the number of iterations cannot be quantified exactly. This doesn’t mean that the number of iterations in a #!py for loop is always constant. For example:\nn = int(input())\nfor i in range(n):\n    print(i ** 2)\nIn the code given above, the number of iterations will keep varying every time the code is run with a different input. But given the knowledge of the input, the number of iterations is fixed. On the other hand, consider the following example:\nx = int(input())\nwhile x &gt; 0:\n    x = int(input())\nThe number of iterations in the above code can be determined only after it terminates. There is no way of quantifying the number of iterations as an explicit function of user input.\n\n\n\n\n\nConsider the following problem:\n!!! question ” ” Accept a positive integer n as input and print all the numbers from 1 to n in a single line separated by commas.\nFor a given value of n, say n = 9, we want the output to be:\n1,2,3,4,5,6,7,8,9\nThe following solution won’t work:\nn = int(input())\nfor i in range(1, n + 1):\n    print(i, ',')\nFor n = 9, this will give the following output:\n1 ,\n2 ,\n3 ,\n4 ,\n5 ,\n6 ,\n7 ,\n8 ,\n9 ,\nThankfully, the print function provides a way to solve this problem:\nn = int(input())\nfor i in range(1, n):\n    print(i, end = ',')\nprint(n)\nFor n = 9, this will give the required output:\n1,2,3,4,5,6,7,8,9\nWhenever we use the #!py print() function, it prints the expression passed to it and immediately follows it up by printing a newline. This is the default behaviour of #!py print(). It can be altered by using a special argument called end. The default value of end is set to the newline character. So, whenever the end argument is not explicitly specified in the print function, a newline is appended to the input expression by default. In the code given above, by setting end to be a comma, we are forcing the #!py print() function to insert a comma instead of a newline at the end of the expression passed to it. It is called end because it is added at the end. To get a better picture, consider the following code:\nprint()\nprint(end = ',')\nprint(1)\nprint(1, end = ',')\nprint(2, end = ',')\nprint(3, end = ',')\nThis output is:\n\n,1\n1,2,3,\nEven though nothing is being passed to the print function in the first line of code, the first line in the output is a newline because the default value of end is a newline character ('\\n'). No expression is passed as input to print in the second line of code as well, but end is set to ,. So, only a comma is printed. Notice that line 3 of the code is printed in line 2 of the output. This is because end was set to , instead of the newline character in line 2 of the code.\n\n\n\nIf multiple expressions are passed to the #!py print() function, it prints all of them in the same line, by adding a space between adjacent expressions. For example:\nprint('this', 'is', 'cool')\nThe output is:\nthis is cool\nWhat if we do not want the space or if want some other separator? This can be done using sep:\nprint('this', 'is', 'cool', sep = ',')\nThe output is:\nthis,is,cool\nWe could also have an empty string as the separator:\nprint('this', 'is', 'cool', sep = '')\nThe output will then be:\nthisiscool\n\n\n\nLet us look at one final example that makes use of both end and sep:\n!!! question ” ” Accept a positive integer n, which is also a multiple of 3, as input and print the following pattern:\n```\n|1,2,3|4,5,6|7,8,9|...|n - 2,n - 1,n|\n```\n\nFor `n = 9`, we would like to print:\n\n```\n|1,2,3|4,5,6|7,8,9|\n```\nSolution\nn = int(input())\nprint('|', end = '')\nfor i in range(1, n + 1, 3):\n    print(i, i + 1, i + 2, sep = ',', end = '|')\nprint()\nNotice that the #!py for loop iterates in steps of 3 starting from 1. To print the comma separated triplet i,i + 1,i + 2, sep is set to ,. After printing each triplet, the symbol | needs to be printed. This is achieved by setting end to be equal to |. Line 2 makes sure that the symbol | is present at the beginning of the pattern. The last #!py print() statement outside the loop is there so that the prompt can move to the next line on the console once the pattern has been printed. You can try removing the last line and see how that changes the output on the console."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.3.html#nested-loops",
    "href": "notes/chapter-3/lesson-3.3.html#nested-loops",
    "title": "Lesson-3.3",
    "section": "",
    "text": "Consider the following problem:\n!!! question ” ” Find the number of ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs.\nSolution\ncount = 0\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            count = count + 1\nprint(count)\nThe code given above is an example of a nested loop. Lines 2-5 form the outer loop while lines 3-5 form the inner-loop. There are multiple levels of indentation here. Line-3 is the beginning of a new #!py for loop, so line 4 is indented with respect to line 3. As line 4 is an if statement, line 5 is indented with respect to line 4.\nThis problem could have been solved without using a nested loop. The nested loop is not an efficient solution. It is left as an exercise to the reader to come up with a more efficient solution to this problem. Let us look at one more problem:\n!!! question ” ” Find the number of prime numbers less than \\(n\\), where \\(n\\) is some positive integer.\nSolution\nn = int(input())\ncount = 0\nfor i in range(2, n + 1):\n    flag = True\n    for j in range(2, i):\n        if i % j == 0:\n            flag = False\n            break\n    if flag:\n        count = count + 1\nprint(count)\nThe basic idea behind the solution is as follows:\n\nThe outer for loop goes through each element in the sequence \\(2, 3, ..., n\\). i is the loop variable for this sequence.\nWe begin with the guess that i is prime. In code, we do this by setting flag to be True.\nNow, we go through all potential divisors of i. This is represented by the sequence \\(2, 3, ..., i - 1\\). Variable j is the loop variable for this sequence. Notice how the sequence for the inner loop is dependent on i, the loop variable for the outer loop.\nIf j divides i, then i cannot be a prime. We correct our initial assumption by updating flag to False whenever this happens. As we know that i is not prime, there is no use of continuing with the inner-loop, so we break out of it.\nIf j doesn’t divide i for any j in this sequence, then i is a prime. In such a situation, our initial assumption is right, and flag stays True.\nOnce we are outside the inner-loop, we check if flag is True. if that is the case, then we increment count as we have hit upon a prime number.\n\nSome important points regarding nested loops:\n\nNesting is not restricted to #!py for loops. Any one of the following combinations is possible:\n\n#!py for inside #!py for\n#!py for inside #!py while\n#!py while inside #!py while\n#!py while inside #!py for\n\nMultiple levels of nesting is possible."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.3.html#py-while-versus-py-for",
    "href": "notes/chapter-3/lesson-3.3.html#py-while-versus-py-for",
    "title": "Lesson-3.3",
    "section": "",
    "text": "#!py for loops are typically used in situations where the number of iterations can be quantified, whereas #!py while loops are used in situations where the number of iterations cannot be quantified exactly. This doesn’t mean that the number of iterations in a #!py for loop is always constant. For example:\nn = int(input())\nfor i in range(n):\n    print(i ** 2)\nIn the code given above, the number of iterations will keep varying every time the code is run with a different input. But given the knowledge of the input, the number of iterations is fixed. On the other hand, consider the following example:\nx = int(input())\nwhile x &gt; 0:\n    x = int(input())\nThe number of iterations in the above code can be determined only after it terminates. There is no way of quantifying the number of iterations as an explicit function of user input."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.3.html#print-end-sep",
    "href": "notes/chapter-3/lesson-3.3.html#print-end-sep",
    "title": "Lesson-3.3",
    "section": "",
    "text": "Consider the following problem:\n!!! question ” ” Accept a positive integer n as input and print all the numbers from 1 to n in a single line separated by commas.\nFor a given value of n, say n = 9, we want the output to be:\n1,2,3,4,5,6,7,8,9\nThe following solution won’t work:\nn = int(input())\nfor i in range(1, n + 1):\n    print(i, ',')\nFor n = 9, this will give the following output:\n1 ,\n2 ,\n3 ,\n4 ,\n5 ,\n6 ,\n7 ,\n8 ,\n9 ,\nThankfully, the print function provides a way to solve this problem:\nn = int(input())\nfor i in range(1, n):\n    print(i, end = ',')\nprint(n)\nFor n = 9, this will give the required output:\n1,2,3,4,5,6,7,8,9\nWhenever we use the #!py print() function, it prints the expression passed to it and immediately follows it up by printing a newline. This is the default behaviour of #!py print(). It can be altered by using a special argument called end. The default value of end is set to the newline character. So, whenever the end argument is not explicitly specified in the print function, a newline is appended to the input expression by default. In the code given above, by setting end to be a comma, we are forcing the #!py print() function to insert a comma instead of a newline at the end of the expression passed to it. It is called end because it is added at the end. To get a better picture, consider the following code:\nprint()\nprint(end = ',')\nprint(1)\nprint(1, end = ',')\nprint(2, end = ',')\nprint(3, end = ',')\nThis output is:\n\n,1\n1,2,3,\nEven though nothing is being passed to the print function in the first line of code, the first line in the output is a newline because the default value of end is a newline character ('\\n'). No expression is passed as input to print in the second line of code as well, but end is set to ,. So, only a comma is printed. Notice that line 3 of the code is printed in line 2 of the output. This is because end was set to , instead of the newline character in line 2 of the code.\n\n\n\nIf multiple expressions are passed to the #!py print() function, it prints all of them in the same line, by adding a space between adjacent expressions. For example:\nprint('this', 'is', 'cool')\nThe output is:\nthis is cool\nWhat if we do not want the space or if want some other separator? This can be done using sep:\nprint('this', 'is', 'cool', sep = ',')\nThe output is:\nthis,is,cool\nWe could also have an empty string as the separator:\nprint('this', 'is', 'cool', sep = '')\nThe output will then be:\nthisiscool\n\n\n\nLet us look at one final example that makes use of both end and sep:\n!!! question ” ” Accept a positive integer n, which is also a multiple of 3, as input and print the following pattern:\n```\n|1,2,3|4,5,6|7,8,9|...|n - 2,n - 1,n|\n```\n\nFor `n = 9`, we would like to print:\n\n```\n|1,2,3|4,5,6|7,8,9|\n```\nSolution\nn = int(input())\nprint('|', end = '')\nfor i in range(1, n + 1, 3):\n    print(i, i + 1, i + 2, sep = ',', end = '|')\nprint()\nNotice that the #!py for loop iterates in steps of 3 starting from 1. To print the comma separated triplet i,i + 1,i + 2, sep is set to ,. After printing each triplet, the symbol | needs to be printed. This is achieved by setting end to be equal to |. Line 2 makes sure that the symbol | is present at the beginning of the pattern. The last #!py print() statement outside the loop is there so that the prompt can move to the next line on the console once the pattern has been printed. You can try removing the last line and see how that changes the output on the console."
  },
  {
    "objectID": "notes/chapter-7/lesson-7.4.html",
    "href": "notes/chapter-7/lesson-7.4.html",
    "title": "Lesson 7.4",
    "section": "",
    "text": "Let us continue working with examples.txt that we created in the previous lesson. If you recall, examples.txt has the following contents:\none\ntwo\nthree\nfour\nfive\nLet us now look at a different way of reading from a file, using the #!py read() method.\nf = open('examples.txt', 'r')\ncontent = f.read()\nprint(content)\nf.close()\nThis gives the following output:\none\ntwo\nthree\nfour\nfive\n#!py read() is a method defined for the file object. When it is called without any argument, it returns a string that contains the entire content of the file. If you head to the console (it is to the right of the editor in Replit) and type the string content, this is what you get:\n'one\\ntwo\\nthree\\nfour\\nfive'\nNotice that content is a single string. It contains the contents of the file, but between consecutive lines in the file, there is a #!py '\\n':\n\n\n\n\nContents of the variable content\n\n\nExcept for the last line, every line in the file ends with a #!py '\\n' character. When this string is printed to the console — #!py print(content) — we get five separate lines even though we are only passing a single string to the #!py print() function. This is because of the presence of the newline character in the string. Whenever a newline character is encountered, the Python interpreter moves to the next line.\nNow, it is clear why the following piece of code printed an extra line between consecutive lines in the file:\nf = open('examples.txt', 'r')\nfor line in f:\n    print(line)     \n    # line ends with a \\n character for all lines except the last one\n    # this is why we get an empty line between consecutive lines in the console\nf.close()\n\n\n\n\nAs its name suggests, the #!py readline() method reads from the file one line at a time:\nf = open('examples.txt', 'r')\nline1 = f.readline()\nline2 = f.readline()\nline3 = f.readline()\nline4 = f.readline()\nline5 = f.readline()\nf.close()\nThe variables line1, line2, …, line5 will hold the following values at the end of execution of the code given above:\n\n\n\n\nVariable\nValue\n\n\n\n\nline1\n#!py 'one\\n'\n\n\nline2\n#!py 'two\\n'\n\n\nline3\n#!py 'three\\n'\n\n\nline4\n#!py 'four\\n'\n\n\nline5\n#!py 'five'\n\n\n\n\nNotice that line5 doesn’t have a #!py '\\n' at the end as it is the last line in the file. Here, we know that there are five lines in the file. This helped us define five separate variables. But what if there are more lines? Generally, we read a file so as to see what its contents are because we don’t know what is there in it. Clearly, we need a way to figure out when the file ends.\nNow, consider the following code. What happens if we try to read the file using #!py readline() after all the lines in the file have been read?\nf = open('examples.txt', 'r')\nline1 = f.readline()\nline2 = f.readline()\nline3 = f.readline()\nline4 = f.readline()\nline5 = f.readline()\nline = f.readline()\nf.close()\nIf we execute this and head to the console, we see that the variable line defined in line 7 is an empty string! This gives us a way to determine when a file is empty:\n!!! question ” ” Keep reading lines from the file until an empty string is encountered.\nLet us implement this:\nf = open('examples.txt', 'r')\nline = f.readline()\nwhile line != '':\n    print(line, end = '')\n    line = f.readline()\nf.close()\nHere, we have managed to read the file using just one string variable. Let us make few more changes to this code:\nf = open('examples.txt', 'r')\nline = f.readline()\nwhile line:\n    print(line.strip())\n    line = f.readline()\nf.close()\nIn this code, we have made two changes. One in line 3 and another in line 4. The loop condition in line-3 checks for the empty string. If line is an empty string, it evaluates to False and the loop will be terminated. This is a compact way of writing #!py line != ''. Python treats empty sequences as False. If this is confusing, execute the following code and check the output:\nline = ''\nif not line:\n    print('It works!')  \nIn line 4, we are using the #!py strip() method to strip the string line of all the whitespace characters at the beginning and at the end. In this way, the trailing newline at the end of line will be stripped. This way, we don’t need to use the end argument.\n\n\n\nFinally, Python also provides a way to read the file and store it as a list of lines:\nf = open('examples.txt', 'r')\nlines = f.readlines()\nfor line in lines:\n    print(line.strip())\nf.close()\nHere, lines is a list of lines. Notice that each element in lines corresponds to one line in the file. It is always a string:\n['one\\n', 'two\\n', 'three\\n', 'four\\n', 'five']\n\n\n\nWe already saw the #!py write() method earlier. There, we used the #!py write() method five times to write five lines. Let us now use a loop with the help of the lines list. First, we run the code:\nf = open('writing.txt', 'w')\nlines = ['one', 'two', 'three', 'four', 'five']\nfor line in lines:\n    f.write(line + '\\n')\nf.close()\nWhen we execute this, the following file is created:\n\n\n\nContents of writing.txt after execution of above code\n\n\nWe see that there are six lines in the file and not five, though we seem to have written only five lines. The problem is with line-4, where we are adding #!py '\\n' after every string in the list lines. We should make sure that we don’t add a #!py '\\n' after the last string in the list:\nf = open('writing.txt', 'w')\nlines = ['one', 'two', 'three', 'four', 'five']\nfor i in range(len(lines)):\n    line = lines[i]\n    if i != len(lines) - 1:\n        f.write(line + '\\n')\n    else:\n        f.write(line)\nf.close()\nNow, check the file, you will see that it has exactly five lines! Let us now try to write an integer to the file:\nf = open('writing.txt', 'w')\nf.write(1)\nf.close()\nThis throws the following error:\nTraceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    f.write(1)\nTypeError: write() argument must be str, not int\nWe see that #!py write() method accepts only string arguments. If we want to write integers to a file, we have to first convert them to strings:\nf = open('writing.txt', 'w')\nf.write(str(1))\nf.close()\n!!! question ” ” As an exercise, try to run the following code. What do you observe? Why do you think this happens?\n```python\nf = open('writing.txt', 'w')\nf.writeline(str(1))\nf.close()\n```\n\n\n\nWe can write a list of lines to a file using the #!py writelines() method:\nf = open('writing.txt', 'w')\nlines = ['1\\n', '2\\n', '3\\n', '4\\n', '5']\nf.writelines(lines)\nf.close()\nNote that the argument passed to the #!py writelines() method is a list of strings. This will create a file having the following contents:\n1\n2\n3\n4\n5"
  },
  {
    "objectID": "notes/chapter-7/lesson-7.4.html#file-methods",
    "href": "notes/chapter-7/lesson-7.4.html#file-methods",
    "title": "Lesson 7.4",
    "section": "",
    "text": "Let us continue working with examples.txt that we created in the previous lesson. If you recall, examples.txt has the following contents:\none\ntwo\nthree\nfour\nfive\nLet us now look at a different way of reading from a file, using the #!py read() method.\nf = open('examples.txt', 'r')\ncontent = f.read()\nprint(content)\nf.close()\nThis gives the following output:\none\ntwo\nthree\nfour\nfive\n#!py read() is a method defined for the file object. When it is called without any argument, it returns a string that contains the entire content of the file. If you head to the console (it is to the right of the editor in Replit) and type the string content, this is what you get:\n'one\\ntwo\\nthree\\nfour\\nfive'\nNotice that content is a single string. It contains the contents of the file, but between consecutive lines in the file, there is a #!py '\\n':\n\n\n\n\nContents of the variable content\n\n\nExcept for the last line, every line in the file ends with a #!py '\\n' character. When this string is printed to the console — #!py print(content) — we get five separate lines even though we are only passing a single string to the #!py print() function. This is because of the presence of the newline character in the string. Whenever a newline character is encountered, the Python interpreter moves to the next line.\nNow, it is clear why the following piece of code printed an extra line between consecutive lines in the file:\nf = open('examples.txt', 'r')\nfor line in f:\n    print(line)     \n    # line ends with a \\n character for all lines except the last one\n    # this is why we get an empty line between consecutive lines in the console\nf.close()\n\n\n\n\nAs its name suggests, the #!py readline() method reads from the file one line at a time:\nf = open('examples.txt', 'r')\nline1 = f.readline()\nline2 = f.readline()\nline3 = f.readline()\nline4 = f.readline()\nline5 = f.readline()\nf.close()\nThe variables line1, line2, …, line5 will hold the following values at the end of execution of the code given above:\n\n\n\n\nVariable\nValue\n\n\n\n\nline1\n#!py 'one\\n'\n\n\nline2\n#!py 'two\\n'\n\n\nline3\n#!py 'three\\n'\n\n\nline4\n#!py 'four\\n'\n\n\nline5\n#!py 'five'\n\n\n\n\nNotice that line5 doesn’t have a #!py '\\n' at the end as it is the last line in the file. Here, we know that there are five lines in the file. This helped us define five separate variables. But what if there are more lines? Generally, we read a file so as to see what its contents are because we don’t know what is there in it. Clearly, we need a way to figure out when the file ends.\nNow, consider the following code. What happens if we try to read the file using #!py readline() after all the lines in the file have been read?\nf = open('examples.txt', 'r')\nline1 = f.readline()\nline2 = f.readline()\nline3 = f.readline()\nline4 = f.readline()\nline5 = f.readline()\nline = f.readline()\nf.close()\nIf we execute this and head to the console, we see that the variable line defined in line 7 is an empty string! This gives us a way to determine when a file is empty:\n!!! question ” ” Keep reading lines from the file until an empty string is encountered.\nLet us implement this:\nf = open('examples.txt', 'r')\nline = f.readline()\nwhile line != '':\n    print(line, end = '')\n    line = f.readline()\nf.close()\nHere, we have managed to read the file using just one string variable. Let us make few more changes to this code:\nf = open('examples.txt', 'r')\nline = f.readline()\nwhile line:\n    print(line.strip())\n    line = f.readline()\nf.close()\nIn this code, we have made two changes. One in line 3 and another in line 4. The loop condition in line-3 checks for the empty string. If line is an empty string, it evaluates to False and the loop will be terminated. This is a compact way of writing #!py line != ''. Python treats empty sequences as False. If this is confusing, execute the following code and check the output:\nline = ''\nif not line:\n    print('It works!')  \nIn line 4, we are using the #!py strip() method to strip the string line of all the whitespace characters at the beginning and at the end. In this way, the trailing newline at the end of line will be stripped. This way, we don’t need to use the end argument.\n\n\n\nFinally, Python also provides a way to read the file and store it as a list of lines:\nf = open('examples.txt', 'r')\nlines = f.readlines()\nfor line in lines:\n    print(line.strip())\nf.close()\nHere, lines is a list of lines. Notice that each element in lines corresponds to one line in the file. It is always a string:\n['one\\n', 'two\\n', 'three\\n', 'four\\n', 'five']\n\n\n\nWe already saw the #!py write() method earlier. There, we used the #!py write() method five times to write five lines. Let us now use a loop with the help of the lines list. First, we run the code:\nf = open('writing.txt', 'w')\nlines = ['one', 'two', 'three', 'four', 'five']\nfor line in lines:\n    f.write(line + '\\n')\nf.close()\nWhen we execute this, the following file is created:\n\n\n\nContents of writing.txt after execution of above code\n\n\nWe see that there are six lines in the file and not five, though we seem to have written only five lines. The problem is with line-4, where we are adding #!py '\\n' after every string in the list lines. We should make sure that we don’t add a #!py '\\n' after the last string in the list:\nf = open('writing.txt', 'w')\nlines = ['one', 'two', 'three', 'four', 'five']\nfor i in range(len(lines)):\n    line = lines[i]\n    if i != len(lines) - 1:\n        f.write(line + '\\n')\n    else:\n        f.write(line)\nf.close()\nNow, check the file, you will see that it has exactly five lines! Let us now try to write an integer to the file:\nf = open('writing.txt', 'w')\nf.write(1)\nf.close()\nThis throws the following error:\nTraceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    f.write(1)\nTypeError: write() argument must be str, not int\nWe see that #!py write() method accepts only string arguments. If we want to write integers to a file, we have to first convert them to strings:\nf = open('writing.txt', 'w')\nf.write(str(1))\nf.close()\n!!! question ” ” As an exercise, try to run the following code. What do you observe? Why do you think this happens?\n```python\nf = open('writing.txt', 'w')\nf.writeline(str(1))\nf.close()\n```\n\n\n\nWe can write a list of lines to a file using the #!py writelines() method:\nf = open('writing.txt', 'w')\nlines = ['1\\n', '2\\n', '3\\n', '4\\n', '5']\nf.writelines(lines)\nf.close()\nNote that the argument passed to the #!py writelines() method is a list of strings. This will create a file having the following contents:\n1\n2\n3\n4\n5"
  },
  {
    "objectID": "notes/chapter-7/lesson-7.2.html",
    "href": "notes/chapter-7/lesson-7.2.html",
    "title": "Lesson-7.2",
    "section": "",
    "text": "Let us use Replit and use the Add File button to create a file.\n\n\n\nReplit interface\n\n\nEach file should be given a name. Let us call our file examples.txt. Now, we shall add the following lines to the file:\none\ntwo\nthree\nfour\nfive\nAfter creating the file, this is how it should look in Replit when we click on examples.txt:\n\n\n\nReplit interface\n\n\nexamples.txt is called a text file. We can identify this from the extension — txt that comes at the end of files. Don’t worry too much about the extension. It is enough if you know that different files come with different extensions. In fact, main.py is itself a file with py as the extension. This is why it gets listed along with examples.txt under the Files tab in Replit.\n\n\n\nNow, it is time to open the file and print the contents on to the console. For this, we head to main.py and type the following lines.\nf = open('examples.txt', 'r')\nfor line in f:\n    print(line)\nf.close()\n#!py open() is a built-in function in Python that accepts two arguments:\n\nfile name\nmode\n\nThe first argument is the file name, which is #!py 'examples.txt' in our case. The second argument corresponds to the mode in which we want to process the file. In this case, we want to read the file. So, we open the file in read-mode. The single character #!py 'r' is used to denote this mode. Notice that both the arguments passed to #!py open() are strings.\nThe #!py open() function returns a file object. Do no worry about the terminology for now. We will discuss it in detail in the next lesson. For now, it is enough to know that the #!py open() function returns a file object that we have called f in our code.\nIn lines 2-3, we loop through each line in the file and print it. As simple as that. Finally, in line 4, we close the file using the method #!py close(). It is a good practice to close the file once we are done with processing it. Let us now see the output at the end of execution of this code block:\none\n\ntwo\n\nthree\n\nfour\n\nfive\nNow that doesn’t seem right. We have all the contents of the file, but for whatever reason, there is an extra line between successive lines in the file. To suppress these new lines, we have to modify our print function slightly:\nf = open('examples.txt', 'r')\nfor line in f:\n    print(line, end = '')   # there is NO SPACE between the quotes\nf.close()\n\nNote the change in line 3. By default, #!py print() appends a newline character (#!py '\\n') at the end of whatever it is printing. By using #!py end = '', we are just appending the empty string. Therefore, the extra line that was appearing in the output will no longer bother us when we execute the code we have just written:\none\ntwo\nthree\nfour\nfive\n\n\n\nConsider the following code-block:\n\nf = open('writing.txt', 'w')\nf.write('one ')\nf.write('two ')\nf.write('three ')\nf.write('four ')\nf.write('five')\nf.close()\nHere, we have opened the file in write mode. When this code is executed, it creates a file in Replit called writing.txt.\n\n\n\nContents of writing.txt\n\n\nWe have used what is called the #!py write() method to write to the file. We pass the content we wish to write as a string argument to the method. Notice that, even though we have used the #!py write() method to write five different words on five lines in the code, all of them get written to the same line in the file. The way to tell the file object to go to a new line is using the #!py '\\n' character. Let us now, try the following piece of code:\nf = open('writing.txt', 'w')\nf.write('one')\nf.write('\\n')\nf.write('two')\nf.write('\\n')\nf.write('three')\nf.write('\\n')\nf.write('four')\nf.write('\\n')\nf.write('five')\nf.close()\n\n\n\nContents of writing.txt after execution of above code\n\n\nA better way of achieving this in fewer lines of code is to append the \\n character to every line of the file we wish to write:\nf = open('writing.txt', 'w')\nf.write('one\\n')\nf.write('two\\n')\nf.write('three\\n')\nf.write('four\\n')\nf.write('five')\nf.close()\nThis results in the same file but with fewer lines of code! In the next lesson, we will take a closer look at the idea of a file object.\nNotice that we didn’t add a #!py '\\n' after five. Why do you think that is the case? Try running the code with #!py '\\n' after five."
  },
  {
    "objectID": "notes/chapter-7/lesson-7.2.html#file-handling",
    "href": "notes/chapter-7/lesson-7.2.html#file-handling",
    "title": "Lesson-7.2",
    "section": "",
    "text": "Let us use Replit and use the Add File button to create a file.\n\n\n\nReplit interface\n\n\nEach file should be given a name. Let us call our file examples.txt. Now, we shall add the following lines to the file:\none\ntwo\nthree\nfour\nfive\nAfter creating the file, this is how it should look in Replit when we click on examples.txt:\n\n\n\nReplit interface\n\n\nexamples.txt is called a text file. We can identify this from the extension — txt that comes at the end of files. Don’t worry too much about the extension. It is enough if you know that different files come with different extensions. In fact, main.py is itself a file with py as the extension. This is why it gets listed along with examples.txt under the Files tab in Replit.\n\n\n\nNow, it is time to open the file and print the contents on to the console. For this, we head to main.py and type the following lines.\nf = open('examples.txt', 'r')\nfor line in f:\n    print(line)\nf.close()\n#!py open() is a built-in function in Python that accepts two arguments:\n\nfile name\nmode\n\nThe first argument is the file name, which is #!py 'examples.txt' in our case. The second argument corresponds to the mode in which we want to process the file. In this case, we want to read the file. So, we open the file in read-mode. The single character #!py 'r' is used to denote this mode. Notice that both the arguments passed to #!py open() are strings.\nThe #!py open() function returns a file object. Do no worry about the terminology for now. We will discuss it in detail in the next lesson. For now, it is enough to know that the #!py open() function returns a file object that we have called f in our code.\nIn lines 2-3, we loop through each line in the file and print it. As simple as that. Finally, in line 4, we close the file using the method #!py close(). It is a good practice to close the file once we are done with processing it. Let us now see the output at the end of execution of this code block:\none\n\ntwo\n\nthree\n\nfour\n\nfive\nNow that doesn’t seem right. We have all the contents of the file, but for whatever reason, there is an extra line between successive lines in the file. To suppress these new lines, we have to modify our print function slightly:\nf = open('examples.txt', 'r')\nfor line in f:\n    print(line, end = '')   # there is NO SPACE between the quotes\nf.close()\n\nNote the change in line 3. By default, #!py print() appends a newline character (#!py '\\n') at the end of whatever it is printing. By using #!py end = '', we are just appending the empty string. Therefore, the extra line that was appearing in the output will no longer bother us when we execute the code we have just written:\none\ntwo\nthree\nfour\nfive\n\n\n\nConsider the following code-block:\n\nf = open('writing.txt', 'w')\nf.write('one ')\nf.write('two ')\nf.write('three ')\nf.write('four ')\nf.write('five')\nf.close()\nHere, we have opened the file in write mode. When this code is executed, it creates a file in Replit called writing.txt.\n\n\n\nContents of writing.txt\n\n\nWe have used what is called the #!py write() method to write to the file. We pass the content we wish to write as a string argument to the method. Notice that, even though we have used the #!py write() method to write five different words on five lines in the code, all of them get written to the same line in the file. The way to tell the file object to go to a new line is using the #!py '\\n' character. Let us now, try the following piece of code:\nf = open('writing.txt', 'w')\nf.write('one')\nf.write('\\n')\nf.write('two')\nf.write('\\n')\nf.write('three')\nf.write('\\n')\nf.write('four')\nf.write('\\n')\nf.write('five')\nf.close()\n\n\n\nContents of writing.txt after execution of above code\n\n\nA better way of achieving this in fewer lines of code is to append the \\n character to every line of the file we wish to write:\nf = open('writing.txt', 'w')\nf.write('one\\n')\nf.write('two\\n')\nf.write('three\\n')\nf.write('four\\n')\nf.write('five')\nf.close()\nThis results in the same file but with fewer lines of code! In the next lesson, we will take a closer look at the idea of a file object.\nNotice that we didn’t add a #!py '\\n' after five. Why do you think that is the case? Try running the code with #!py '\\n' after five."
  },
  {
    "objectID": "notes/chapter-7/lesson-7.3.html",
    "href": "notes/chapter-7/lesson-7.3.html",
    "title": "Lesson 7.3",
    "section": "",
    "text": "As mentioned earlier, the #!py open() function returns a file object. The following image gives a better picture of the whole setup.\n\nWhat is a file object? Let us use the following analogy:\nYou are the CEO of a tech company. Even though you are good at multi-tasking, there are simply too many things for you to keep track of. To help you manage the mounting load of activities, you hire a personal assistant (PA). Think about the kind of work you generally assign to a PA. Let us say that you are meeting delegates from another company at 5:00 PM next Tuesday. The typical instruction to your PA would be this: “make a note of this meeting”. Your PA would dutifully record this information in a file.\nFew days later, you might be suddenly reminded of this important meeting. At this point, this would be your instruction: “fetch me the details of the meeting with those delegates”. In both cases, notice that it is your PA who is interacting with a file. In the first instruction, your PA noted down the details of a meeting in a file. In the second instruction, your PA retrieved the information from the file.\nThe file object is your PA who mediates between you, the coder, and the file that resides on the hard disk of your computer. You pass an instruction to your file object, which does the job of reading and writing to a file. All communication between you and the file is routed through the file object.\n\n\nIn the following sections, we will briefly discuss about the two modes that a file can be opened in. We will go in depth in later lessons.\n\n\nThe dotted line in the image given below corresponds to the mode in which you wish to process the file. This instruction always originates from you and is directed at the file object. When you are reading from a file, information flows from the file, through the file object and reaches you. This represented by the solid arrow.\n\nTo read a file, we open it in the read mode:\nf = open('&lt;file_name&gt;', 'r')\n# ...\n# code for reading something from file\n# ...\nf.close()\n\n\n\nWhen you are writing to a file, information flows from you, through the file object and to the file.\n\nTo write to a file, we open it in the write mode:\nf = open('&lt;file_name&gt;', 'w')\n# ...\n# code for writing something into the file\n# ...\nf.close()\nIn the next lesson, we will see some more aspects of file handling."
  },
  {
    "objectID": "notes/chapter-7/lesson-7.3.html#file-object",
    "href": "notes/chapter-7/lesson-7.3.html#file-object",
    "title": "Lesson 7.3",
    "section": "",
    "text": "As mentioned earlier, the #!py open() function returns a file object. The following image gives a better picture of the whole setup.\n\nWhat is a file object? Let us use the following analogy:\nYou are the CEO of a tech company. Even though you are good at multi-tasking, there are simply too many things for you to keep track of. To help you manage the mounting load of activities, you hire a personal assistant (PA). Think about the kind of work you generally assign to a PA. Let us say that you are meeting delegates from another company at 5:00 PM next Tuesday. The typical instruction to your PA would be this: “make a note of this meeting”. Your PA would dutifully record this information in a file.\nFew days later, you might be suddenly reminded of this important meeting. At this point, this would be your instruction: “fetch me the details of the meeting with those delegates”. In both cases, notice that it is your PA who is interacting with a file. In the first instruction, your PA noted down the details of a meeting in a file. In the second instruction, your PA retrieved the information from the file.\nThe file object is your PA who mediates between you, the coder, and the file that resides on the hard disk of your computer. You pass an instruction to your file object, which does the job of reading and writing to a file. All communication between you and the file is routed through the file object.\n\n\nIn the following sections, we will briefly discuss about the two modes that a file can be opened in. We will go in depth in later lessons.\n\n\nThe dotted line in the image given below corresponds to the mode in which you wish to process the file. This instruction always originates from you and is directed at the file object. When you are reading from a file, information flows from the file, through the file object and reaches you. This represented by the solid arrow.\n\nTo read a file, we open it in the read mode:\nf = open('&lt;file_name&gt;', 'r')\n# ...\n# code for reading something from file\n# ...\nf.close()\n\n\n\nWhen you are writing to a file, information flows from you, through the file object and to the file.\n\nTo write to a file, we open it in the write mode:\nf = open('&lt;file_name&gt;', 'w')\n# ...\n# code for writing something into the file\n# ...\nf.close()\nIn the next lesson, we will see some more aspects of file handling."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.2.html",
    "href": "notes/chapter-8/lesson-8.2.html",
    "title": "Lesson 8.2",
    "section": "",
    "text": "Let us continue with the Student class. For now, don’t bother too much about the variable self. We will get to that soon.\nclass Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n           \n    def update_marks(self, marks):\n        self.marks = marks\n        \n    def print_details(self):\n        print(f'{self.name}:{self.marks}')\nAs we saw at the end of the previous lesson, an object of the class Student can be created like this:\npython linenums=\"11\" anish = Student('Anish', 80)\nNotice that we have used the name of the class in the RHS of the assignment statement. This invokes what is called the constructor — #!py __init__() method — of the class. Since the constructor has two parameters (ignore #!py self for now) name and marks, we have to pass them as arguments while creating the object.\nThe two arguments are then assigned to #!py self.name and #!py self.marks respectively. These two variables are called the attributes of the object. Attributes can be accessed using the . operator:\npython linenums=\"12\" print(anish.name) print(anish.marks)\n#!py __init__(), #!py update_marks() and #!py print_details() are called methods. A method is effectively just a function that is defined in a class. Methods can be accessed using an object. If we wish to update Anish’s marks to \\(95\\), then we invoke the method using the object anish:\npython linenums=\"14\" anish.update_marks(95)\nWhen #!py anish.update_marks(95) is called, the attribute marks that is tied to the object anish is updated to \\(95\\).\nTo summarize, anish is an object of type Student having two attributes — name and marks — that can be accessed using the #!py . operator. This object is also equipped with two methods (ignoring the constructor), one to update the marks and the other to print the details of the object. Attributes define the state of an object. Different objects of the same class could have different attributes. Naively speaking, methods help to update the values of the attributes. Therefore, the methods capture the behaviour of the object.\n\n\n\nSome of you might be wondering about the variable #!py self that crops in so many places in the definition of the class. The variable #!py self is used to point to the current object. To get a better understanding, let us create two different Student objects:\nanish = Student('Anish', 90)\nlakshmi = Student('Lakshmi', 95)\nHow do we print the details of the student Lakshmi?\nlakshmi.print_details()\nWhen this method is called, Python actually ends up invoking the following function:\nStudent.print_details(lakshmi)\nThat is, it passes the current object as an argument. So, the variable #!py self points to the current object. Another example:\nanish.update_marks(95)\nThis is equivalent to the function call:\nStudent.update_marks(anish, 95)\nThis is a mechanism that Python uses to know the object that it is dealing with. And for this reason, the first parameter in every method defined in a class will be #!py self, and it will point to the object calling the method i.e., the current object.\nThis should also clear up any confusion that lines 3 and 4 could have caused:\nclass Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n#!py self.name = name is the following operation: assign the value of the argument name to the current object’s attribute #!py self.name. A similar operation follows for #!py self.marks.\n\n\n\nSo far all attributes that we have seen are object attributes. Given an attribute, say name or marks, it is different for different objects. The name attribute of anish is different from the corresponding attribute fo the object lakshmi. Now, we shall see another kind of attribute.\nLet us say that we wish to keep track of the number students in our program. That is, when a new student joins our program, we need to update a counter. How do we do that? We need an attribute that is common to all objects and is not tied to any individual object. At the same time, we should be able to update this attribute whenever a new object is created. This is where the concept of class attributes comes in:\nclass Student:\n    counter = 0\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n        Student.counter += 1\n           \n    def update_marks(self, marks):\n        self.marks = marks\n        \n    def print_details(self):\n        print(f'{self.name}:{self.marks}')\nNow, let us say that three students join the program:\npython linenums=\"13\" madhavan = Student('Madhavan', 90) print('Number of students in the program =', Student.counter) andrew = Student('Andrew', 85) print('Number of students in the program =', Student.counter) usha = Student('Usha', 95) print('Number of students in the program =', Student.counter)\nThis gives the following output:\nNumber of students in the program = 1\nNumber of students in the program = 2\nNumber of students in the program = 3\nNotice that we have used #!py Student.counter to access the attribute counter. Such attributes are called class attributes. All objects of the class share this attribute. At this stage, we can try the following exercise. What do you think the output will be?\npython linenums=\"19\" print(madhavan.counter)\n??? abstract “OUTPUT” linenums=\"4\"     3\nA class attribute can be accessed by any of the objects. But, now, try to run this code:\npython linenums=\"20\" madhavan.counter = -1 print(\"Student counter:\", Student.counter) print(\"Madhavan counter:\", madhavan.counter)\n??? abstract “OUTPUT” linenums=\"5\"     Student counter: 3     Madhavan counter: -1\nThis seems confusing! But a moment’s thought will convince you that it is not so hard. In line 20, we are creating an object attribute with the same name as the class attribute! If the same attribute name occurs in both an object and a class, then Python prioritizes the object attribute. In other words, when we change #!py madhavan.counter, #!py Student.counter remains unchanged because #!py madhavan.counter gets delinked from #!py Student.counter and becomes a new object attribute specific to madhavan. To change Student.counter:\npython linenums=\"23\" Student.counter = 0 print(Student.counter)\n??? abstract “OUTPUT” linenums=\"7\"     Student counter: 0\nNow try this as an exercise and try to figure out why the output is the way it is:\npython linenums=\"25\" print(\"Usha counter:\", usha.counter) print(\"Madhavan counter:\", madhavan.counter) Rohan = Student('Rohan', 40) print(\"Student counter:\", Student.counter) print(\"Usha counter:\", usha.counter) print(\"Madhavan counter:\", madhavan.counter)\n??? abstract “OUTPUT” linenums=\"8\"     Usha counter: 0     Madhavan counter: -1     Student counter: 1     Usha counter: 1     Madhavan counter: -1\nThis demonstrates an important fact: class attributes cannot be updated by an object! At best, they can be referenced or accessed using an object\nThis also introduces another important point: object attributes can be created dynamically during runtime. So far, we have seen object attributes being created within the constructor. This is not binding. For example, consider the following snippet:\nclass Student:\n    def __init__(self, name):\n        self.name = name\n        \nanish = Student('Anish')\nanish.maths = 100\nanish.physics = 90\nanish.chem = 70\nWe have created three more object attributes on the fly. It is interesting to note the subtle difference between the attribute name and the three new attributes maths, physics and chem. Any object of Student will have the attribute name when it is initially created, of course with a different value for name depending on the object. But the attributes maths, physics and chem are unique to the object anish."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.2.html#classes-and-objects",
    "href": "notes/chapter-8/lesson-8.2.html#classes-and-objects",
    "title": "Lesson 8.2",
    "section": "",
    "text": "Let us continue with the Student class. For now, don’t bother too much about the variable self. We will get to that soon.\nclass Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n           \n    def update_marks(self, marks):\n        self.marks = marks\n        \n    def print_details(self):\n        print(f'{self.name}:{self.marks}')\nAs we saw at the end of the previous lesson, an object of the class Student can be created like this:\npython linenums=\"11\" anish = Student('Anish', 80)\nNotice that we have used the name of the class in the RHS of the assignment statement. This invokes what is called the constructor — #!py __init__() method — of the class. Since the constructor has two parameters (ignore #!py self for now) name and marks, we have to pass them as arguments while creating the object.\nThe two arguments are then assigned to #!py self.name and #!py self.marks respectively. These two variables are called the attributes of the object. Attributes can be accessed using the . operator:\npython linenums=\"12\" print(anish.name) print(anish.marks)\n#!py __init__(), #!py update_marks() and #!py print_details() are called methods. A method is effectively just a function that is defined in a class. Methods can be accessed using an object. If we wish to update Anish’s marks to \\(95\\), then we invoke the method using the object anish:\npython linenums=\"14\" anish.update_marks(95)\nWhen #!py anish.update_marks(95) is called, the attribute marks that is tied to the object anish is updated to \\(95\\).\nTo summarize, anish is an object of type Student having two attributes — name and marks — that can be accessed using the #!py . operator. This object is also equipped with two methods (ignoring the constructor), one to update the marks and the other to print the details of the object. Attributes define the state of an object. Different objects of the same class could have different attributes. Naively speaking, methods help to update the values of the attributes. Therefore, the methods capture the behaviour of the object."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.2.html#py-self",
    "href": "notes/chapter-8/lesson-8.2.html#py-self",
    "title": "Lesson 8.2",
    "section": "",
    "text": "Some of you might be wondering about the variable #!py self that crops in so many places in the definition of the class. The variable #!py self is used to point to the current object. To get a better understanding, let us create two different Student objects:\nanish = Student('Anish', 90)\nlakshmi = Student('Lakshmi', 95)\nHow do we print the details of the student Lakshmi?\nlakshmi.print_details()\nWhen this method is called, Python actually ends up invoking the following function:\nStudent.print_details(lakshmi)\nThat is, it passes the current object as an argument. So, the variable #!py self points to the current object. Another example:\nanish.update_marks(95)\nThis is equivalent to the function call:\nStudent.update_marks(anish, 95)\nThis is a mechanism that Python uses to know the object that it is dealing with. And for this reason, the first parameter in every method defined in a class will be #!py self, and it will point to the object calling the method i.e., the current object.\nThis should also clear up any confusion that lines 3 and 4 could have caused:\nclass Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n#!py self.name = name is the following operation: assign the value of the argument name to the current object’s attribute #!py self.name. A similar operation follows for #!py self.marks."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.2.html#class-attributes-vs-object-attributes",
    "href": "notes/chapter-8/lesson-8.2.html#class-attributes-vs-object-attributes",
    "title": "Lesson 8.2",
    "section": "",
    "text": "So far all attributes that we have seen are object attributes. Given an attribute, say name or marks, it is different for different objects. The name attribute of anish is different from the corresponding attribute fo the object lakshmi. Now, we shall see another kind of attribute.\nLet us say that we wish to keep track of the number students in our program. That is, when a new student joins our program, we need to update a counter. How do we do that? We need an attribute that is common to all objects and is not tied to any individual object. At the same time, we should be able to update this attribute whenever a new object is created. This is where the concept of class attributes comes in:\nclass Student:\n    counter = 0\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n        Student.counter += 1\n           \n    def update_marks(self, marks):\n        self.marks = marks\n        \n    def print_details(self):\n        print(f'{self.name}:{self.marks}')\nNow, let us say that three students join the program:\npython linenums=\"13\" madhavan = Student('Madhavan', 90) print('Number of students in the program =', Student.counter) andrew = Student('Andrew', 85) print('Number of students in the program =', Student.counter) usha = Student('Usha', 95) print('Number of students in the program =', Student.counter)\nThis gives the following output:\nNumber of students in the program = 1\nNumber of students in the program = 2\nNumber of students in the program = 3\nNotice that we have used #!py Student.counter to access the attribute counter. Such attributes are called class attributes. All objects of the class share this attribute. At this stage, we can try the following exercise. What do you think the output will be?\npython linenums=\"19\" print(madhavan.counter)\n??? abstract “OUTPUT” linenums=\"4\"     3\nA class attribute can be accessed by any of the objects. But, now, try to run this code:\npython linenums=\"20\" madhavan.counter = -1 print(\"Student counter:\", Student.counter) print(\"Madhavan counter:\", madhavan.counter)\n??? abstract “OUTPUT” linenums=\"5\"     Student counter: 3     Madhavan counter: -1\nThis seems confusing! But a moment’s thought will convince you that it is not so hard. In line 20, we are creating an object attribute with the same name as the class attribute! If the same attribute name occurs in both an object and a class, then Python prioritizes the object attribute. In other words, when we change #!py madhavan.counter, #!py Student.counter remains unchanged because #!py madhavan.counter gets delinked from #!py Student.counter and becomes a new object attribute specific to madhavan. To change Student.counter:\npython linenums=\"23\" Student.counter = 0 print(Student.counter)\n??? abstract “OUTPUT” linenums=\"7\"     Student counter: 0\nNow try this as an exercise and try to figure out why the output is the way it is:\npython linenums=\"25\" print(\"Usha counter:\", usha.counter) print(\"Madhavan counter:\", madhavan.counter) Rohan = Student('Rohan', 40) print(\"Student counter:\", Student.counter) print(\"Usha counter:\", usha.counter) print(\"Madhavan counter:\", madhavan.counter)\n??? abstract “OUTPUT” linenums=\"8\"     Usha counter: 0     Madhavan counter: -1     Student counter: 1     Usha counter: 1     Madhavan counter: -1\nThis demonstrates an important fact: class attributes cannot be updated by an object! At best, they can be referenced or accessed using an object\nThis also introduces another important point: object attributes can be created dynamically during runtime. So far, we have seen object attributes being created within the constructor. This is not binding. For example, consider the following snippet:\nclass Student:\n    def __init__(self, name):\n        self.name = name\n        \nanish = Student('Anish')\nanish.maths = 100\nanish.physics = 90\nanish.chem = 70\nWe have created three more object attributes on the fly. It is interesting to note the subtle difference between the attribute name and the three new attributes maths, physics and chem. Any object of Student will have the attribute name when it is initially created, of course with a different value for name depending on the object. But the attributes maths, physics and chem are unique to the object anish."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.3.html",
    "href": "notes/chapter-8/lesson-8.3.html",
    "title": "Lesson 8.3",
    "section": "",
    "text": "Let us get back to the fundamental philosophical idea with which we began the study of object oriented programming.\n\nUnity in diversity.\n\nThe idea of a class represents the unity, the idea of objects represent the diversity. But this diversity that we see around us is not chaotic and unordered. On the contrary, there is an organized hierarchy that we see almost everywhere around us. Consider the following image:\n\nWe humans take up different roles. Some of us are students, others are working professionals. The beauty of this program is that we have working professionals who are at the same time students. Getting back to the point, we see that there is a hierarchy. All college students are students. All students are humans. In the other branch of this directed graph, all full-stack developers are software developers, all software developers are working professionals. The basic idea behind the concept of inheritance is this:\n\nClasses that are lower in the hierarchy inherit features or attributes from their ancestors.\n\nThere are certain features of a class higher up in the hierarchy that can be inherited by classes lower in the hierarchy. For example, all working professionals draw a salary every month. All software developers also draw some monthly salary, because they belong to the class of working professionals. So, salary is an attribute that is common to all classes that are derived from the class of working professionals. Needless to say, a full stack developer inherits this attribute of salary from his ancestors in the graph.\nWe shall take up a concrete example and see inheritance in action.\n\n\n\nBy now you would have worked on plenty of assignments across multiple courses. Each assignment is a collection of questions. Questions come in different types, some are NAT, some MCQ. So, a NAT question is not of the same type as a MCQ question. Yet, both are questions. So, we see that there is a hierarchy of relationships here:\n\n\n\nHierarchy of question types\n\n\nParents always come first in the hierarchy. So, let us first define a class to represent a question:\nclass Question:\n    def __init__(self, statement, marks):\n        self.statement = statement\n        self.marks = marks\n    \n    def print_question(self):\n        print(self.statement)\n    \n    def update_marks(self, marks):\n        self.marks = marks\nNote that we have only retained those elements as attributes that are common to all questions, irrespective of the type:\n\nstatement of the question\nmarks for the question\n\nThe next step is to define two new classes for the children of Question, one for MCQ and the other for NAT. It is here that we make use of the relationship that we just diagrammed:\n```python linenums=“11” class NAT(Question): def init(self, statement, marks, answer): super().__init__(statement, marks) self.answer = answer\ndef update_answer(self, answer):\n    self.answer = answer\n\n`NAT` is also a `Question`, but a specialized question. Specifically, it has an additional feature, `answer`, and a new method, `update_answer`. But all the other attributes and methods of `Question` are inherited by it, since `NAT` is just another `Question`.\n\nWe say that `NAT` is derived from `Question`. `Question` becomes the parent-class or base-class , and `NAT` is a child-class or derived-class.\n\n![Relationship between Parent class and child class](../assets/images/img-58.png)\n\nIn Python, the syntax used to make this dependency explicit is as follows:\n\n```python\nclass Derived(Base):\n    def __init__(self, ...):\n        pass\n        \n#### OR ####\nclass Child(Parent):\n    def __init__(self, ...):\n        ...\nIn our specific example, we have:\nclass NAT(Question):\n    def __init__(self, ...):\n        pass\n\n\n\nNote that something interesting happens within the constructor of the derived class:\n```python linenums=“11” hl_lines=“3” class NAT(Question): def init(self, statement, marks, answer): super().__init__(statement, marks) self.answer = answer\ndef update_answer(self, answer):\n    self.answer = answer\n\nThe `#!py super()` function points to the parent class, in this case `Question`. So, in line 13, we are effectively calling the constructor of the parent class. If we need to update the marks, we can just invoke the method `#!py update_marks()` that is inherited from `Question`:\n\n```python linenums=\"18\"\nq_nat = NAT('What is 1 + 1?', 1, 2)\nq_nat.update_marks(4)\nprint(q_nat.marks)\n???+ abstract “OUTPUT” 4\n\n\n\nLet us now turn our attention to methods. Pasting the parent-class here for easy reference:\nclass Question:\n    def __init__(self, statement, marks):\n        self.statement = statement\n        self.marks = marks\n    \n    def print_question(self):\n        print(self.statement)\n    \n    def update_marks(self, marks):\n        self.marks = marks\nSometimes we may want to modify the behaviour of existing methods in the parent class. For example, take the case of a MCQ question. For questions of this type, the statement of a problem is incomplete without the options. The #!py print_question() method in the parent class just prints the statement, but it makes more sense to print the options as well for a MCQ question. So, we want the #!py print_question() to behave differently. Though we have inherited this method from the parent class, we can override the behaviour of the method in the following way:\n```python linenums=“11” class MCQ(Question): def init(self, statement, marks, ops, c_ops): super().__init__(statement, marks) self.ops = ops # list of all options self.c_ops = c_ops # list of correct options\ndef print_question(self):\n    super().print_question()\n    # Assume there are only four options\n    op_index = ['(a)', '(b)', '(c)', '(d)']\n    for i in range(4):\n        print(op_index[i], self.ops[i])\n\nNote that the parent class `Question` already prints the statement. So, we piggy-back on this behaviour using the `#!py super()` function in line-8. In addition, we also print the options. Let us create a `MCQ` question object and see how it all works:\n\n```python linenums=\"23\"\nq_mcq = MCQ('What is the capital of India?',\n           2,\n           ['Chennai', 'Mumbai', 'Kolkota', 'New Delhi'],\n           ['New Delhi'])\nq_mcq.print_question()\nThis returns the output:\n??? abstract “OUTPUT” What is the capital of India?     (a) Chennai     (b) Mumbai     (c) Kolkota     (d) New Delhi"
  },
  {
    "objectID": "notes/chapter-8/lesson-8.3.html#inheritance",
    "href": "notes/chapter-8/lesson-8.3.html#inheritance",
    "title": "Lesson 8.3",
    "section": "",
    "text": "Let us get back to the fundamental philosophical idea with which we began the study of object oriented programming.\n\nUnity in diversity.\n\nThe idea of a class represents the unity, the idea of objects represent the diversity. But this diversity that we see around us is not chaotic and unordered. On the contrary, there is an organized hierarchy that we see almost everywhere around us. Consider the following image:\n\nWe humans take up different roles. Some of us are students, others are working professionals. The beauty of this program is that we have working professionals who are at the same time students. Getting back to the point, we see that there is a hierarchy. All college students are students. All students are humans. In the other branch of this directed graph, all full-stack developers are software developers, all software developers are working professionals. The basic idea behind the concept of inheritance is this:\n\nClasses that are lower in the hierarchy inherit features or attributes from their ancestors.\n\nThere are certain features of a class higher up in the hierarchy that can be inherited by classes lower in the hierarchy. For example, all working professionals draw a salary every month. All software developers also draw some monthly salary, because they belong to the class of working professionals. So, salary is an attribute that is common to all classes that are derived from the class of working professionals. Needless to say, a full stack developer inherits this attribute of salary from his ancestors in the graph.\nWe shall take up a concrete example and see inheritance in action."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.3.html#concrete-example",
    "href": "notes/chapter-8/lesson-8.3.html#concrete-example",
    "title": "Lesson 8.3",
    "section": "",
    "text": "By now you would have worked on plenty of assignments across multiple courses. Each assignment is a collection of questions. Questions come in different types, some are NAT, some MCQ. So, a NAT question is not of the same type as a MCQ question. Yet, both are questions. So, we see that there is a hierarchy of relationships here:\n\n\n\nHierarchy of question types\n\n\nParents always come first in the hierarchy. So, let us first define a class to represent a question:\nclass Question:\n    def __init__(self, statement, marks):\n        self.statement = statement\n        self.marks = marks\n    \n    def print_question(self):\n        print(self.statement)\n    \n    def update_marks(self, marks):\n        self.marks = marks\nNote that we have only retained those elements as attributes that are common to all questions, irrespective of the type:\n\nstatement of the question\nmarks for the question\n\nThe next step is to define two new classes for the children of Question, one for MCQ and the other for NAT. It is here that we make use of the relationship that we just diagrammed:\n```python linenums=“11” class NAT(Question): def init(self, statement, marks, answer): super().__init__(statement, marks) self.answer = answer\ndef update_answer(self, answer):\n    self.answer = answer\n\n`NAT` is also a `Question`, but a specialized question. Specifically, it has an additional feature, `answer`, and a new method, `update_answer`. But all the other attributes and methods of `Question` are inherited by it, since `NAT` is just another `Question`.\n\nWe say that `NAT` is derived from `Question`. `Question` becomes the parent-class or base-class , and `NAT` is a child-class or derived-class.\n\n![Relationship between Parent class and child class](../assets/images/img-58.png)\n\nIn Python, the syntax used to make this dependency explicit is as follows:\n\n```python\nclass Derived(Base):\n    def __init__(self, ...):\n        pass\n        \n#### OR ####\nclass Child(Parent):\n    def __init__(self, ...):\n        ...\nIn our specific example, we have:\nclass NAT(Question):\n    def __init__(self, ...):\n        pass"
  },
  {
    "objectID": "notes/chapter-8/lesson-8.3.html#parent-child-relationship",
    "href": "notes/chapter-8/lesson-8.3.html#parent-child-relationship",
    "title": "Lesson 8.3",
    "section": "",
    "text": "Note that something interesting happens within the constructor of the derived class:\n```python linenums=“11” hl_lines=“3” class NAT(Question): def init(self, statement, marks, answer): super().__init__(statement, marks) self.answer = answer\ndef update_answer(self, answer):\n    self.answer = answer\n\nThe `#!py super()` function points to the parent class, in this case `Question`. So, in line 13, we are effectively calling the constructor of the parent class. If we need to update the marks, we can just invoke the method `#!py update_marks()` that is inherited from `Question`:\n\n```python linenums=\"18\"\nq_nat = NAT('What is 1 + 1?', 1, 2)\nq_nat.update_marks(4)\nprint(q_nat.marks)\n???+ abstract “OUTPUT” 4"
  },
  {
    "objectID": "notes/chapter-8/lesson-8.3.html#method-overriding",
    "href": "notes/chapter-8/lesson-8.3.html#method-overriding",
    "title": "Lesson 8.3",
    "section": "",
    "text": "Let us now turn our attention to methods. Pasting the parent-class here for easy reference:\nclass Question:\n    def __init__(self, statement, marks):\n        self.statement = statement\n        self.marks = marks\n    \n    def print_question(self):\n        print(self.statement)\n    \n    def update_marks(self, marks):\n        self.marks = marks\nSometimes we may want to modify the behaviour of existing methods in the parent class. For example, take the case of a MCQ question. For questions of this type, the statement of a problem is incomplete without the options. The #!py print_question() method in the parent class just prints the statement, but it makes more sense to print the options as well for a MCQ question. So, we want the #!py print_question() to behave differently. Though we have inherited this method from the parent class, we can override the behaviour of the method in the following way:\n```python linenums=“11” class MCQ(Question): def init(self, statement, marks, ops, c_ops): super().__init__(statement, marks) self.ops = ops # list of all options self.c_ops = c_ops # list of correct options\ndef print_question(self):\n    super().print_question()\n    # Assume there are only four options\n    op_index = ['(a)', '(b)', '(c)', '(d)']\n    for i in range(4):\n        print(op_index[i], self.ops[i])\n\nNote that the parent class `Question` already prints the statement. So, we piggy-back on this behaviour using the `#!py super()` function in line-8. In addition, we also print the options. Let us create a `MCQ` question object and see how it all works:\n\n```python linenums=\"23\"\nq_mcq = MCQ('What is the capital of India?',\n           2,\n           ['Chennai', 'Mumbai', 'Kolkota', 'New Delhi'],\n           ['New Delhi'])\nq_mcq.print_question()\nThis returns the output:\n??? abstract “OUTPUT” What is the capital of India?     (a) Chennai     (b) Mumbai     (c) Kolkota     (d) New Delhi"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.4.html",
    "href": "notes/chapter-1/lesson-1.4.html",
    "title": "Lesson-1.4",
    "section": "",
    "text": "We have been using Replit’s console to type code so far. We will now move to the editor in Replit. The advantage of using the editor is that code typed here gets automatically saved. Think about it like Google Docs for code. The window to the left of the console is the editor. After typing code, click on the green Run button on the top. The output of the code will appear in the console on the right. We will completely shift to the editor from now. This means dropping the prompt symbol before each line of code.\n\n\nVideo\ntype:video\n\n\n\n\n\n\n\nEnter the following line of code in the editor and run it:\nprint('123)\nThis is the output that we get in the console:\n  File \"main.py\", line 1\n    print('123)\n              ^\nSyntaxError: EOL while scanning string literal\nLines 1-4 represent an error message. It is the interpreter’s way of warning us that there is something wrong with the code. Error messages usually come with some information about the errors which helps us understand what has gone wrong. In this case, we have a SyntaxError, i.e., something is wrong with the syntax. The remaining part of the message gives the details:\n\nEOL stands for End Of Line\nscanning a string literal\n\nThere was an issue with the end of line while scanning a string literal. The ^ sign points to the place where the error occurred. This acts as a visual aid while trying to trace the error. Going back to the code, the ending quote ' is missing. We can now fix it:\nprint('123')\n\n\n\nAmong software professionals, there is an alternative term used for errors in code: bugs. The process of fixing bugs is called debugging. The process usually works as follows:\n\nRun: run the code\nDetect: the interpreter intimates the coder of the error\nUnderstand: the coder has to understand the error message and go back to the code to see what went wrong\nUpdate: fix the error by modifying or updating one or more lines of the code\n\nNow, the coder closes the loop by running the code again. If the code throws another error, the whole process repeats.\n\nDebugging code forms an important part of programming. While working on huge codebases it might take several hours or even days to fix bugs.\n\n\n\nWe now move to a different set of errors. These are no longer syntax errors. Let us take an example:\n1 / 0\nThe output is:\nTraceback (most recent call last):\n  File \"main.py\", line 1, in &lt;module&gt;\n    1 / 0\nZeroDivisionError: division by zero\nThe error message is quite clear here. We are trying to divide by zero and the interpreter is rightly objecting to it. This is called a ZeroDivisionError. But in terms of syntax, there is no error here. Such errors that are detected by the interpreter during the program’s execution are called exceptions. We will keep returning to the idea of exceptions in every chapter. Let us look at another exception:\n1 + 'one'\nThe output is:\nTraceback (most recent call last):\n  File \"main.py\", line 1, in &lt;module&gt;\n    1 + 'one'\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\nThe interpreter throws a TypeError. The message accompanying the error is more suggestive: an integer and a string cannot be added, i.e., for the + operator, int and str cannot be the type of the two operands.\nThe next exception that we will frequently encounter is NameError.\nprint('There is no problem with this line')\nprint(x ** 2)\nThe output is:\nThere is no problem with this line\nTraceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    print(x ** 2)\nNameError: name 'x' is not defined\nNotice that the first line in the code gets printed correctly. The interpreter starts executing the code from top to bottom. The first line is error free. It is the second line which has a problem. NameError occurs when we try to reference a variable that has not been defined before. We will look at what referencing a variable means in the next chapter.\n\n\n\nWherever we wish to demonstrate examples of incorrect code, we will do it in the following manner:\n##### Alarm! Wrong code snippet! #####\n\n# Incorrect code will go here #\n\n##### Alarm! Wrong code snippet! #####"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.4.html#replit-editor",
    "href": "notes/chapter-1/lesson-1.4.html#replit-editor",
    "title": "Lesson-1.4",
    "section": "",
    "text": "We have been using Replit’s console to type code so far. We will now move to the editor in Replit. The advantage of using the editor is that code typed here gets automatically saved. Think about it like Google Docs for code. The window to the left of the console is the editor. After typing code, click on the green Run button on the top. The output of the code will appear in the console on the right. We will completely shift to the editor from now. This means dropping the prompt symbol before each line of code.\n\n\nVideo\ntype:video"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.4.html#errors",
    "href": "notes/chapter-1/lesson-1.4.html#errors",
    "title": "Lesson-1.4",
    "section": "",
    "text": "Enter the following line of code in the editor and run it:\nprint('123)\nThis is the output that we get in the console:\n  File \"main.py\", line 1\n    print('123)\n              ^\nSyntaxError: EOL while scanning string literal\nLines 1-4 represent an error message. It is the interpreter’s way of warning us that there is something wrong with the code. Error messages usually come with some information about the errors which helps us understand what has gone wrong. In this case, we have a SyntaxError, i.e., something is wrong with the syntax. The remaining part of the message gives the details:\n\nEOL stands for End Of Line\nscanning a string literal\n\nThere was an issue with the end of line while scanning a string literal. The ^ sign points to the place where the error occurred. This acts as a visual aid while trying to trace the error. Going back to the code, the ending quote ' is missing. We can now fix it:\nprint('123')\n\n\n\nAmong software professionals, there is an alternative term used for errors in code: bugs. The process of fixing bugs is called debugging. The process usually works as follows:\n\nRun: run the code\nDetect: the interpreter intimates the coder of the error\nUnderstand: the coder has to understand the error message and go back to the code to see what went wrong\nUpdate: fix the error by modifying or updating one or more lines of the code\n\nNow, the coder closes the loop by running the code again. If the code throws another error, the whole process repeats.\n\nDebugging code forms an important part of programming. While working on huge codebases it might take several hours or even days to fix bugs.\n\n\n\nWe now move to a different set of errors. These are no longer syntax errors. Let us take an example:\n1 / 0\nThe output is:\nTraceback (most recent call last):\n  File \"main.py\", line 1, in &lt;module&gt;\n    1 / 0\nZeroDivisionError: division by zero\nThe error message is quite clear here. We are trying to divide by zero and the interpreter is rightly objecting to it. This is called a ZeroDivisionError. But in terms of syntax, there is no error here. Such errors that are detected by the interpreter during the program’s execution are called exceptions. We will keep returning to the idea of exceptions in every chapter. Let us look at another exception:\n1 + 'one'\nThe output is:\nTraceback (most recent call last):\n  File \"main.py\", line 1, in &lt;module&gt;\n    1 + 'one'\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\nThe interpreter throws a TypeError. The message accompanying the error is more suggestive: an integer and a string cannot be added, i.e., for the + operator, int and str cannot be the type of the two operands.\nThe next exception that we will frequently encounter is NameError.\nprint('There is no problem with this line')\nprint(x ** 2)\nThe output is:\nThere is no problem with this line\nTraceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    print(x ** 2)\nNameError: name 'x' is not defined\nNotice that the first line in the code gets printed correctly. The interpreter starts executing the code from top to bottom. The first line is error free. It is the second line which has a problem. NameError occurs when we try to reference a variable that has not been defined before. We will look at what referencing a variable means in the next chapter.\n\n\n\nWherever we wish to demonstrate examples of incorrect code, we will do it in the following manner:\n##### Alarm! Wrong code snippet! #####\n\n# Incorrect code will go here #\n\n##### Alarm! Wrong code snippet! #####"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.3.html",
    "href": "notes/chapter-1/lesson-1.3.html",
    "title": "Lesson-1.3",
    "section": "",
    "text": "Let us start looking at arithmetic expressions that involve multiple operators:\n&gt;&gt;&gt; 4 // 2 - 1\n1\nWe can interpret this statement in two ways:\n\n(4 // 2) - 1 = 2 - 1 = 1\n4 // (2 - 1) = 4 // 1 = 4\n\nClearly, we see that the interpreter is following the first way. When an expression has different operators, the interpreter has to make a decision about the way the expression is to be parenthesized, i.e., which operator takes precedence over the others. From the above example, we see that the floor division operator (//) has greater precedence than the subtraction operator (-).\nIn general, the following table describes the precedence rules for operators. Those with higher precedence come at the top of the table. Operators in a given cell have the same precedence. For example, + and - have same precedence.\n\n\n\nArithmetic operator precedence table\n\n\nLet us take another example:\n&gt;&gt;&gt; 3 ** 2 * 4 - 4\n32\nGoing by the precedence rules, we apply the parenthesis in the following sequence:\n\n(3 ** 2) * 4 - 4\n((3 ** 2) * 4) - 4\n\nThis is evaluated as: ((3 ** 2) * 4) - 4 = (9 * 4) - 4 = 36 - 4 = 32\n\n\n\nConsider the following example:\n&gt;&gt;&gt; 3 - 2 + 1\n2\nWe can interpret this statement in two ways:\n\n(3 - 2) + 1 = 1 + 1 = 2\n3 - (2 + 1) = 3 - 3 = 0.\n\nThe interpreter is following the first way. Does this mean that subtraction has greater precedence than addition? No, we just saw that they have the same precedence! We have to be careful here. Python evaluates expressions from left to right. There are two exceptions to this rule, the ** and = operator, both of which are evaluated from right to left. We shall return to this in a while.\nNow for another example. Consider the following expression:\n&gt;&gt;&gt; 4 - 3 - 1\n0\nThe two ways of doing this are:\n\n(4 - 3) - 1 = 1 - 1 = 0\n4 - (3 - 1) = 4 - 2 = 2\n\nThe first way is the one followed by the interpreter. Going back to the evaluation order followed by Python, we see that this expression is evaluated from left to right.\nLet us take another example:\n&gt;&gt;&gt; 8 % 4 % 2\n0\nRun the following code in the interpreter. Which of the following parenthesizations matches the expression given above? This is left as an exercise for you to try out.\n&gt;&gt;&gt; (8 % 4) % 2\n&gt;&gt;&gt; 8 % (4 % 2)\nFinally, ** is a unique operator in this regard:\n&gt;&gt;&gt; 2 ** 3 ** 0\n2\nThe two ways of doing this are:\n\n(2 ** 3) ** 0\n2 ** (3 ** 0)\n\nThe interpreter is following the second way, i.e., the statement is being executed from right to left. This kind of execution happens only in the case of the exponentiation operator and the assignment operator."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.3.html#arithmetic-expressions",
    "href": "notes/chapter-1/lesson-1.3.html#arithmetic-expressions",
    "title": "Lesson-1.3",
    "section": "",
    "text": "Let us start looking at arithmetic expressions that involve multiple operators:\n&gt;&gt;&gt; 4 // 2 - 1\n1\nWe can interpret this statement in two ways:\n\n(4 // 2) - 1 = 2 - 1 = 1\n4 // (2 - 1) = 4 // 1 = 4\n\nClearly, we see that the interpreter is following the first way. When an expression has different operators, the interpreter has to make a decision about the way the expression is to be parenthesized, i.e., which operator takes precedence over the others. From the above example, we see that the floor division operator (//) has greater precedence than the subtraction operator (-).\nIn general, the following table describes the precedence rules for operators. Those with higher precedence come at the top of the table. Operators in a given cell have the same precedence. For example, + and - have same precedence.\n\n\n\nArithmetic operator precedence table\n\n\nLet us take another example:\n&gt;&gt;&gt; 3 ** 2 * 4 - 4\n32\nGoing by the precedence rules, we apply the parenthesis in the following sequence:\n\n(3 ** 2) * 4 - 4\n((3 ** 2) * 4) - 4\n\nThis is evaluated as: ((3 ** 2) * 4) - 4 = (9 * 4) - 4 = 36 - 4 = 32\n\n\n\nConsider the following example:\n&gt;&gt;&gt; 3 - 2 + 1\n2\nWe can interpret this statement in two ways:\n\n(3 - 2) + 1 = 1 + 1 = 2\n3 - (2 + 1) = 3 - 3 = 0.\n\nThe interpreter is following the first way. Does this mean that subtraction has greater precedence than addition? No, we just saw that they have the same precedence! We have to be careful here. Python evaluates expressions from left to right. There are two exceptions to this rule, the ** and = operator, both of which are evaluated from right to left. We shall return to this in a while.\nNow for another example. Consider the following expression:\n&gt;&gt;&gt; 4 - 3 - 1\n0\nThe two ways of doing this are:\n\n(4 - 3) - 1 = 1 - 1 = 0\n4 - (3 - 1) = 4 - 2 = 2\n\nThe first way is the one followed by the interpreter. Going back to the evaluation order followed by Python, we see that this expression is evaluated from left to right.\nLet us take another example:\n&gt;&gt;&gt; 8 % 4 % 2\n0\nRun the following code in the interpreter. Which of the following parenthesizations matches the expression given above? This is left as an exercise for you to try out.\n&gt;&gt;&gt; (8 % 4) % 2\n&gt;&gt;&gt; 8 % (4 % 2)\nFinally, ** is a unique operator in this regard:\n&gt;&gt;&gt; 2 ** 3 ** 0\n2\nThe two ways of doing this are:\n\n(2 ** 3) ** 0\n2 ** (3 ** 0)\n\nThe interpreter is following the second way, i.e., the statement is being executed from right to left. This kind of execution happens only in the case of the exponentiation operator and the assignment operator."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.3.html#boolean-expressions",
    "href": "notes/chapter-1/lesson-1.3.html#boolean-expressions",
    "title": "Lesson-1.3",
    "section": "Boolean expressions",
    "text": "Boolean expressions\nThe simplest example of an expression that results in a boolean value is given below:\n&gt;&gt;&gt; 1 &gt; 0\nTrue\n&gt;&gt;&gt; type(1 &gt; 0)\n&lt;class 'bool'&gt;\nThe following expression conveys the fact that 3.14 lies between 3 and 4:\n&gt;&gt;&gt; 3 &lt; 3.14 and 4 &gt; 3.14\nTrue\nThis can also be written in the following manner:\n&gt;&gt;&gt; 3 &lt; 3.14 &lt; 4\nTrue\nLet us add some boolean literals into the mix:\n&gt;&gt;&gt; 10 &gt; 20 or True\nTrue\nAs an exercise, try the following:\n&gt;&gt;&gt; False or False or False or False or True\n\nPrecedence and Order\nSimilar to arithmetic operators, logical operators also have precedence. Boolean expressions are also going to evaluated from left to right:\n\n\n\nLogical Operator precedence\n\n\nTo see this rule in action, consider the following example:\n&gt;&gt;&gt; not True and False\nFalse\nThere are two different parenthesizations:\n\nnot(True) and False = False and False = False\nnot(True and False) = not(False) = True\n\nClearly, the interpreter is following the first parenthesization. This is in accordance with the precedence rule for logical operators. The evaluation order is from left to right. But we will return to this in more detail in the section on short circuit evaluation. Another example, this time with and and or:\n&gt;&gt;&gt; True or False and False\nTrue\nThere are two different parenthesizations:\n\n(True or False) and False = True and False = False\nTrue or (False and False) = True or False = True\n\nAccording to the precedence rules, and has greater precedence than or. So, the second way is the one followed by Python.\n\n\nBeware of float!\nExecute the following expression in the interpreter:\n&gt;&gt;&gt; 10.00000000000000000000001 &gt; 10\nFalse\nThis seems surprising! 10.00000000000000000000001 &gt; 10 is a perfectly valid mathematical statement that evaluates to True. The reason this returns False in Python has to do with the way floating point numbers are represented. Python, and programming languages in general, do not support arbitrary precision for representing real numbers. When the number cannot be represented exactly, an approximate value is returned. As a result of this behaviour, we should be careful when using float values in expressions that involve comparisons. Another example:\n&gt;&gt;&gt; 0.1 ** 100 == 0.0\nFalse\n&gt;&gt;&gt; 0.1 ** 1000 == 0.0\nTrue\nThe above expression presents a typical case of approximation when dealing with float. The number 0.1 ** 1000 is extremely small. So, the interpreter is going to represent that as 0. One more example follows:\n&gt;&gt;&gt; 0.1 * 3 == 0.3\nFalse\nLet us see what is happening here by starting with the expression to the left of the == operator:\n&gt;&gt;&gt; 0.1 * 3\n0.30000000000000004\nNote: The following explanation can be skipped.\nThe problem is with the way 0.1 is represented in binary - it has a non-terminating, recurring sequence of bits after the decimal point. As the computer uses a finite number of bits to represent data, this sequence will be truncated at some stage. This results in an approximate representation of 0.1. For a more detailed explanation, refer to this resource.\n\n\nShort Circuit Evaluation\nNow, we come to an important feature in Python. Execute the following expression in the interpreter:\n&gt;&gt;&gt; 1 / 0\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nZeroDivisionError: division by zero\nDivision by zero is not allowed, and the interpreter promptly hits back with an error message. This is not surprising. But what is surprising is the following statement:\n&gt;&gt;&gt; True or (1 / 0)\nTrue\nNo error message! How do we explain this behaviour?\nThe expression is evaluated from left to right. The operator is or. Since the operand on the left is True, the whole expression will evaluate to True irrespective of the operand on the right. So, the interpreter skips evaluating the operand on the right. This behaviour is called short circuit evaluation.\nConsider a more complex example:\n&gt;&gt;&gt; (not((3 &gt; 2) or (5 / 0))) and (10 / 0)\nFalse\nLet us break this down using the diagram given below. The arrows on the left give us an idea of the expression that has to be evaluated first. If we keep following the arrows, the last expression in this image on the bottom-left is the first to be evaluated. By following the arrows on the right, we can see that the two offending expressions - 5 / 0 and 10 / 0 - are never evaluated.\n\n\n\nShort circuiting flow chart"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.6.html",
    "href": "notes/chapter-1/lesson-1.6.html",
    "title": "Lesson-1.6",
    "section": "",
    "text": "We looked at string operations in the previous lesson. A quick recap of what we have seen so far:\n\nLength of a string using the len function\nConcatenation of two strings using the + operator\nReplication of strings using the * operator\nString comparison using relational operators such as &gt;, &lt;, ==\nUse of in keyword\n\nIn this lesson, we will explore the sequential nature of strings. This will also serve as an introduction to lists in Python. In addition, we will also look at string methods.\n\n\nA string is a sequence of characters. Sequences support indexing. What do we mean by that? Consider the following image:\n\n\n\nIndexing\n\n\nGiven a word such as “world”, we say that ‘w’ is the first letter in the word, ‘o’ is the second letter and so on. What we are referring to is the position of the letter in the word. The “index” is just a formal way of denoting the position of an element in the sequence. In computer science, starting the index from 0 is a widespread convention. This is called zero-based numbering.\nOnce this is defined, we can go ahead and access characters that are at a given position in a string:\nword = 'world'\nprint(word[0])\nprint(word[1])\nprint(word[2])\nprint(word[3])\nprint(word[4])\nThis will give the output:\nw\no\nr\nl\nd\nGiven a variable, say word, that holds a string literal, word[i] gives the character at index i in the string. Informally, this would be the letter at position i + 1 in the string. Now, let us turn to the following code:\nword = 'world'\nprint(word[5])\nThis gives the following output:\nTraceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    print(word[5])\nIndexError: string index out of range\nThe interpreter throws an IndexError as we are trying to access an index that is out of range. The length of the string is 5. Since we start the index from 0, the last character will be at index 4. Anything greater than that is going to throw an error. Now, let us turn to the other end of the spectrum:\nword = 'world'\nprint(word[-1])\nSurprisingly, there is no error and the output is:\nd\nPython supports negative indexing. This can be best understood using the following image:\n\n\n\n\nNegative indexing\n\n\n\nThink about it as follows. You keep moving down a flight of stairs starting from the top most step. When you reach the last step, you think that you cannot go down any further. At that moment, some invisible hand magically transports you back to the top most step and you begin your descent all over again. A good image that captures this analogy is the Penrose stairs:\n\n\n\npenrose stairs\n\n\nImage credit: Wikipedia\nAn index of -1 points to the last element in the sequence. From this, we keep moving backwards until we reach the first element in the sequence which is at index -5.\nword = 'world'\nprint(word[-1])\n# ... please add the remaining lines!\nprint(word[-5])\nUnlike the Penrose stairs, we cannot keep repeating this forever. print(word[-6]) will throw an IndexError.\n\n\n\nSlicing is a way of extracting a substring from a string using the slice() function.\nAssume that you have a collection of email ids of students in IIT-M. Let us say all email ids are of this form:\n\nbranch_year_number@iitm.ac.in\n\nEach branch is given a two-letter code. For example, CS stands for Computer Science and ME stands for Mechanical Engineering. The year is some two digit number that represents the year of joining. For example, it would be 11 if the year of joining is 2011. Finally, number is a three digit roll number. Some sample email ids are as follows:\nCS_10_014@iitm.ac.in\nME_11_123@iitm.ac.in\nBT_17_001@iitm.ac.in\nGiven a string, we would like to extract the roll number of the student from it. How do we do this? Python provides a way to extract this information using the concept of slicing:\n\n\n\nslicing\n\n\nemail = 'CS_10_014@iitm.ac.in'\nroll = email[6 : 9]\nprint(roll)\nThe slicing operator - start:stop - will be our knife in slicing sequences! Let us see how it works. The substring that we want to extract is 014. In terms of indices, this will be 6, 7, 8 in the string email. So, we start slicing at the index 6 and stop before the index 9. In general, email[start : stop] will be the substring starting at index start and stopping before the index stop, i.e., the character at the index stop will be excluded from the substring.\nFew more examples using the same string:\nemail = 'CS_10_014@iitm.ac.in'\nbranch = email[0 : 2]\nyear = email[3 : 5]\nroll = email[6 : 9]\ncollege = email[10 : 14]\n# Print each one of them and check the output\nSlicing is quite powerful. If we want the institute roll number, including the branch, we could do the following:\nemail = 'CS_10_014@iitm.ac.in'\nin_roll = email[ : 9]\nprint(in_roll)\nThis outputs CS_10_014. If no starting index is specified in the slice, then start will default to 0. Likewise, if no stopping index is specified, stop will default to the end of the string or len(email). Now, consider:\nemail = 'CS_10_014@iitm.ac.in'\ndomain = email[-10 : ]\nprint(domain)\nThis outputs iitm.ac.in. Think for a while about the output. It is just a combination of negative indexing and slicing. Use the following visual to get a better understanding of slicing:\n\n\n\nslicing with negative indices\n\n\nUsing the above visual, we can now very easily process the following slices:\nword = 'world'\nprint(word[-4 : 3])\nprint(word[1 : -2])\n\n\n\nExecute the following code and observe the output:\nword = 'some string'\nword[0] = 'S'\nThe interpreter throws a TypeError with the following error message: 'str' object does not support item assignment. We say that something is “mutable” if it can be changed, modified. Therefore, an object is immutable if it cannot be changed or modified. Strings are immutable. One or more characters in the string literal present in word cannot be modified in-place.\nNote that this is different from the following:\nword = 'some string'\nword = 'Some string'\nHere, we are not modifying the variable word in-place. Instead, we are assigning it an entirely new string literal in line-2. Thus there are two different string literals - 'some string' and 'Some string' - and the former has NOT been transformed into the latter.\n\n\n\nModifying variable word\n\n\nThe number on the arrow represents the line number in the code. word binds to the string on top after line-1. word binds to the string on the bottom after line-2. Note that there are two different strings here; one doesn’t transform into the other. The concept of mutable and immutable objects will be explored in considerable detail in chapter-5.\n\n\n\nConsider the following problem:\n!!! question ” ” Accept a sentence as input from the user and output the same sentence with the first letter in the sentence capitalized.\nFor example, if the input is 'this is a chair.', the output should be 'This is a chair.'.\nSolution\nsentence = input()\ncap_sentence = sentence.capitalize()\nprint(cap_sentence)\ncapitalize is called a method. Methods are essentially functions, but they are defined for specific objects. So, they have to be called by using the object for which they have been defined. In the case of capitalize, it is a method that is defined for the str data type. If we try to call it using an int object, we will get an error:\n##### Alarm! Wrong code snippet!\na = 1\na.capitalize()\n##### Alarm! Wrong code snippet!\nGetting back to the previous code snippet, sentence.capitalize() returns a string, which is then assigned to a new variable called cap_sentence. There are plenty of other methods associated with strings. Let us look at one more method which features in the solution to this interesting problem:\n!!! question ” ” Check whether a given string is a valid name of a person.\nIt is safe to assume that we are not thinking about Elon Musk’s son, in which case, a name usually has only alphabets without any special characters and numbers. The method isalpha checks for just this requirement:\n# name is some pre-defined string\nvalid = name.isalpha()\nprint(valid)\nname.isalpha() returns a boolean value. If every character in the string is an alphabet and the string is non-empty, it returns True, and False otherwise. A comprehensive list of string methods can be found here."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.6.html#strings",
    "href": "notes/chapter-1/lesson-1.6.html#strings",
    "title": "Lesson-1.6",
    "section": "",
    "text": "We looked at string operations in the previous lesson. A quick recap of what we have seen so far:\n\nLength of a string using the len function\nConcatenation of two strings using the + operator\nReplication of strings using the * operator\nString comparison using relational operators such as &gt;, &lt;, ==\nUse of in keyword\n\nIn this lesson, we will explore the sequential nature of strings. This will also serve as an introduction to lists in Python. In addition, we will also look at string methods.\n\n\nA string is a sequence of characters. Sequences support indexing. What do we mean by that? Consider the following image:\n\n\n\nIndexing\n\n\nGiven a word such as “world”, we say that ‘w’ is the first letter in the word, ‘o’ is the second letter and so on. What we are referring to is the position of the letter in the word. The “index” is just a formal way of denoting the position of an element in the sequence. In computer science, starting the index from 0 is a widespread convention. This is called zero-based numbering.\nOnce this is defined, we can go ahead and access characters that are at a given position in a string:\nword = 'world'\nprint(word[0])\nprint(word[1])\nprint(word[2])\nprint(word[3])\nprint(word[4])\nThis will give the output:\nw\no\nr\nl\nd\nGiven a variable, say word, that holds a string literal, word[i] gives the character at index i in the string. Informally, this would be the letter at position i + 1 in the string. Now, let us turn to the following code:\nword = 'world'\nprint(word[5])\nThis gives the following output:\nTraceback (most recent call last):\n  File \"main.py\", line 2, in &lt;module&gt;\n    print(word[5])\nIndexError: string index out of range\nThe interpreter throws an IndexError as we are trying to access an index that is out of range. The length of the string is 5. Since we start the index from 0, the last character will be at index 4. Anything greater than that is going to throw an error. Now, let us turn to the other end of the spectrum:\nword = 'world'\nprint(word[-1])\nSurprisingly, there is no error and the output is:\nd\nPython supports negative indexing. This can be best understood using the following image:\n\n\n\n\nNegative indexing\n\n\n\nThink about it as follows. You keep moving down a flight of stairs starting from the top most step. When you reach the last step, you think that you cannot go down any further. At that moment, some invisible hand magically transports you back to the top most step and you begin your descent all over again. A good image that captures this analogy is the Penrose stairs:\n\n\n\npenrose stairs\n\n\nImage credit: Wikipedia\nAn index of -1 points to the last element in the sequence. From this, we keep moving backwards until we reach the first element in the sequence which is at index -5.\nword = 'world'\nprint(word[-1])\n# ... please add the remaining lines!\nprint(word[-5])\nUnlike the Penrose stairs, we cannot keep repeating this forever. print(word[-6]) will throw an IndexError.\n\n\n\nSlicing is a way of extracting a substring from a string using the slice() function.\nAssume that you have a collection of email ids of students in IIT-M. Let us say all email ids are of this form:\n\nbranch_year_number@iitm.ac.in\n\nEach branch is given a two-letter code. For example, CS stands for Computer Science and ME stands for Mechanical Engineering. The year is some two digit number that represents the year of joining. For example, it would be 11 if the year of joining is 2011. Finally, number is a three digit roll number. Some sample email ids are as follows:\nCS_10_014@iitm.ac.in\nME_11_123@iitm.ac.in\nBT_17_001@iitm.ac.in\nGiven a string, we would like to extract the roll number of the student from it. How do we do this? Python provides a way to extract this information using the concept of slicing:\n\n\n\nslicing\n\n\nemail = 'CS_10_014@iitm.ac.in'\nroll = email[6 : 9]\nprint(roll)\nThe slicing operator - start:stop - will be our knife in slicing sequences! Let us see how it works. The substring that we want to extract is 014. In terms of indices, this will be 6, 7, 8 in the string email. So, we start slicing at the index 6 and stop before the index 9. In general, email[start : stop] will be the substring starting at index start and stopping before the index stop, i.e., the character at the index stop will be excluded from the substring.\nFew more examples using the same string:\nemail = 'CS_10_014@iitm.ac.in'\nbranch = email[0 : 2]\nyear = email[3 : 5]\nroll = email[6 : 9]\ncollege = email[10 : 14]\n# Print each one of them and check the output\nSlicing is quite powerful. If we want the institute roll number, including the branch, we could do the following:\nemail = 'CS_10_014@iitm.ac.in'\nin_roll = email[ : 9]\nprint(in_roll)\nThis outputs CS_10_014. If no starting index is specified in the slice, then start will default to 0. Likewise, if no stopping index is specified, stop will default to the end of the string or len(email). Now, consider:\nemail = 'CS_10_014@iitm.ac.in'\ndomain = email[-10 : ]\nprint(domain)\nThis outputs iitm.ac.in. Think for a while about the output. It is just a combination of negative indexing and slicing. Use the following visual to get a better understanding of slicing:\n\n\n\nslicing with negative indices\n\n\nUsing the above visual, we can now very easily process the following slices:\nword = 'world'\nprint(word[-4 : 3])\nprint(word[1 : -2])\n\n\n\nExecute the following code and observe the output:\nword = 'some string'\nword[0] = 'S'\nThe interpreter throws a TypeError with the following error message: 'str' object does not support item assignment. We say that something is “mutable” if it can be changed, modified. Therefore, an object is immutable if it cannot be changed or modified. Strings are immutable. One or more characters in the string literal present in word cannot be modified in-place.\nNote that this is different from the following:\nword = 'some string'\nword = 'Some string'\nHere, we are not modifying the variable word in-place. Instead, we are assigning it an entirely new string literal in line-2. Thus there are two different string literals - 'some string' and 'Some string' - and the former has NOT been transformed into the latter.\n\n\n\nModifying variable word\n\n\nThe number on the arrow represents the line number in the code. word binds to the string on top after line-1. word binds to the string on the bottom after line-2. Note that there are two different strings here; one doesn’t transform into the other. The concept of mutable and immutable objects will be explored in considerable detail in chapter-5.\n\n\n\nConsider the following problem:\n!!! question ” ” Accept a sentence as input from the user and output the same sentence with the first letter in the sentence capitalized.\nFor example, if the input is 'this is a chair.', the output should be 'This is a chair.'.\nSolution\nsentence = input()\ncap_sentence = sentence.capitalize()\nprint(cap_sentence)\ncapitalize is called a method. Methods are essentially functions, but they are defined for specific objects. So, they have to be called by using the object for which they have been defined. In the case of capitalize, it is a method that is defined for the str data type. If we try to call it using an int object, we will get an error:\n##### Alarm! Wrong code snippet!\na = 1\na.capitalize()\n##### Alarm! Wrong code snippet!\nGetting back to the previous code snippet, sentence.capitalize() returns a string, which is then assigned to a new variable called cap_sentence. There are plenty of other methods associated with strings. Let us look at one more method which features in the solution to this interesting problem:\n!!! question ” ” Check whether a given string is a valid name of a person.\nIt is safe to assume that we are not thinking about Elon Musk’s son, in which case, a name usually has only alphabets without any special characters and numbers. The method isalpha checks for just this requirement:\n# name is some pre-defined string\nvalid = name.isalpha()\nprint(valid)\nname.isalpha() returns a boolean value. If every character in the string is an alphabet and the string is non-empty, it returns True, and False otherwise. A comprehensive list of string methods can be found here."
  },
  {
    "objectID": "notes/extras/resources.html",
    "href": "notes/extras/resources.html",
    "title": "Resources",
    "section": "",
    "text": "Resources\nThis section provides additional resources in the form of articles and blogs that are scattered around the web:\n\nDropbox | Dynamic typing\nPython’s Functions are First-Class\nMemory address of a Function\nUnderstanding slicing\nMigration to Python 3"
  },
  {
    "objectID": "notes/chapter-2/lesson-2.1.html",
    "href": "notes/chapter-2/lesson-2.1.html",
    "title": "Lesson-2.1",
    "section": "",
    "text": "Variables are containers that are used to store values. Variables in Python are defined by using the assignment operator =. For example:\nx = 1\ny = 100.\nz = \"good\"\nVariables can also be updated using the assignment operator:\nx = 1\nprint('The initial value of x is', x)\nx = 2\nprint('The value after updating x is', x)\nThe output is:\nThe initial value of x is 1\nThe value after updating x is 2\n\n\n\nThe syntax of the assignment statement is as follows:\nvariable_name = expression\nThe assignment operator works from right to left. That is, the expression on the right is evaluated first. The value of this expression is assigned to the variable on the left. For example:\nx = 1 + 2 * 3 / 2\nprint(x)\nThe output is:\n4.0\nHaving a literal to the left of the assignment operator will result in an error:\n##### Alarm! Wrong code snippet! #####\n3 = x\n##### Alarm! Wrong code snippet! #####\nThis will throw the following error:\nSyntaxError: cannot assign to literal\nThe assignment statement maps or binds the variable name on the left to an object on the right. A closer look at the anatomy of an assignment statement:\n\n\nThe numbers on the arrow correspond to the line numbers in the code. The variables on the left side of the arrow bind to the objects on the right side after the corresponding line is executed. For example, the variable x binds to the object 8 - in this case an #!python int literal - after line 1 is executed. Note the period at the end of line 2 which makes 10 a #!py float. After the execution of line 2, 18.0 gets stored in x. The interesting part is line 3. Note that y = x makes both x and y bind to the same object. When x is updated in line-4, it binds to a new object. However, the value of y is not disturbed by this operation. It continues to be bound to the object 18.0 even after line-4 is executed.\nAs a final point, the assignment operator should not be confused with the equality operator:\nx = 2   # this is the assignment operator\nx == 2  # this is the equality operator\nThe assignment operator is used for creating or updating variables whereas the equality operator is used when two expressions need to be compared. They cannot be used interchangeably!\n!!! info “Dynamic Typing” Python supports what is called dynamic typing. In a dynamically typed language, a variable is simply a value bound to a name; the value has a type — like int or str — but the variable itself doesn’t 1. For example:\na = 1\nprint(type(a))\na = 1 / 2\nprint(type(a))\na = \"IIT Madras\"\nprint(type(a))\nThe output is:\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\nIn the above example, a was initially bound to a value of type #!py int. After its update in line 3, it was bound to a value of type #!py float and after line 5, it becomes a #!py str. The image in the previous section will give a clearer picture of why this is the case.\n\n\n\nWhen a variable that has already been defined is used in an expression, we say that the variable is being referenced. For example:\nx = 2\nprint(x * x, 'is the square of', x)\nIn line-2, we are referencing the variable x which was assigned a value in line-1. If a variable is referenced before it has been assigned a value, the interpreter throws an exception called NameError:\nprint(someVar)\nThis is the output:\nNameError: name 'someVar' is not defined\n\n\n\nKeywords are certain words in the Python language that have a special meaning. Some of them are listed below:\nnot, and, or, if, for, while, in, is, def, class\nWe have already seen some of them - not, and, or. We will come across all these keywords in upcoming chapters. Keywords cannot be used as names for variables. For example, the following line of code will throw a SyntaxError when executed:\n##### Alarm! Wrong code snippet! #####\nand = 2\n##### Alarm! Wrong code snippet! #####\nAlong with this restriction, there are certain other rules which have to be followed while choosing the names of variables in Python 2:\n\nA variable name can only contain alpha-numeric (alphabets and numbers) characters and underscores:\n\na - z\nA - Z\n0 - 9\n_\n\nA variable name must start with a letter or the underscore character.\n\nA few observations that directly follow from the above rules:\n\nA variable name cannot start with a number.\nVariable names are case-sensitive (age, Age and AGE are three different variables).\n\nNote that these are not merely conventions. Violating any one of these rules will result in a SyntaxError. As an example, the following code will throw a SyntaxError when executed:\n##### Alarm! Wrong code snippet! #####\n3a = 1\n##### Alarm! Wrong code snippet! #####\nSyntaxError: invalid decimal literal\n\n\n\nVariables can be used in computing the value of other variables. This is something that will routinely come up in programming and data science. Consider the following sequence of mathematical equations. We wish to evaluate the value of z at x = 10: \\[\ny=x^2\n\\] \\[\nz=(x+1)(y+1)\n\\] This can be computed as follows:\nx = 10\ny = x ** 2\nz = (x + 1) * (y + 1)\n\n\n\n\nConsider the following statement that defines two variables x and y.\nx = 1\ny = 2\nPython allows a compact way of writing this assignment on the same line. The following code assigns 1 to the variable x and 2 to the variable y:\nx, y = 1, 2\nNote that the order matters. The following code assigns 2 to the variable x and 1 to the variable y:\nx, y = 2, 1\nTo understand how this works, we need to get into the concept of packing and unpacking tuples, which we will visit in chapter 5. Treat this as a useful feature for the time being. Another way of doing multiple assignments is to initialize multiple variables with the same value:\nx = y = z = 10\nprint(x, y, z)\nThe output is:\n10 10 10\nThough x, y and z start off by being equal, the equality is broken the moment even one of the three variables is updated:\nx = x * 1\ny = y * 2\nz = z * 3\nprint(x, y, z)\nThe output is:\n10 20 30\n\n\n\nExecute the code given below and observe the output. What do you think is happening?\nx = 1\nx += 1\nprint(x)\n+= is something that we haven’t seen before.\n\nx += a\nIncrements the value of x by a. In other words, add a to x and store the result in x. It is equivalent to the statement x = x + a.\n\nThis is not just limited to the addition operator. The following table gives a summary of the shortcuts for some of the arithmetic operators:\n\n\n\n\nShortcut\nMeaning\n\n\n\n\nx += a\nx = x + a\n\n\nx -= a\nx = x - a\n\n\nx *= a\nx = x * a\n\n\nx /= a\nx = x / a\n\n\nx %= a\nx = x % a\n\n\nx **= a\nx = x ** a\n\n\n\n\nNote that the arithmetic operator must always come before the assignment operator in a shortcut. Swapping them will not work:\nx = 1\nx =+ 1\nprint(x)\nThis will give 1 as the output. This is because + is treated as the unary operator here. Statements like x =* 1 or x =/ 2 will result in errors!\n\n\n\nVariables can be deleted by using the del keyword:\nx = 100\nprint('x is a variable whose value is', x)\nprint('we are now going to delete x')\ndel x\nprint(x)\nWhen this code is executed, line 5 throws a NameError. This is because x was deleted in line 4 and we are trying to access a variable that is no longer defined at line 5."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.1.html#variables",
    "href": "notes/chapter-2/lesson-2.1.html#variables",
    "title": "Lesson-2.1",
    "section": "",
    "text": "Variables are containers that are used to store values. Variables in Python are defined by using the assignment operator =. For example:\nx = 1\ny = 100.\nz = \"good\"\nVariables can also be updated using the assignment operator:\nx = 1\nprint('The initial value of x is', x)\nx = 2\nprint('The value after updating x is', x)\nThe output is:\nThe initial value of x is 1\nThe value after updating x is 2\n\n\n\nThe syntax of the assignment statement is as follows:\nvariable_name = expression\nThe assignment operator works from right to left. That is, the expression on the right is evaluated first. The value of this expression is assigned to the variable on the left. For example:\nx = 1 + 2 * 3 / 2\nprint(x)\nThe output is:\n4.0\nHaving a literal to the left of the assignment operator will result in an error:\n##### Alarm! Wrong code snippet! #####\n3 = x\n##### Alarm! Wrong code snippet! #####\nThis will throw the following error:\nSyntaxError: cannot assign to literal\nThe assignment statement maps or binds the variable name on the left to an object on the right. A closer look at the anatomy of an assignment statement:\n\n\nThe numbers on the arrow correspond to the line numbers in the code. The variables on the left side of the arrow bind to the objects on the right side after the corresponding line is executed. For example, the variable x binds to the object 8 - in this case an #!python int literal - after line 1 is executed. Note the period at the end of line 2 which makes 10 a #!py float. After the execution of line 2, 18.0 gets stored in x. The interesting part is line 3. Note that y = x makes both x and y bind to the same object. When x is updated in line-4, it binds to a new object. However, the value of y is not disturbed by this operation. It continues to be bound to the object 18.0 even after line-4 is executed.\nAs a final point, the assignment operator should not be confused with the equality operator:\nx = 2   # this is the assignment operator\nx == 2  # this is the equality operator\nThe assignment operator is used for creating or updating variables whereas the equality operator is used when two expressions need to be compared. They cannot be used interchangeably!\n!!! info “Dynamic Typing” Python supports what is called dynamic typing. In a dynamically typed language, a variable is simply a value bound to a name; the value has a type — like int or str — but the variable itself doesn’t 1. For example:\na = 1\nprint(type(a))\na = 1 / 2\nprint(type(a))\na = \"IIT Madras\"\nprint(type(a))\nThe output is:\n&lt;class 'int'&gt;\n&lt;class 'float'&gt;\n&lt;class 'str'&gt;\nIn the above example, a was initially bound to a value of type #!py int. After its update in line 3, it was bound to a value of type #!py float and after line 5, it becomes a #!py str. The image in the previous section will give a clearer picture of why this is the case.\n\n\n\nWhen a variable that has already been defined is used in an expression, we say that the variable is being referenced. For example:\nx = 2\nprint(x * x, 'is the square of', x)\nIn line-2, we are referencing the variable x which was assigned a value in line-1. If a variable is referenced before it has been assigned a value, the interpreter throws an exception called NameError:\nprint(someVar)\nThis is the output:\nNameError: name 'someVar' is not defined\n\n\n\nKeywords are certain words in the Python language that have a special meaning. Some of them are listed below:\nnot, and, or, if, for, while, in, is, def, class\nWe have already seen some of them - not, and, or. We will come across all these keywords in upcoming chapters. Keywords cannot be used as names for variables. For example, the following line of code will throw a SyntaxError when executed:\n##### Alarm! Wrong code snippet! #####\nand = 2\n##### Alarm! Wrong code snippet! #####\nAlong with this restriction, there are certain other rules which have to be followed while choosing the names of variables in Python 2:\n\nA variable name can only contain alpha-numeric (alphabets and numbers) characters and underscores:\n\na - z\nA - Z\n0 - 9\n_\n\nA variable name must start with a letter or the underscore character.\n\nA few observations that directly follow from the above rules:\n\nA variable name cannot start with a number.\nVariable names are case-sensitive (age, Age and AGE are three different variables).\n\nNote that these are not merely conventions. Violating any one of these rules will result in a SyntaxError. As an example, the following code will throw a SyntaxError when executed:\n##### Alarm! Wrong code snippet! #####\n3a = 1\n##### Alarm! Wrong code snippet! #####\nSyntaxError: invalid decimal literal\n\n\n\nVariables can be used in computing the value of other variables. This is something that will routinely come up in programming and data science. Consider the following sequence of mathematical equations. We wish to evaluate the value of z at x = 10: \\[\ny=x^2\n\\] \\[\nz=(x+1)(y+1)\n\\] This can be computed as follows:\nx = 10\ny = x ** 2\nz = (x + 1) * (y + 1)\n\n\n\n\nConsider the following statement that defines two variables x and y.\nx = 1\ny = 2\nPython allows a compact way of writing this assignment on the same line. The following code assigns 1 to the variable x and 2 to the variable y:\nx, y = 1, 2\nNote that the order matters. The following code assigns 2 to the variable x and 1 to the variable y:\nx, y = 2, 1\nTo understand how this works, we need to get into the concept of packing and unpacking tuples, which we will visit in chapter 5. Treat this as a useful feature for the time being. Another way of doing multiple assignments is to initialize multiple variables with the same value:\nx = y = z = 10\nprint(x, y, z)\nThe output is:\n10 10 10\nThough x, y and z start off by being equal, the equality is broken the moment even one of the three variables is updated:\nx = x * 1\ny = y * 2\nz = z * 3\nprint(x, y, z)\nThe output is:\n10 20 30\n\n\n\nExecute the code given below and observe the output. What do you think is happening?\nx = 1\nx += 1\nprint(x)\n+= is something that we haven’t seen before.\n\nx += a\nIncrements the value of x by a. In other words, add a to x and store the result in x. It is equivalent to the statement x = x + a.\n\nThis is not just limited to the addition operator. The following table gives a summary of the shortcuts for some of the arithmetic operators:\n\n\n\n\nShortcut\nMeaning\n\n\n\n\nx += a\nx = x + a\n\n\nx -= a\nx = x - a\n\n\nx *= a\nx = x * a\n\n\nx /= a\nx = x / a\n\n\nx %= a\nx = x % a\n\n\nx **= a\nx = x ** a\n\n\n\n\nNote that the arithmetic operator must always come before the assignment operator in a shortcut. Swapping them will not work:\nx = 1\nx =+ 1\nprint(x)\nThis will give 1 as the output. This is because + is treated as the unary operator here. Statements like x =* 1 or x =/ 2 will result in errors!\n\n\n\nVariables can be deleted by using the del keyword:\nx = 100\nprint('x is a variable whose value is', x)\nprint('we are now going to delete x')\ndel x\nprint(x)\nWhen this code is executed, line 5 throws a NameError. This is because x was deleted in line 4 and we are trying to access a variable that is no longer defined at line 5."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.1.html#footnotes",
    "href": "notes/chapter-2/lesson-2.1.html#footnotes",
    "title": "Lesson-2.1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nInterestingly Python is both a dynamically typed and strongly typed language, head to this wiki page if you’d like to learn more about this.↩︎\nFor more examples of legal and illegal variable names in python click here.↩︎"
  },
  {
    "objectID": "notes/chapter-2/lesson-2.2.html",
    "href": "notes/chapter-2/lesson-2.2.html",
    "title": "Lesson-2.2",
    "section": "",
    "text": "Accepting input from the user routinely happens in programming. Any piece of software shipped to a customer needs to have a functional interface that will let the user interact with the software. We all have used apps like Facebook, Instagram and Twitter. These apps regularly accept input from the user, though we seldom look at it from a programming perspective. Take the case of commenting on a post in Facebook. The text entered in the comment box is the input. The code running in the backend processes this input and then displays it as a comment in a visually appealing form.\nPython provides a built-in function called #!py input() to accept input from the user. This is a simple yet powerful function:\nx = input()\nprint('The input entered by the user is', x)\nExecute the code given above and head to the console. Here the interpreter waits patiently for you to enter text. Press ++enter++ after entering the input. This acts as a cue for the interpreter to understand that you have completed entering your input. This text is stored in the variable x. The way it looks in the console is as follows:\n1\nThe input entered by the user is 1\nSometimes we may want to prompt the user to enter a particular type of input. This can be done by passing the instruction as an argument to the input function:\nx = input('Enter an integer between 0 and 10: ')\nprint('The number entered by the user is', x)\nLet us now look at the type of the variable x:\nx = input()\nprint('The input entered by the user is of type', type(x))\nExecute the above code with the following input types: #!py int, #!py float, #!py str and #!py bool. What is the output in each case? We see that the #!py input() function always returns a string. Even if the user enters a number, say #!py 123, that is processed as the string #!py '123'. If we want to accept an integer as input, how do we do it? We take the help of an operation called type conversion.\n\n\n\nIf we want to convert a string into an integer, Python provides a built-in function called #!py int():\nx = '123'\nprint('The type of x is', type(x))\ny = int(x)\nprint('The type of y is', type(y))\nThe operation in line 3 is called type conversion, i.e., we are converting an object of type #!py str into an object of type #!py int. The inverse operation also works. Predictably, the function needed for this purpose is #!py str():\nx = 123\nprint('The type of x is', type(x))\ny = str(x)\nprint('The type of y is', type(y))\nIf we want to accept an integer input from the user, we first take a string as input and then convert it into an integer:\nx = input('Enter an integer: ')\nx = int(x)\nprint('The integer entered by the user is', x)\nInstead of writing this in two lines, we could write this in a single line:\nx = int(input())\nprint('The integer entered by the user is', x)\nWhat we have done in line 1 is to compose two functions. That is, pass the output of the inner function - #!py input() - as the input of the outer function - #!py int(). In the above code, what happens if the input entered is a float value?\nx = int(input())    # user enters a float value here\nThe code will throw a ValueError. Let us take a concrete example. When the command #!py int('1.23') is entered, the interpreter tries to convert the string #!py '1.23' into an integer. But the number enclosed within the quotes is not an #!py int, but a #!py float. This number cannot be converted into an integer, hence the error.\n\n\n\nWe have been using the term built-in functions quite often. These are functions that have already been defined. Loosely speaking, a function in Python is an object that accepts inputs and produces outputs. For example, #!py print() is a built-in function that accepts an input and prints it to the console.\nWe will look at few more functions which will come in handy.\n\n#!py round() accepts a number as input and returns the integer closest to it. For example, #!py round(1.2) returns #!py 1, while #!py round(1.9) returns #!py 2.\n#!py abs() accepts a number as input and returns its absolute value. For example, #!py abs(-1.2) returns #!py 1.2.\n#!py int() is a bit involved. If an integer enclosed within quotes (string) is entered as input, then the output is that integer. We have already seen this: #!py int('123') is #!py 123. If a float is entered as input, then the decimal part is thrown away and the integer part is returned. For example, #!py int(1.2) returns #!py 1 and #!py int(-2.5) returns #!py -2. Do note that if a #!py float is passed in the form of a string, a ValueError will be thrown i.e., #!py int('2.5') will result in the following message:\n\nValueError: invalid literal for int() with base 10: '2.5'\n\n#!py pow() is another useful function. #!py pow(x, y) returns the value of \\(x^{y}\\). This performs the same function as the #!py ** operator. In general, the #!py ** operator is faster than the #!py pow function. But for small numbers, the difference is not perceptible. In fact, using the #!py pow() function increases readability of code. An extra feature of #!py pow() is that it supports a third argument: pow(x, y, z) returns the value of \\(x^{y} \\text{ mod } z\\). That is, it gives the remainder when \\(x^y\\) is divided by \\(z\\).\n#!py isinstance() is used to check if an object is of a specified type. For example #!py isinstance(3, int) returns the value #!py True as the literal #!py 3 is of type #!py int. The first argument could be any object, not just a literal. For example, if x is a variable of type #!py str then, #!py isinstance(x, str) will again return #!py True.\n\nThe Python documentation provides an exhaustive list of built-in functions."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.2.html#input",
    "href": "notes/chapter-2/lesson-2.2.html#input",
    "title": "Lesson-2.2",
    "section": "",
    "text": "Accepting input from the user routinely happens in programming. Any piece of software shipped to a customer needs to have a functional interface that will let the user interact with the software. We all have used apps like Facebook, Instagram and Twitter. These apps regularly accept input from the user, though we seldom look at it from a programming perspective. Take the case of commenting on a post in Facebook. The text entered in the comment box is the input. The code running in the backend processes this input and then displays it as a comment in a visually appealing form.\nPython provides a built-in function called #!py input() to accept input from the user. This is a simple yet powerful function:\nx = input()\nprint('The input entered by the user is', x)\nExecute the code given above and head to the console. Here the interpreter waits patiently for you to enter text. Press ++enter++ after entering the input. This acts as a cue for the interpreter to understand that you have completed entering your input. This text is stored in the variable x. The way it looks in the console is as follows:\n1\nThe input entered by the user is 1\nSometimes we may want to prompt the user to enter a particular type of input. This can be done by passing the instruction as an argument to the input function:\nx = input('Enter an integer between 0 and 10: ')\nprint('The number entered by the user is', x)\nLet us now look at the type of the variable x:\nx = input()\nprint('The input entered by the user is of type', type(x))\nExecute the above code with the following input types: #!py int, #!py float, #!py str and #!py bool. What is the output in each case? We see that the #!py input() function always returns a string. Even if the user enters a number, say #!py 123, that is processed as the string #!py '123'. If we want to accept an integer as input, how do we do it? We take the help of an operation called type conversion."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.2.html#type-conversion",
    "href": "notes/chapter-2/lesson-2.2.html#type-conversion",
    "title": "Lesson-2.2",
    "section": "",
    "text": "If we want to convert a string into an integer, Python provides a built-in function called #!py int():\nx = '123'\nprint('The type of x is', type(x))\ny = int(x)\nprint('The type of y is', type(y))\nThe operation in line 3 is called type conversion, i.e., we are converting an object of type #!py str into an object of type #!py int. The inverse operation also works. Predictably, the function needed for this purpose is #!py str():\nx = 123\nprint('The type of x is', type(x))\ny = str(x)\nprint('The type of y is', type(y))\nIf we want to accept an integer input from the user, we first take a string as input and then convert it into an integer:\nx = input('Enter an integer: ')\nx = int(x)\nprint('The integer entered by the user is', x)\nInstead of writing this in two lines, we could write this in a single line:\nx = int(input())\nprint('The integer entered by the user is', x)\nWhat we have done in line 1 is to compose two functions. That is, pass the output of the inner function - #!py input() - as the input of the outer function - #!py int(). In the above code, what happens if the input entered is a float value?\nx = int(input())    # user enters a float value here\nThe code will throw a ValueError. Let us take a concrete example. When the command #!py int('1.23') is entered, the interpreter tries to convert the string #!py '1.23' into an integer. But the number enclosed within the quotes is not an #!py int, but a #!py float. This number cannot be converted into an integer, hence the error."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.2.html#built-in-functions",
    "href": "notes/chapter-2/lesson-2.2.html#built-in-functions",
    "title": "Lesson-2.2",
    "section": "",
    "text": "We have been using the term built-in functions quite often. These are functions that have already been defined. Loosely speaking, a function in Python is an object that accepts inputs and produces outputs. For example, #!py print() is a built-in function that accepts an input and prints it to the console.\nWe will look at few more functions which will come in handy.\n\n#!py round() accepts a number as input and returns the integer closest to it. For example, #!py round(1.2) returns #!py 1, while #!py round(1.9) returns #!py 2.\n#!py abs() accepts a number as input and returns its absolute value. For example, #!py abs(-1.2) returns #!py 1.2.\n#!py int() is a bit involved. If an integer enclosed within quotes (string) is entered as input, then the output is that integer. We have already seen this: #!py int('123') is #!py 123. If a float is entered as input, then the decimal part is thrown away and the integer part is returned. For example, #!py int(1.2) returns #!py 1 and #!py int(-2.5) returns #!py -2. Do note that if a #!py float is passed in the form of a string, a ValueError will be thrown i.e., #!py int('2.5') will result in the following message:\n\nValueError: invalid literal for int() with base 10: '2.5'\n\n#!py pow() is another useful function. #!py pow(x, y) returns the value of \\(x^{y}\\). This performs the same function as the #!py ** operator. In general, the #!py ** operator is faster than the #!py pow function. But for small numbers, the difference is not perceptible. In fact, using the #!py pow() function increases readability of code. An extra feature of #!py pow() is that it supports a third argument: pow(x, y, z) returns the value of \\(x^{y} \\text{ mod } z\\). That is, it gives the remainder when \\(x^y\\) is divided by \\(z\\).\n#!py isinstance() is used to check if an object is of a specified type. For example #!py isinstance(3, int) returns the value #!py True as the literal #!py 3 is of type #!py int. The first argument could be any object, not just a literal. For example, if x is a variable of type #!py str then, #!py isinstance(x, str) will again return #!py True.\n\nThe Python documentation provides an exhaustive list of built-in functions."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python Companion",
    "section": "",
    "text": "This is a companion resource for the course “Programming in Python” offered at the foundational level of the BS program in data science and applications. Check out the navigation bar at the top to get an idea of the different resources that can be found here."
  },
  {
    "objectID": "howto/howto-24.html",
    "href": "howto/howto-24.html",
    "title": "Sort a list of numbers in ascending order",
    "section": "",
    "text": "Method-1Method-2Method-3\n\n\nThis is the simplest method. sort is a method of the list object. It sorts the list “in-place”. That is, it doesn’t create a new list in the process of sorting, but sorts the existing list itself. This method is to be avoided if you don’t want to disturb the original list.\nL = [10, -4, 40, 30, 14, 5, -1, -4]\nL.sort()\nprint(L)\n\n\nThis method sorts the list but creates a new list in the process. The original list is not distrubed.\nL = [10, -4, 40, 30, 14, 5, -1, -4]\nsorted_L = sorted(L)\nprint(sorted_L)\n\n\nThis uses the algorithm mentioned in the course.\nL = [10, -4, 40, 30, 14, 5, -1, -4]\nsorted_L = [ ]\nwhile L != [ ]:\n    smallest = min(L)\n    L.remove(smallest)\n    sorted_L.append(smallest)\nprint(sorted_L)"
  },
  {
    "objectID": "howto/howto-19.html",
    "href": "howto/howto-19.html",
    "title": "Check if a variable is of type int",
    "section": "",
    "text": "x = 3\nresult = isinstance(x, int)\nif result:\n    print(x, 'is an int')\nelse:\n    print(x, 'is not an int')"
  },
  {
    "objectID": "howto/howto-13.html",
    "href": "howto/howto-13.html",
    "title": "Iterate through the elements in a list",
    "section": "",
    "text": "Method-1Method-2\n\n\nThis is more Pythonic.\nL = ['this', 'is', 'a', 'list']\nfor word in L:\n    print(word)\n\n\nThis is less Pythonic.\nL = ['this', 'is', 'a', 'list']\nn = len(L)\nfor i in range(n):\n    print(L[i])"
  },
  {
    "objectID": "howto/howto-16.html",
    "href": "howto/howto-16.html",
    "title": "Print all elements in a list on the same line separated by a comma",
    "section": "",
    "text": "L = ['this', 'is', 'a', 'sentence']\nfor word in L:\n    print(word, end = ',')\nThis will add a comma after every word. As a result, there will be a comma after the last word. To get rid of it we can use this snippet:\nL = ['this', 'is', 'a', 'sentence']\nfor word in L[:-1]:\n    print(word, end = ',')\nprint(L[-1])\nThis iterates through the first \\(n - 1\\) entries in the list of length \\(n\\). The last element is printed outside the loop. The code is agnostic to the type of the values inside the list. That is, this snippet would work for a list of integers or a list of float values as well.\nIf we are dealing with a list of strings, there is a smarter way of doing this:\nL = ['this', 'is', 'a', 'sentence']\nsentence = ','.join(L)\nprint(sentence)\njoin is a string method that accepts a list of strings as argument and joins the elements in the list by using comma (the string on which the method is called) as the separator. If join is called using a different string, say a space, then the separator would be different."
  },
  {
    "objectID": "howto/howto-23.html",
    "href": "howto/howto-23.html",
    "title": "Find the maximum element in a list",
    "section": "",
    "text": "Method-1Method-2\n\n\nL = [10, -4, 40, 30, 14]\nmax_elem = max(L)\nprint(max_elem)\n\n\nThis approaches the problem from first principles.\nL = [10, -4, 40, 30, 14]\nmax_elem = L[0]\nfor x in L:\n    if x &gt; max_elem:\n        max_elem = x\nprint(max_elem)"
  },
  {
    "objectID": "howto/howto-22.html",
    "href": "howto/howto-22.html",
    "title": "Extract the sublist that does not contain the first and last elements",
    "section": "",
    "text": "Method-1Method-2\n\n\nL = [1, 2, 3, 4, 5, 6, 7, 8]\nsub_L = L[1:-1]\nprint(sub_L)\n\n\nL = [1, 2, 3, 4, 5, 6, 7, 8]\nn = len(L)\nsub_L = L[1:n - 1]\nprint(sub_L)"
  },
  {
    "objectID": "howto/howto-14.html",
    "href": "howto/howto-14.html",
    "title": "Print all elements in a list, one on each line",
    "section": "",
    "text": "L = [1, 2, 3, 4]\nfor x in L:\n    print(x)"
  },
  {
    "objectID": "howto/howto-12.html",
    "href": "howto/howto-12.html",
    "title": "Find number of elements in a list",
    "section": "",
    "text": "L = [1, 2, 3, 4]\nn = len(L)\nprint(n)"
  },
  {
    "objectID": "howto/howto-18.html",
    "href": "howto/howto-18.html",
    "title": "Find the last element in a list",
    "section": "",
    "text": "Method-1Method-2\n\n\nL = [10, 20, 30, 40]\nlast = L[-1]\n\n\nL = [10, 20, 30, 40]\nn = len(L)\nlast = L[n - 1]"
  },
  {
    "objectID": "howto/howto-3.html",
    "href": "howto/howto-3.html",
    "title": "Print the values of two variables on the same line",
    "section": "",
    "text": "name = 'Krishna'\nage = 35\nprint(name, age)\nFor more details refer to this video."
  },
  {
    "objectID": "howto/howto-10.html",
    "href": "howto/howto-10.html",
    "title": "Accept a float value as input",
    "section": "",
    "text": "x = float(input())"
  },
  {
    "objectID": "howto/howto-8.html",
    "href": "howto/howto-8.html",
    "title": "Create an empty list",
    "section": "",
    "text": "Method-1Method-2\n\n\nL = [ ]\n\n\nL = list()"
  },
  {
    "objectID": "howto/howto-27.html",
    "href": "howto/howto-27.html",
    "title": "Reverse a list of numbers",
    "section": "",
    "text": "Method-1Method-2Method-3Method-4\n\n\nThis is the most straightforward snippet that reverses a list in-place.\nL = [1, 2, 3, 4, 5]\nL.reverse()\nprint(L)\n\n\nL = [1, 2, 3, 4, 5]\nrev = [ ]\nfor x in L:\n    rev = [x] + rev\nprint(rev)\n\n\nHere we are using the step-size parameter. By starting with the last element of the list, we go back all the way till the beginning of the list, in steps of \\(-1\\). We leave the middle index unspecified so that it goes back all the way till the beginning.\nL = [1, 2, 3, 4, 5]\nn = len(L)\nrev = L[n-1::-1]\nprint(rev)\n\n\nWe can leave the first index also unspecified.\nL = [1, 2, 3, 4, 5]\nrev = L[::-1]\nprint(rev)"
  },
  {
    "objectID": "ppa/week-4/PPA-5.html",
    "href": "ppa/week-4/PPA-5.html",
    "title": "PPA-5",
    "section": "",
    "text": "Accept a space-separated sequence of positive real numbers as input. Convert each element of the sequence into the greatest integer less than or equal to it. Print this sequence of integers as output, with a comma between consecutive integers."
  },
  {
    "objectID": "ppa/week-4/PPA-5.html#question",
    "href": "ppa/week-4/PPA-5.html#question",
    "title": "PPA-5",
    "section": "",
    "text": "Accept a space-separated sequence of positive real numbers as input. Convert each element of the sequence into the greatest integer less than or equal to it. Print this sequence of integers as output, with a comma between consecutive integers."
  },
  {
    "objectID": "ppa/week-4/PPA-5.html#hint",
    "href": "ppa/week-4/PPA-5.html#hint",
    "title": "PPA-5",
    "section": "Hint",
    "text": "Hint\nA very important task that will keep repeating throughout the course is to print a sequence of items separated by a specific delimiter, say a comma or a space. For example, given a list L = [1, 2, 3, 4, 5], how does one print the sequence 1,2,3,4,5?\nThe first idea is to just add a comma after every element:\nL = [1, 2, 3, 4, 5]\nfor x in L:\n    print(str(x) + ',')\nIs str(x) needed here? Can’t it be just x?\nWhen this code is executed, it displays the output on five separate lines. By default, print adds a new line at the end after whatever item it is supposed to print. This default behaviour can be suppressed using the end argument:\nL = [1, 2, 3, 4, 5]\nfor x in L:\n    print(str(x) + ',', end = '')   # there is no space between the quotes\nThis prints 1,2,3,4,5,. While this is an improvement from the previous case, there is a problem with the comma right at the end. Before addressing that issue, this code can be simplified in the following manner:\nL = [1, 2, 3, 4, 5]\nfor x in L:\n    print(x, end = ',')\nThis also gives the same output as before: 1,2,3,4,5,. Now, it is time to get rid of the last comma. There are two ways to do it:\n\nMethod-1Method-2\n\n\nL = [1, 2, 3, 4, 5]\nfor num in L[: -1]:\n    print(num, end = ',')\nprint(L[-1])\n\n\nL = [1, 2, 3, 4, 5]\nfor index, num in enumerate(L):\n    if index == len(L) - 1:\n        print(num)\n    else:\n        print(num, end = ',')\n\n\n\n\nMethod-1 iterates over the first len(L) - 1 elements of the list and adds a comma after every element. It then gets out of the loop and just prints the last element without a comma.\nMethod-2 iterates over all the elements. If index corresponds to len(L) - 1, it just prints that element. If not, it prints the element and adds a comma at the end.\n\nBoth are valid methods."
  },
  {
    "objectID": "ppa/week-4/PPA-5.html#solution",
    "href": "ppa/week-4/PPA-5.html#solution",
    "title": "PPA-5",
    "section": "Solution",
    "text": "Solution\nWhy can’t we directly do L[i] = int(L[i])? Why do we need line-4 to happen before line-5? Try deleting line-4 and see what happens.\nL = input().split(' ')\n\nfor i in range(len(L)):\n    L[i] = float(L[i])\n    L[i] = int(L[i])\n\nfor i in range(len(L)):\n    if i != len(L) - 1:\n        print(L[i], end = ',')\n    else:\n        print(L[i])"
  },
  {
    "objectID": "ppa/week-4/PPA-9.html",
    "href": "ppa/week-4/PPA-9.html",
    "title": "PPA-9",
    "section": "",
    "text": "Accept a square matrix \\(A\\) and an integer \\(s\\) as input and print the matrix \\(s \\cdot A\\) as output. Multiplying a matrix by an integer \\(s\\) is equivalent to multiplying each element of the matrix by \\(s\\). For example: \\[\n2 \\cdot \\begin{bmatrix}\n1 & 2\\\\\n3 & 4\n\\end{bmatrix} = \\begin{bmatrix}\n2 & 4\\\\\n6 & 8\n\\end{bmatrix}\n\\]\n\nThe first line of input is a positive integer, \\(n\\), that denotes the dimension of the matrix \\(A\\). Each of the next \\(n\\) lines contains a sequence of space-separated integers. The last line of the input contains the integer \\(s\\).\nPrint the matrix \\(s \\cdot A\\) as output. Each row of the matrix must be printed as a sequence of space separated integers, one row on each line. There should not be any space after the last number on each line."
  },
  {
    "objectID": "ppa/week-4/PPA-9.html#question",
    "href": "ppa/week-4/PPA-9.html#question",
    "title": "PPA-9",
    "section": "",
    "text": "Accept a square matrix \\(A\\) and an integer \\(s\\) as input and print the matrix \\(s \\cdot A\\) as output. Multiplying a matrix by an integer \\(s\\) is equivalent to multiplying each element of the matrix by \\(s\\). For example: \\[\n2 \\cdot \\begin{bmatrix}\n1 & 2\\\\\n3 & 4\n\\end{bmatrix} = \\begin{bmatrix}\n2 & 4\\\\\n6 & 8\n\\end{bmatrix}\n\\]\n\nThe first line of input is a positive integer, \\(n\\), that denotes the dimension of the matrix \\(A\\). Each of the next \\(n\\) lines contains a sequence of space-separated integers. The last line of the input contains the integer \\(s\\).\nPrint the matrix \\(s \\cdot A\\) as output. Each row of the matrix must be printed as a sequence of space separated integers, one row on each line. There should not be any space after the last number on each line."
  },
  {
    "objectID": "ppa/week-4/PPA-9.html#hint",
    "href": "ppa/week-4/PPA-9.html#hint",
    "title": "PPA-9",
    "section": "Hint",
    "text": "Hint\nOne way to do it is to accept the matrix \\(A\\) as input and then create a new matrix \\(B\\), such that: \\[\nB[i][j] = s \\cdot A[i][j]\n\\]\nB = [ ]\nn = len(A)\nfor i in range(n):\n    row = [ ]\n    for j in range(n):\n        row.append(s * A[i][j])\n    B.append(row)\nThough this forms a part of a valid solution, is there another way of solving this problem?"
  },
  {
    "objectID": "ppa/week-4/PPA-9.html#solution",
    "href": "ppa/week-4/PPA-9.html#solution",
    "title": "PPA-9",
    "section": "Solution",
    "text": "Solution\nn = int(input())\nmatrix = [ ]\nfor i in range(n):\n    row = [ ]\n    for x in input().split(' '):\n        row.append(int(x))\n    matrix.append(row)\ns = int(input())\n\nfor i in range(n):\n    for j in range(n):\n        matrix[i][j] *= s\n\nfor i in range(n):\n    for j in range(n):\n        if j != n - 1:\n            print(matrix[i][j], end = ' ')\n        else:\n            print(matrix[i][j])"
  },
  {
    "objectID": "ppa/week-4/PPA-1.html",
    "href": "ppa/week-4/PPA-1.html",
    "title": "PPA-1",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the list of first \\(n\\) positive integers as output."
  },
  {
    "objectID": "ppa/week-4/PPA-1.html#question",
    "href": "ppa/week-4/PPA-1.html#question",
    "title": "PPA-1",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the list of first \\(n\\) positive integers as output."
  },
  {
    "objectID": "ppa/week-4/PPA-1.html#hint",
    "href": "ppa/week-4/PPA-1.html#hint",
    "title": "PPA-1",
    "section": "Hint",
    "text": "Hint\nThere are two ways of growing a list:\n\nappend method\nlist concatenation\n\nL = [ ]\nL.append(1)\nL = L + [2]\nprint(L)\nIf you want a list of the first \\(n\\) positive integers, then you need to use a loop."
  },
  {
    "objectID": "ppa/week-4/PPA-1.html#solutions",
    "href": "ppa/week-4/PPA-1.html#solutions",
    "title": "PPA-1",
    "section": "Solutions",
    "text": "Solutions\nBe careful to initialize L as the empty list before you begin populating it.\n\nSolution-1Solution-2\n\n\nn = int(input())\nL = [ ]\nfor x in range(1, n + 1):\n    L.append(x)\nprint(L)\n\n\nn = int(input())\nL = [ ]\nfor x in range(1, n + 1):\n    L = L + [x]\nprint(L)"
  },
  {
    "objectID": "ppa/week-4/PPA-4.html",
    "href": "ppa/week-4/PPA-4.html",
    "title": "PPA-4",
    "section": "",
    "text": "A list L of words is already given to you. Print the longest word in the list. If there are multiple words with the same maximum length, print the one which appears at the rightmost end of the list."
  },
  {
    "objectID": "ppa/week-4/PPA-4.html#question",
    "href": "ppa/week-4/PPA-4.html#question",
    "title": "PPA-4",
    "section": "",
    "text": "A list L of words is already given to you. Print the longest word in the list. If there are multiple words with the same maximum length, print the one which appears at the rightmost end of the list."
  },
  {
    "objectID": "ppa/week-4/PPA-4.html#hint",
    "href": "ppa/week-4/PPA-4.html#hint",
    "title": "PPA-4",
    "section": "Hint",
    "text": "Hint\nConsider the following snippet of code.\nmax_word, max_len = '', 0\nfor word in L:\n    if len(word) &gt; max_len:\n        max_len = len(word)\n        max_word = word\nAt the end of execution of this code, do you think max_word is the longest word in the list L as per the conditions given in the question.\nKey-point\nWhile iterating through a list of strings, make it a point to avoid the use of indices as much as possible. That is, try to avoid the following:\nfor i in range(len(L)):\n    ## do something with L[i] ##\nRather, use the following template:\nfor word in L:\n    ## do something with word ##\nThough both of them end up doing the same thing, the second template is more readable and Pythonic. That said, there would be problems (check next one) where you would require both the string and its index in the list. What can be done in such situations? Python provides a facility called enumerate for this.\nenumerate\nL = ['zero', 'one', 'two', 'three']\nfor index, word in enumerate(L):\n    print(index, word)\nThis gives the following output:\n0 zero\n1 one\n2 two\n3 three\nInstead of a single loop variable, note that we have two loop variables — index and word in line-2 of the code. Don’t worry about why this works. The rationale behind this will become clear when we discuss tuples in week-6. The point to keep in mind is that Python provides a way to iterate through a list in a clean way without having to use the unwieldy range(len(L)) construct."
  },
  {
    "objectID": "ppa/week-4/PPA-4.html#solution",
    "href": "ppa/week-4/PPA-4.html#solution",
    "title": "PPA-4",
    "section": "Solution",
    "text": "Solution\nmax_word, max_len = '', 0\nfor word in L:\n    if len(word) &gt;= max_len:\n        max_len = len(word)\n        max_word = word\nprint(max_word)"
  },
  {
    "objectID": "ppa/week-4/PPA-6.html",
    "href": "ppa/week-4/PPA-6.html",
    "title": "PPA-6",
    "section": "",
    "text": "Accept a sequence of comma-separated words as input. Reverse the sequence and print it as output."
  },
  {
    "objectID": "ppa/week-4/PPA-6.html#question",
    "href": "ppa/week-4/PPA-6.html#question",
    "title": "PPA-6",
    "section": "",
    "text": "Accept a sequence of comma-separated words as input. Reverse the sequence and print it as output."
  },
  {
    "objectID": "ppa/week-4/PPA-6.html#hint",
    "href": "ppa/week-4/PPA-6.html#hint",
    "title": "PPA-6",
    "section": "Hint",
    "text": "Hint\nApproach-1\nConsider the following sequence of operations on a list L = [1, 2, 3, 4, 5]. To reverse this list, you can pick up its last element and make it the first element of a new list.\nStep-0\n[1, 2, 3, 4, 5]\n\n[ ]\nStep-1\n[1, 2, 3, 4]\n\n[5]\nStep-2\n[1, 2, 3]\n\n[5, 4]\nStep-3\n[1, 2]\n\n[5, 4, 3]\nStep-4\n[1]\n\n[5, 4, 3, 2]\nStep-5\n[ ]\n\n[5, 4, 3, 2, 1]\nYou don’t necessarily have to remove the elements from the first list. But let us continue with the approach of removing an element from the first list and adding it to the second list. How will you remove an element from a list?\nApproach-2\nConsider the two lists:\nP = [1, 2, 3, 4, 5]\nQ = [5, 4, 3, 2, 1]\nWe note the following:\n\n\n\nx\nIndex of x in P\nIndex of x in Q\n\n\n\n\n1\n0\n4\n\n\n2\n1\n3\n\n\n3\n2\n2\n\n\n4\n3\n1\n\n\n5\n4\n0\n\n\n\nDo you see any pattern in the index of the element x in P and Q? Is there a way you can use this pattern to reverse the list?"
  },
  {
    "objectID": "ppa/week-4/PPA-6.html#solutions",
    "href": "ppa/week-4/PPA-6.html#solutions",
    "title": "PPA-6",
    "section": "Solutions",
    "text": "Solutions\nSolutions galore! Do make it a point to go through every one of them.\n\nSolution-1Solution-2Solution-3Solution-4Solution-5Solution-6Solution-7Solution-8\n\n\nL = input().split(',')\n\nout = [ ]\nfor x in L:\n    out = [x] + out\n\n# Printing: common to all solutions\nn = len(out)\nfor i in range(n - 1):\n    print(out[i], end = ',')\nprint(out[-1])\n\n\nL = input().split(',')\n\nn = len(L)\nout = [ ]\nfor i in range(n):\n    out.append(L[n - 1 - i])\n    \n# Printing: common to all solutions\nfor i in range(n - 1):\n    print(out[i], end = ',')\nprint(out[-1])\n\n\nTake a look at line-5. As the loop proceeds, we are swapping the first and last element, then the second and the penultimate element, and so on. Also take a look at the end-point of the range function. This solution stands out from all the previous two in one detail: it reverses the list in-place, meaning, it doesn’t require a new list.\nL = input().split(',')\n\nn = len(L)\nfor i in range(n // 2):\n    L[i], L[-i - 1] = L[-i - 1], L[i]\n\n# Printing: common to all solutions\nfor i in range(n - 1):\n    print(L[i], end = ',')\nprint(L[-1])\n\n\nHere we are reversing the range. We start from \\(n - 1\\) and go all the way till \\(0\\). The step-size is \\(-1\\). Hence the range function looks like this: range(n - 1, -1, -1). The end-point is one less than where we want to stop, hence it is \\(-1\\) and not \\(0\\).\nL = input().split(',')\nn = len(L)\nout = [ ]\nfor i in range(n - 1, -1, -1):\n    out.append(L[i])\n\n# Printing: common to all solutions\nfor i in range(n - 1):\n    print(out[i], end = ',')\nprint(out[-1])\n\n\nThe best is reserved for the last. This uses some advanced slicing. We know that L[start:end] gives the slice from L[start] to L[end - 1]. The third argument in the slice is the step size. So when we have L[::-1], it means start from the end of the list and go all the way till the beginning of the list in steps of \\(-1\\).\nL = input().split(',')\nout = L[::-1]\n\n# Printing: common to all solutions\nn = len(out)\nfor i in range(n - 1):\n    print(out[i], end = ',')\nprint(out[-1])\n\n\nIf you thought solution-5 was the best of the lot, here is something better. This reverses the list in-place.\nL = input().split(',')\nL.reverse()\n\n# Printing: common to all solutions\nn = len(L)\nfor i in range(n - 1):\n    print(L[i], end = ',')\nprint(L[-1])\n\n\nWe will not go into the details, but there is a construct called reversed that helps us iterate over a reversed sequence.\nL = input().split(',')\nout = [ ]\nfor x in reversed(L):\n    out.append(x)\n\n# Printing: common to all solutions\nn = len(out)\nfor i in range(n - 1):\n    print(out[i], end = ',')\nprint(out[-1])\n\n\nWe can directly convert this into a list. Try removing list and see what you get.\nL = input().split(',')\nout = list(reversed(L))\n\n# Printing: common to all solutions\nn = len(out)\nfor i in range(n - 1):\n    print(out[i], end = ',')\nprint(out[-1])"
  },
  {
    "objectID": "ppa/week-4/PPA-8.html",
    "href": "ppa/week-4/PPA-8.html",
    "title": "PPA-8",
    "section": "",
    "text": "An identity matrix is a square matrix which has ones on the main diagonal and zeros everywhere else. For example, the identity matrix of size \\(3 \\times 3\\) is: \\[\n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\]\n\nAccept a positive integer \\(n\\) as input and print the identity matrix of size \\(n \\times n\\). Your output should have \\(n\\) lines, where each line is a sequence of \\(n\\) comma-separated integers that corresponds to one row of the matrix."
  },
  {
    "objectID": "ppa/week-4/PPA-8.html#question",
    "href": "ppa/week-4/PPA-8.html#question",
    "title": "PPA-8",
    "section": "",
    "text": "An identity matrix is a square matrix which has ones on the main diagonal and zeros everywhere else. For example, the identity matrix of size \\(3 \\times 3\\) is: \\[\n\\begin{bmatrix}\n1 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\]\n\nAccept a positive integer \\(n\\) as input and print the identity matrix of size \\(n \\times n\\). Your output should have \\(n\\) lines, where each line is a sequence of \\(n\\) comma-separated integers that corresponds to one row of the matrix."
  },
  {
    "objectID": "ppa/week-4/PPA-8.html#hint",
    "href": "ppa/week-4/PPA-8.html#hint",
    "title": "PPA-8",
    "section": "Hint",
    "text": "Hint\nIn order to print the elements of a matrix with one row on each line, a nested loop is needed. After the inner loop goes through a row, a new line should be added. This can be done with a simple print statement.\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nfor i in range(3):\n    for j in range(3):\n        print(matrix[i][j], end = ',')\n    print()\nThis gives the following output:\n1,2,3,\n4,5,6,\n7,8,9,\nHow does one get rid of the comma at the end? Check out PPA-5 to get the logic for this."
  },
  {
    "objectID": "ppa/week-4/PPA-8.html#solution",
    "href": "ppa/week-4/PPA-8.html#solution",
    "title": "PPA-8",
    "section": "Solution",
    "text": "Solution\nn = int(input())\nI = [ ]\nfor i in range(n):\n    row = [ ]\n    for j in range(n):\n        if i == j:\n            row.append(1)\n        else:\n            row.append(0)\n    I.append(row)\n    \nfor i in range(n):\n    for j in range(n):\n        if j != n - 1:\n            print(I[i][j], end = ',')\n        else:\n            print(I[i][j])"
  },
  {
    "objectID": "ppa/week-2/PPA-9.html",
    "href": "ppa/week-2/PPA-9.html",
    "title": "PPA-9",
    "section": "",
    "text": "You have \\(n\\) gold coins with you. You wish to divide this among three of your friends under the following conditions:\n\nAll three of them should get a non-zero share.\nNo two of them should get the same number of coins.\nYou should not have any coins with you at the end of this sharing process.\n\nThe input has four lines. The first line contains the number of coins with you. The next three lines will have the share given to your three friends. All inputs shall be non-negative integers. If the division satisfies these conditions, then print the string FAIR. If not, print UNFAIR."
  },
  {
    "objectID": "ppa/week-2/PPA-9.html#question",
    "href": "ppa/week-2/PPA-9.html#question",
    "title": "PPA-9",
    "section": "",
    "text": "You have \\(n\\) gold coins with you. You wish to divide this among three of your friends under the following conditions:\n\nAll three of them should get a non-zero share.\nNo two of them should get the same number of coins.\nYou should not have any coins with you at the end of this sharing process.\n\nThe input has four lines. The first line contains the number of coins with you. The next three lines will have the share given to your three friends. All inputs shall be non-negative integers. If the division satisfies these conditions, then print the string FAIR. If not, print UNFAIR."
  },
  {
    "objectID": "ppa/week-2/PPA-9.html#hint",
    "href": "ppa/week-2/PPA-9.html#hint",
    "title": "PPA-9",
    "section": "Hint",
    "text": "Hint\nThere are three expressions given to you here:\n(a &gt; 0) and (b &gt; 0) and (c &gt; 0)\n(a != b) and (b != c) and (c != a)\na + b + c - n == 0\nNow, make use of these three expressions to construct a solution. Consider another set of three expressions:\n(a == 0) or (b == 0) or (c == 0)\n(a == b) or (b == c) or (c == a)\na + b + c - n != 0\nNow, make use of these three expressions to construct another solution. How are these two solutions different from each other?"
  },
  {
    "objectID": "ppa/week-2/PPA-9.html#solutions",
    "href": "ppa/week-2/PPA-9.html#solutions",
    "title": "PPA-9",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif (a &gt; 0) and (b &gt; 0) and (c &gt; 0):\n    if (a != b) and (b != c) and (c != a):\n        if a + b + c - n == 0:\n            print('FAIR')\n        else:\n            print('UNFAIR')\n    else:\n        print('UNFAIR')\nelse:\n    print('UNFAIR')\n\n\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nflag = True\nif (a == 0) or (b == 0) or (c == 0):\n    flag = False\nif (a == b) or (b == c) or (c == a):\n    flag = False\nif a + b + c - n != 0:\n    flag = False\n\nif flag:\n    print('FAIR')\nelse:\n    print('UNFAIR')"
  },
  {
    "objectID": "ppa/week-2/PPA-1.html",
    "href": "ppa/week-2/PPA-1.html",
    "title": "PPA-1",
    "section": "",
    "text": "Accept an integer as input. Print positive if it is greater than zero and negative if it is less than zero. You can assume that the input will be non-zero."
  },
  {
    "objectID": "ppa/week-2/PPA-1.html#question",
    "href": "ppa/week-2/PPA-1.html#question",
    "title": "PPA-1",
    "section": "",
    "text": "Accept an integer as input. Print positive if it is greater than zero and negative if it is less than zero. You can assume that the input will be non-zero."
  },
  {
    "objectID": "ppa/week-2/PPA-1.html#hint",
    "href": "ppa/week-2/PPA-1.html#hint",
    "title": "PPA-1",
    "section": "Hint",
    "text": "Hint\nAn incomplete outline of the solution is given below:\nif x &gt; 0:\n    print('positive')\nCan you complete it?"
  },
  {
    "objectID": "ppa/week-2/PPA-1.html#solution",
    "href": "ppa/week-2/PPA-1.html#solution",
    "title": "PPA-1",
    "section": "Solution",
    "text": "Solution\nSince the problem statement assures us that the input will be non-zero, the following solution will work.\nx = int(input())\nif x &gt; 0:\n    print('positive')\nelse:\n    print('negative')\nIf the input could be zero, then we need to modify the code as follows:\nx = int(input())\nif x &gt; 0:\n    print('positive')\nelif x &lt; 0:\n    print('negative')\nThis snippet will not print anything when \\(0\\) is passed as input."
  },
  {
    "objectID": "ppa/week-2/PPA-4.html",
    "href": "ppa/week-2/PPA-4.html",
    "title": "PPA-4",
    "section": "",
    "text": "Accept a point in 2D space as input and find the region in space that this point belongs to. A point could belong to one of the four quadrants, or it could be on one of the two axes, or it could be the origin. The input is given in 2 lines: the first line is the x-coordinate of the point while the second line is its y-coordinate. The possible outputs are first, second, third, fourth, x-axis, y-axis, and origin. Any other output will not be accepted. Note that all outputs should be in lower case."
  },
  {
    "objectID": "ppa/week-2/PPA-4.html#question",
    "href": "ppa/week-2/PPA-4.html#question",
    "title": "PPA-4",
    "section": "",
    "text": "Accept a point in 2D space as input and find the region in space that this point belongs to. A point could belong to one of the four quadrants, or it could be on one of the two axes, or it could be the origin. The input is given in 2 lines: the first line is the x-coordinate of the point while the second line is its y-coordinate. The possible outputs are first, second, third, fourth, x-axis, y-axis, and origin. Any other output will not be accepted. Note that all outputs should be in lower case."
  },
  {
    "objectID": "ppa/week-2/PPA-4.html#hint",
    "href": "ppa/week-2/PPA-4.html#hint",
    "title": "PPA-4",
    "section": "Hint",
    "text": "Hint\nFor a point (x, y), you have to construct a table such as this:\n\n\n\nCondition\nResult\n\n\n\n\nBoth x and y are positive\nfirst\n\n\nx is positive and y is negative\nfourth\n\n\n\nYour task is twofold. First, complete this table. How many rows does it have? Secondly, convert the conditions into Python expressions. Now, you just have to write a sequence of conditional statements and print the appropriate string. Study the following snippets:\n\nSnippet-1Snippet-2Snippet-3\n\n\nif x &gt; 0:\n    if y &gt; 0:\n        print('first')\n\n\nif x &gt; 0 and y &gt; 0:\n    print('first')\n\n\nif x &gt; 0 or y &gt; 0:\n    print('first')\n\n\n\nHere is a follow-up question to help you with the second task:\n\nAmong the three snippets, which one would you choose to include in your solution to the problem?\nWhat are the differences and similarities between snippet-1 and snippet-2?"
  },
  {
    "objectID": "ppa/week-2/PPA-4.html#solutions",
    "href": "ppa/week-2/PPA-4.html#solutions",
    "title": "PPA-4",
    "section": "Solutions",
    "text": "Solutions\nAn image of the coordinate plane with the regions marked on it:\n\n\nSolution-1Solution-2\n\n\nx = float(input())\ny = float(input())\n\nif x &gt; 0:\n    if y &gt; 0:\n        print('first')\n    elif y &lt; 0:\n        print('fourth')\n    else:\n        print('x-axis')\nelif x &lt; 0:\n    if y &gt; 0:\n        print('second')\n    elif y &lt; 0:\n        print('third')\n    else:\n        print('x-axis')\nelse:\n    if y != 0:\n        print('y-axis')\n    else:\n        print('origin')\n\n\nx = float(input())\ny = float(input())\n\nif x &gt; 0 and y &gt; 0:\n    print('first')\nelif x &lt; 0 and y &gt; 0:\n    print('second')\nelif x &lt; 0 and y &lt; 0:\n    print('third')\nelif x &gt; 0 and y &lt; 0:\n    print('fourth')\nelif x != 0 and y == 0:\n    print('x-axis')\nelif x == 0 and y != 0:\n    print('y-axis')\nelif x == 0 and y == 0:\n    print('origin')"
  },
  {
    "objectID": "ppa/week-2/PPA-6.html",
    "href": "ppa/week-2/PPA-6.html",
    "title": "PPA-6",
    "section": "",
    "text": "Accept a string as input. If the input string is of odd length, then continue with it. If the input string is of even length, make the string of odd length as below:\n\nIf the last character is a period (.), then remove it\nIf the last character is not a period, then add a period (.) to the end of the string\n\nCall this string of odd length word. Select a substring made up of three consecutive characters from word such that there are an equal number of characters to the left and right of this substring. Print this substring as output. You can assume that all input strings will be in lower case and will have a length of at least four."
  },
  {
    "objectID": "ppa/week-2/PPA-6.html#question",
    "href": "ppa/week-2/PPA-6.html#question",
    "title": "PPA-6",
    "section": "",
    "text": "Accept a string as input. If the input string is of odd length, then continue with it. If the input string is of even length, make the string of odd length as below:\n\nIf the last character is a period (.), then remove it\nIf the last character is not a period, then add a period (.) to the end of the string\n\nCall this string of odd length word. Select a substring made up of three consecutive characters from word such that there are an equal number of characters to the left and right of this substring. Print this substring as output. You can assume that all input strings will be in lower case and will have a length of at least four."
  },
  {
    "objectID": "ppa/week-2/PPA-6.html#hint",
    "href": "ppa/week-2/PPA-6.html#hint",
    "title": "PPA-6",
    "section": "Hint",
    "text": "Hint\nIn case you are confused with the terminology, a period is another term for the full-stop.\nThis problem can be split into two parts:\n\nGet a string of odd length.\nExtract the required substring.\n\nIf the string is already of odd length, you don’t have to do much. If not, then you have to follow the procedure given in the question. A small snippet is given to help you; where do you think you would find this useful?\nif word[-1] == '.':\n    new_word = word[: -1]\nIf word = 'abcde', then word[: -1] is abcd. Do you see what is happening here?\nNow, how do you extract the substring? The hint is to focus on the character that is at the center of the string. Do you see why this is important? If you do, then how do you obtain the index of the middle chatacter in a string? What does all this have to do with the length of the string being odd? If the string had an even number of characters, what problems would you face?"
  },
  {
    "objectID": "ppa/week-2/PPA-6.html#solution",
    "href": "ppa/week-2/PPA-6.html#solution",
    "title": "PPA-6",
    "section": "Solution",
    "text": "Solution\nword = input()\nif len(word) % 2 == 0:\n    if word[-1] == '.':\n        word = word[: -1]\n    else:\n        word = word + '.'\nmid = len(word) // 2\nout = word[mid - 1:mid + 2]\nprint(out)"
  },
  {
    "objectID": "ppa/week-2/PPA-8.html",
    "href": "ppa/week-2/PPA-8.html",
    "title": "PPA-8",
    "section": "",
    "text": "Consider the following image of a chess-board (image borrowed from chess.com). The piece on the board is a bishop.\n\n\n\n\n\nAccept two positions as input: start and end. Print YES if a bishop at start can move to end in exactly one move. Print NO otherwise. Note that a bishop can only move along diagonals."
  },
  {
    "objectID": "ppa/week-2/PPA-8.html#question",
    "href": "ppa/week-2/PPA-8.html#question",
    "title": "PPA-8",
    "section": "",
    "text": "Consider the following image of a chess-board (image borrowed from chess.com). The piece on the board is a bishop.\n\n\n\n\n\nAccept two positions as input: start and end. Print YES if a bishop at start can move to end in exactly one move. Print NO otherwise. Note that a bishop can only move along diagonals."
  },
  {
    "objectID": "ppa/week-2/PPA-8.html#hint",
    "href": "ppa/week-2/PPA-8.html#hint",
    "title": "PPA-8",
    "section": "Hint",
    "text": "Hint\nThe bishop is capable of only diagonal moves. In the problem statement, you have to figure out if the bishop can move from start to end in exactly one move. So you have to see if this movement is along a diagonal or not. What are the characteristics of a diagonal? In terms of coordinate geometry, what is the slope of a diagonal?\nAs far as the inputs are concerned, each position on the chessboard is given by two symbols: a letter and a number. The letter denotes the column and the number denotes the row. For example, the bishop in the image given above is at C4. In the test cases, we use capital letters for the columns.\nNow consider the following strings:\ncols = 'ABCDEFGH'\nrows = '12345678'\nAnd the following snippet of code:\ncols.index('D')\nCan you come up with the solution using these hints?"
  },
  {
    "objectID": "ppa/week-2/PPA-8.html#solution",
    "href": "ppa/week-2/PPA-8.html#solution",
    "title": "PPA-8",
    "section": "Solution",
    "text": "Solution\nstart = input()\nend = input()\n\ncols = 'ABCDEFGH'\nrows = '12345678'\n\nstart_col, start_row = start[0], start[1]\nend_col, end_row = end[0], end[1]\n\ncol_diff = cols.index(start_col) - cols.index(end_col)\nrow_diff = rows.index(start_row) - rows.index(end_row)\n\n# abs(x) returns the absolute value of x\nif abs(col_diff) == abs(row_diff):\n    print('YES')\nelse:\n    print('NO')"
  },
  {
    "objectID": "ppa/week-3/PPA-11.html",
    "href": "ppa/week-3/PPA-11.html",
    "title": "PPA-11",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and find all solutions to the equation: \\[\nx^2 + y^2 = z^2\n\\] subject to the following constraints:\n\n\\(x\\), \\(y\\) and \\(z\\) are positive integers\n\\(x &lt; y &lt; z &lt; n\\)\n\nPrint each solution triplet on one line — x,y,z — with a comma between consecutive integers. The triplets should be printed in ascending order. If you do not find any solutions satisfying the given constraints, print the string NO SOLUTION as output.\nOrder relation among triplets\nGiven two triplets \\(T_1 = (x_1, y_1, z_1)\\) and \\(T_2 = (x_2, y_2, z_2)\\), use the following process to compare them:\n\nIf \\(x_1 &lt; x_2\\), then \\(T_1 &lt; T_2\\)\nIf \\(x_1 = x_2\\) and \\(y_1 &lt; y_2\\), then \\(T_1 &lt; T_2\\)\nIf \\(x_1 = x_2\\), \\(y_1 = y_2\\), and \\(z_1 &lt; z_2\\), then \\(T_1 &lt; T_2\\)"
  },
  {
    "objectID": "ppa/week-3/PPA-11.html#question",
    "href": "ppa/week-3/PPA-11.html#question",
    "title": "PPA-11",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and find all solutions to the equation: \\[\nx^2 + y^2 = z^2\n\\] subject to the following constraints:\n\n\\(x\\), \\(y\\) and \\(z\\) are positive integers\n\\(x &lt; y &lt; z &lt; n\\)\n\nPrint each solution triplet on one line — x,y,z — with a comma between consecutive integers. The triplets should be printed in ascending order. If you do not find any solutions satisfying the given constraints, print the string NO SOLUTION as output.\nOrder relation among triplets\nGiven two triplets \\(T_1 = (x_1, y_1, z_1)\\) and \\(T_2 = (x_2, y_2, z_2)\\), use the following process to compare them:\n\nIf \\(x_1 &lt; x_2\\), then \\(T_1 &lt; T_2\\)\nIf \\(x_1 = x_2\\) and \\(y_1 &lt; y_2\\), then \\(T_1 &lt; T_2\\)\nIf \\(x_1 = x_2\\), \\(y_1 = y_2\\), and \\(z_1 &lt; z_2\\), then \\(T_1 &lt; T_2\\)"
  },
  {
    "objectID": "ppa/week-3/PPA-11.html#hint",
    "href": "ppa/week-3/PPA-11.html#hint",
    "title": "PPA-11",
    "section": "Hint",
    "text": "Hint\nFirst, study the following snippet of code:\nfor x in range(1, 3):\n    for y in range(1, 3):\n        for z in range(1, 3):\n            print(x, y, z)\nThis is the output:\n1 1 1\n1 1 2\n1 2 1\n1 2 2\n2 1 1\n2 1 2\n2 2 1\n2 2 2\nWhat can you say about the order in which the triplets are printed? How will you use this idea to construct a solution to this problem?"
  },
  {
    "objectID": "ppa/week-3/PPA-11.html#solution",
    "href": "ppa/week-3/PPA-11.html#solution",
    "title": "PPA-11",
    "section": "Solution",
    "text": "Solution\nn = int(input())\n\nnum = 0\nfor x in range(1, n):\n    for y in range(x + 1, n):\n        for z in range(y + 1, n):\n            if x ** 2 + y ** 2 == z ** 2:\n                print(f'{x},{y},{z}')\n                num += 1\nif num == 0:\n    print('NO SOLUTION')"
  },
  {
    "objectID": "ppa/week-3/PPA-3.html",
    "href": "ppa/week-3/PPA-3.html",
    "title": "PPA-3",
    "section": "",
    "text": "Accept two positive integers \\(a\\) and \\(b\\) as input. Print the sum of all integers in the range \\([1000, 2000]\\), endpoints inclusive, that are divisible by both \\(a\\) and \\(b\\). If you find no number satisfying this condition in the given range, then print 0."
  },
  {
    "objectID": "ppa/week-3/PPA-3.html#question",
    "href": "ppa/week-3/PPA-3.html#question",
    "title": "PPA-3",
    "section": "",
    "text": "Accept two positive integers \\(a\\) and \\(b\\) as input. Print the sum of all integers in the range \\([1000, 2000]\\), endpoints inclusive, that are divisible by both \\(a\\) and \\(b\\). If you find no number satisfying this condition in the given range, then print 0."
  },
  {
    "objectID": "ppa/week-3/PPA-3.html#hint",
    "href": "ppa/week-3/PPA-3.html#hint",
    "title": "PPA-3",
    "section": "Hint",
    "text": "Hint\nThis is an extension of the previous problem. Here, you have to filter out all the numbers that are divisible by both \\(a\\) and \\(b\\)."
  },
  {
    "objectID": "ppa/week-3/PPA-3.html#solution",
    "href": "ppa/week-3/PPA-3.html#solution",
    "title": "PPA-3",
    "section": "Solution",
    "text": "Solution\na = int(input())\nb = int(input())\n\ntotal = 0\nfor f in range(1000, 2001):\n    if (f % a == 0) and (f % b == 0):\n        total += f\n\nprint(total)"
  },
  {
    "objectID": "ppa/week-3/PPA-7.html",
    "href": "ppa/week-3/PPA-7.html",
    "title": "PPA-7",
    "section": "",
    "text": "Accept a positive integer as input and print the sum of the digits in the number."
  },
  {
    "objectID": "ppa/week-3/PPA-7.html#question",
    "href": "ppa/week-3/PPA-7.html#question",
    "title": "PPA-7",
    "section": "",
    "text": "Accept a positive integer as input and print the sum of the digits in the number."
  },
  {
    "objectID": "ppa/week-3/PPA-7.html#hint",
    "href": "ppa/week-3/PPA-7.html#hint",
    "title": "PPA-7",
    "section": "Hint",
    "text": "Hint\nLet us take a number, say 1234 and see how to computationally approach the problem. We could start adding the digits from the left, \\(1 + 2 + 3 + 4\\), or we could do it from the right, \\(4 + 3 + 2 + 1\\). If we do it from the left, then we need to get hold of the leftmost digit of the number. It is not immediately clear how to do this. If we do it from the right, then we need to get hold of the last digit. Fortunately, this is something that we can easily do:\nThis can be done by taking the remainder when the number is divided by 10, that is, 1234 % 10 == 4. Once we have the last digit, we no longer need it in the original number. To get rid of the last digit, we go for floor division by 10: 1234 // 10 == 123. Now, it is just a matter of doing these two operations repeatedly:\nx = 1234\ndigit_4 = x % 10\nx = x // 10\ndigit_3 = x % 10\nx = x // 10\ndigit_2 = x % 10\nx = x // 10\ndigit_1 = x % 10\nIt is now up to you to generalize this logic so that it will work for any number. Naturally, if the number of digits is arbitrary, then we have to go for a loop. Which type of loop do you think is a better option here, for or while? Are the number of iterations known a priori or not?\nIf you decide to go for a while loop, what would be the termination condition? To answer the last question, think about the number \\(1234\\) and perform the pair of operations (modulo \\(10\\) followed by floor division by \\(10\\)) four times. What is the final value of x that you end up with?"
  },
  {
    "objectID": "ppa/week-3/PPA-7.html#solutions",
    "href": "ppa/week-3/PPA-7.html#solutions",
    "title": "PPA-7",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nn = int(input())\ntotal = 0\nwhile n &gt; 0:\n    total = total + (n % 10)\n    n = n // 10\nprint(total)\n\n\nHere we retain n as a string and then iterate through it.\nn = input()\ntotal = 0\nfor x in n:\n    total = total + int(x)\nprint(total)"
  },
  {
    "objectID": "ppa/week-3/PPA-4.html",
    "href": "ppa/week-3/PPA-4.html",
    "title": "PPA-4",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input, where \\(n &gt; 1\\). Print PRIME if \\(n\\) is a prime number and NOTPRIME otherwise."
  },
  {
    "objectID": "ppa/week-3/PPA-4.html#question",
    "href": "ppa/week-3/PPA-4.html#question",
    "title": "PPA-4",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input, where \\(n &gt; 1\\). Print PRIME if \\(n\\) is a prime number and NOTPRIME otherwise."
  },
  {
    "objectID": "ppa/week-3/PPA-4.html#hint",
    "href": "ppa/week-3/PPA-4.html#hint",
    "title": "PPA-4",
    "section": "Hint",
    "text": "Hint\nThere are at least two different approaches to this problem:\nApproach-1\nA prime number \\(p\\) has exactly two factors, one and the number itself:\n\n\\(1\\)\n\\(p\\)\n\nGiven the number \\(n\\) in this problem, we can count the number of factors it has. If this number is equal to \\(2\\), then we have a prime number. This approach suggests a natural separation of the code into two parts:\n\nuse a for-loop to count the number of factors of \\(n\\) and store it in a variable, say num\nuse an if-else block to check if the number of factors is equal to \\(2\\) or not, and display the appropriate message\n\nA variation to this approach is the following. While looping through the possible factors of \\(n\\), if you find that the number of factors has exceeded \\(2\\) at some stage, does it make sense to persist with the iterations? Or does it give us an opportunity to break out of the loop? See if you can make use of the following snippet of code:\n### inside some loop ###\n    if num &gt; 3:\n        break\n### inside some loop ###\nWhy does breaking help? What are the advantages of doing so?\nApproach-2\nA number \\(n\\) is a composite number (not-prime) if it has a factor \\(f\\) which is different from \\(1\\) and \\(n\\). For example, \\(6\\) is a composite number as it has a factor \\(2\\), which is neither \\(1\\) nor \\(6\\). We will now use this slightly different perspective to solve the problem.\nThis approach is based on the idea of the state of a system. In our case, the system is the code. In most problems in our course, the state will be binary. For this problem, we will associate prime numbers with state = True. Therefore, while looping through the factors of \\(n\\), we could be in one of these two states:\n\nstate = True\nstate = False\n\nIf the state is True, it means that so far we have not come across any factor of \\(n\\) other than \\(1\\) and \\(n\\). The moment we find a factor of \\(n\\) other than \\(1\\) and \\(n\\), we should update the state to False. For example:\nstate = True\nfor f in range(1, n + 1):\n    if (n % f == 0) and (f != 1) and (f != n):\n        state = False\nWe start with an “optimistic” mindset that the number \\(n\\) is a prime and set state = True in line-1. During the looping process, if we find that \\(n\\) is composite, we update the state to False. If \\(n\\) is indeed prime, then the state remains True even after the loop ends. Either way, at the end of the loop, the state variable will tell us whether the number \\(n\\) is prime or not. Notice that the state is a dynamic entity during the looping process. For a composite number, state = True to begin with, but it eventually becomes False.\nThis approach is an extremely powerful template and can be applied to a wide range of problems. We will refer to this as the state-approach. There are some variants to this solution as well. Does breaking out of the loop make sense here? If the state become False, can it ever become True again? Finally, is there a simpler way of writing the if-condition so that we don’t have to check for three conditions? The hint lies in rethinking about the range of numbers that you have to check for. Should it be range(1, n + 1), or can it be something else?"
  },
  {
    "objectID": "ppa/week-3/PPA-4.html#solutions",
    "href": "ppa/week-3/PPA-4.html#solutions",
    "title": "PPA-4",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2Solution-3\n\n\nn = int(input())\ncount = 0\nfor f in range(1, n + 1):\n    if n % f == 0:\n        count += 1\nif count == 2:\n    print('PRIME')\nelse:\n    print('NOTPRIME')\n\n\nn = int(input())\n# optimistic start\nis_prime = True\n\nfor f in range(1, n + 1):\n    if (n % f == 0) and (f != 1) and (f != n):\n        is_prime = False\n        break\n\nif is_prime:\n    print('PRIME')\nelse:\n    print('NOTPRIME')\n\n\nThough the following code will not work for \\(n = 1\\), the question states that \\(n &gt; 1\\). We have made use of this fact. This code is a slight improvement over solution-2.\nn = int(input())\n# optimistic start\nis_prime = True\n\nfor f in range(2, n):\n    if n % f == 0:\n        is_prime = False\n        break\n\nif is_prime:\n    print('PRIME')\nelse:\n    print('NOTPRIME')"
  },
  {
    "objectID": "ppa/week-3/PPA-6.html",
    "href": "ppa/week-3/PPA-6.html",
    "title": "PPA-6",
    "section": "",
    "text": "Accept a sequence of words as input and print the the shortest word in the sequence. The input will have \\(n + 1\\) lines, where \\(n\\) denotes the number of terms in the sequence. The \\(i^{th}\\) line in the input will contain the \\(i^{th}\\) word in the sequence for \\(1 \\leq i \\leq n\\).\nThe last line of the input will always be the string abcdefghijklmnopqrstuvwxyz. This string is not a part of the sequence. You can assume that each test case corresponds to a non-empty sequence of words. If there are multiple words that have the same minimum length, print the first such occurrence."
  },
  {
    "objectID": "ppa/week-3/PPA-6.html#question",
    "href": "ppa/week-3/PPA-6.html#question",
    "title": "PPA-6",
    "section": "",
    "text": "Accept a sequence of words as input and print the the shortest word in the sequence. The input will have \\(n + 1\\) lines, where \\(n\\) denotes the number of terms in the sequence. The \\(i^{th}\\) line in the input will contain the \\(i^{th}\\) word in the sequence for \\(1 \\leq i \\leq n\\).\nThe last line of the input will always be the string abcdefghijklmnopqrstuvwxyz. This string is not a part of the sequence. You can assume that each test case corresponds to a non-empty sequence of words. If there are multiple words that have the same minimum length, print the first such occurrence."
  },
  {
    "objectID": "ppa/week-3/PPA-6.html#hint",
    "href": "ppa/week-3/PPA-6.html#hint",
    "title": "PPA-6",
    "section": "Hint",
    "text": "Hint\nThis problem is similar to the previous one. Instead of dealing with integers, we are dealing with strings here. Rather than finding the maximum number in the sequence, we need to find the word that has the shortest length. From the CT days, you also know how to find the minimum of a sequence of numbers."
  },
  {
    "objectID": "ppa/week-3/PPA-6.html#solution",
    "href": "ppa/week-3/PPA-6.html#solution",
    "title": "PPA-6",
    "section": "Solution",
    "text": "Solution\nword = input()\nmin_len = len(word)\nmin_word = word\n\nend_string = 'abcdefghijklmnopqrstuvwxyz'\nwhile word != end_string:\n    if len(word) &lt; min_len:\n        min_len = len(word)\n        min_word = word\n    word = input()\nprint(min_word)"
  },
  {
    "objectID": "ppa/week-3/PPA-8.html",
    "href": "ppa/week-3/PPA-8.html",
    "title": "PPA-8",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the first \\(n\\) integers on a line separated by a comma."
  },
  {
    "objectID": "ppa/week-3/PPA-8.html#question",
    "href": "ppa/week-3/PPA-8.html#question",
    "title": "PPA-8",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the first \\(n\\) integers on a line separated by a comma."
  },
  {
    "objectID": "ppa/week-3/PPA-8.html#hint",
    "href": "ppa/week-3/PPA-8.html#hint",
    "title": "PPA-8",
    "section": "Hint",
    "text": "Hint\nConsider the following piece of code:\nn = int(input())\n\nfor x in range(1, n + 1):\n    print(x, end = ',')\nFor an input of \\(5\\), this ends up printing 1,2,3,4,5, and the last comma is undesirable. How do we get rid of it? You can use an if-else block:\n\nIf x == n, which is the last number you are printing, then just print(x).\nIf x != n, which is any other number in the sequence, then print(x, end = ',')\n\nYou have enough information to complete the code."
  },
  {
    "objectID": "ppa/week-3/PPA-8.html#solution",
    "href": "ppa/week-3/PPA-8.html#solution",
    "title": "PPA-8",
    "section": "Solution",
    "text": "Solution\n\nSolution-1Solution-2\n\n\nn = int(input())\n\nfor x in range(1, n + 1):\n    if x != n:\n        print(x, end = ',')\n    else:\n        print(x)\n\n\nHere we stop short of the last number and print it outside the loop.\nn = int(input())\n\nfor x in range(1, n):\n    print(x, end = ',')\nprint(n)"
  },
  {
    "objectID": "ppa/week-1/PPA-3.html",
    "href": "ppa/week-1/PPA-3.html",
    "title": "PPA-3",
    "section": "",
    "text": "Accept an integer as input and print its square as output."
  },
  {
    "objectID": "ppa/week-1/PPA-3.html#question",
    "href": "ppa/week-1/PPA-3.html#question",
    "title": "PPA-3",
    "section": "",
    "text": "Accept an integer as input and print its square as output."
  },
  {
    "objectID": "ppa/week-1/PPA-3.html#hint",
    "href": "ppa/week-1/PPA-3.html#hint",
    "title": "PPA-3",
    "section": "Hint",
    "text": "Hint\nThe input function always returns a string. If you want to accept an integer from the console, you have to first accept a string and then convert it into an integer:\nword = input()\nx = int(word)   # x is now an integer\nYou could of course do it in a single line as:\nx = int(input())\nDo not get confused between the exponentiation and the multiplication operator:\n\n*: multiplication\n**: exponentiation"
  },
  {
    "objectID": "ppa/week-1/PPA-3.html#solution",
    "href": "ppa/week-1/PPA-3.html#solution",
    "title": "PPA-3",
    "section": "Solution",
    "text": "Solution\nThere is a trivial difference between the two solutions. Solution-1 introduces an intermediate variable, y, which represents the square of x and then prints it. Solution-2 does away with this intermediate variable and directly prints the square of x.\n\nSolution-1Solution-2\n\n\nx = int(input())\ny = x ** 2\nprint(y)\n\n\nx = int(input())\nprint(x ** 2)"
  },
  {
    "objectID": "ppa/week-1/PPA-7.html",
    "href": "ppa/week-1/PPA-7.html",
    "title": "PPA-7",
    "section": "",
    "text": "Accept a five digit number as input and print the sum of its digits as output."
  },
  {
    "objectID": "ppa/week-1/PPA-7.html#question",
    "href": "ppa/week-1/PPA-7.html#question",
    "title": "PPA-7",
    "section": "",
    "text": "Accept a five digit number as input and print the sum of its digits as output."
  },
  {
    "objectID": "ppa/week-1/PPA-7.html#hint",
    "href": "ppa/week-1/PPA-7.html#hint",
    "title": "PPA-7",
    "section": "Hint",
    "text": "Hint\nSometimes, it may be more beneficial to accept a string as input and not convert it into an integer right away.\nx = input()\nfirst = int(x[0])\nWhat do you think the variable first contains in the above snippet of code? Do you see how you can extend this idea to solve the problem?\nAs a second approach, we can start with \\(x\\) as an integer. Instead of processing the number from left to right, let us try to process it from right to left. How do we get the last digit of a number? The last digit is the remainder when the number is divided by \\(10\\):\nlast = x % 10\nOnce we have the last digit, we no longer need it. So, we need to remove it from \\(x\\). How do we do it? We can do floor division by \\(10\\):\nx = x // 10\nCan you complete the solution?"
  },
  {
    "objectID": "ppa/week-1/PPA-7.html#solutions",
    "href": "ppa/week-1/PPA-7.html#solutions",
    "title": "PPA-7",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nx = input()\nfirst = int(x[0])\nsecond = int(x[1])\nthird = int(x[2])\nfourth = int(x[3])\nfifth = int(x[4])\nprint(first + second + third + fourth + fifth)\n\n\nx = int(input())\nfifth = x % 10\nx = x // 10\nfourth = x % 10\nx = x // 10\nthird = x % 10\nx = x // 10\nsecond = x % 10\nx = x // 10\nfirst = x % 10\nprint(first + second + third + fourth + fifth)"
  },
  {
    "objectID": "ppa/week-1/PPA-2.html",
    "href": "ppa/week-1/PPA-2.html",
    "title": "PPA-2",
    "section": "",
    "text": "Print the following pattern.\n*\n**\n***\n****\n*****\nThere are no spaces between consecutive stars. There are no spaces at the end of each line."
  },
  {
    "objectID": "ppa/week-1/PPA-2.html#question",
    "href": "ppa/week-1/PPA-2.html#question",
    "title": "PPA-2",
    "section": "",
    "text": "Print the following pattern.\n*\n**\n***\n****\n*****\nThere are no spaces between consecutive stars. There are no spaces at the end of each line."
  },
  {
    "objectID": "ppa/week-1/PPA-2.html#hint",
    "href": "ppa/week-1/PPA-2.html#hint",
    "title": "PPA-2",
    "section": "Hint",
    "text": "Hint\nThere are two ways of solving this problem. Consider the third line of the output. We could either do it this way:\nprint('***')\nOr this way:\nprint('*' * 3)\nMultiplying a string by a number results in replication of the string. For example:\nprint('ab' * 3)\nThis gives the output:\nababab\nAs a follow up question, what do you think will happen if we multiply a string by \\(0\\)?\nprint('ab' * 0)\nAnd what about multiplying a string by a number that is not an integer?\nprint('abc' * 1.5)"
  },
  {
    "objectID": "ppa/week-1/PPA-2.html#solutions",
    "href": "ppa/week-1/PPA-2.html#solutions",
    "title": "PPA-2",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nprint('*')\nprint('**')\nprint('***')\nprint('****')\nprint('*****')\n\n\nprint('*')\nprint('*' * 2)\nprint('*' * 3)\nprint('*' * 4)\nprint('*' * 5)"
  },
  {
    "objectID": "ppa/week-5/PPA-5.html",
    "href": "ppa/week-5/PPA-5.html",
    "title": "PPA-5",
    "section": "",
    "text": "Write a function named first_three that accepts a list L of distinct integers as argument. It should return the first maximum, second maximum and third maximum in the list, in this order. You can assume that the input list will have a size of at least three. What concept in CT does this remind you of?\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-5.html#question",
    "href": "ppa/week-5/PPA-5.html#question",
    "title": "PPA-5",
    "section": "",
    "text": "Write a function named first_three that accepts a list L of distinct integers as argument. It should return the first maximum, second maximum and third maximum in the list, in this order. You can assume that the input list will have a size of at least three. What concept in CT does this remind you of?\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-5.html#hint",
    "href": "ppa/week-5/PPA-5.html#hint",
    "title": "PPA-5",
    "section": "Hint",
    "text": "Hint\nThis function returns three different values at the same time. Let us first take up a simpler example that involves two return values\ndef floor_ceil(x):\n    '''x is a positive real number'''\n    if x == int(x):\n        floor = ceil = int(x)\n    else:\n        floor = int(x)\n        ceil = floor + 1\n    return floor, ceil\nLet us call the function with some value, say floor(4.3) and see what happens:\na = floor_ceil(4.3)\nprint(a)\nIt prints the output (4, 5). This is called a tuple (refer to week-6). A tuple is very much like a list. So, when multiple values are simultaneously returned in a single return statement, what is being returned is a tuple. But, let us not worry too much about that. What is more useful is the following:\na, b = floor_ceil(4.3)\nprint(a)\nprint(b)\nSince the function returns two values, we have two variables — a, b — on the LHS of the assignment statement in line-1.\nCheck out the code below that finds out the first two maximums. Try to extend it to three maximums.\ndef first_two(L):\n    fmax, smax = L[0], L[1]\n    \n    for x in L:\n        if x &gt; fmax:\n            smax = fmax\n            fmax = x\n        elif x &gt; smax and x &lt; fmax:\n            smax = x\n    \n    return fmax, smax"
  },
  {
    "objectID": "ppa/week-5/PPA-5.html#solutions",
    "href": "ppa/week-5/PPA-5.html#solutions",
    "title": "PPA-5",
    "section": "Solutions",
    "text": "Solutions\nWe have used the fact that the elements of the list are distinct in the solution. Can you identify where it is being used? Even before that, why do you think this restriction has been imposed?\n\nSolution-1Solution-2\n\n\ndef first_three(L):\n    fmax, smax, tmax = L[0], L[1], L[2]\n    for x in L:\n        if x &gt; fmax:\n            tmax = smax\n            smax = fmax\n            fmax = x\n        elif x &gt; smax and x &lt; fmax:\n            tmax = smax\n            smax = x\n        elif x &gt; tmax and x &lt; smax:\n            tmax = x\n    return fmax, smax, tmax\n\n\ndef first_three(L):\n    fmax, smax, tmax = L[0], L[1], L[2]\n    for x in L:\n        if x &gt; fmax:\n            tmax = smax\n            smax = fmax\n            fmax = x\n        elif smax &lt; x &lt; fmax:\n            tmax = smax\n            smax = x\n        elif tmax &lt; x &lt; smax:\n            tmax = x\n    return fmax, smax, tmax"
  },
  {
    "objectID": "ppa/week-5/PPA-3.html",
    "href": "ppa/week-5/PPA-3.html",
    "title": "PPA-3",
    "section": "",
    "text": "Write a function maxval that accepts three integers a, b and c as arguments. It should return the maximum among the three numbers.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-3.html#question",
    "href": "ppa/week-5/PPA-3.html#question",
    "title": "PPA-3",
    "section": "",
    "text": "Write a function maxval that accepts three integers a, b and c as arguments. It should return the maximum among the three numbers.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-3.html#hint",
    "href": "ppa/week-5/PPA-3.html#hint",
    "title": "PPA-3",
    "section": "Hint",
    "text": "Hint\nThis function accepts three arguments and returns a single number as output. Functions can have multiple arguments and this function is an example of that. Here is a code snippet to help you solve the problem:\ndef maxval(a, b, c):\n    if (a &gt; b) and (a &gt; c):\n        return a\nThis is obviously an incomplete solution and may even be incorrect. How will you extend this to solve the entire problem? How many return statements would you have to use if you proceed along these lines? Do you require these many return statements? Can you come up with a solution that has just one return statement?"
  },
  {
    "objectID": "ppa/week-5/PPA-3.html#solution",
    "href": "ppa/week-5/PPA-3.html#solution",
    "title": "PPA-3",
    "section": "Solution",
    "text": "Solution\n\nSolution-1Solution-2Solution-3Solution-4\n\n\nNote that it is important to check for equality. Study what happens if all \\(\\geq\\) are changed to \\(&gt;\\).\ndef maxval(a, b, c):\n    if (a &gt;= b) and (a &gt;= c):\n        return a\n    elif (b &gt;= a) and (b &gt;= c):\n        return b\n    return c\n\n\nHow is this different from solution-1?\ndef maxval(a, b, c):\n    maxnum = c\n    if (a &gt;= b) and (a &gt;= c):\n        maxnum = a\n    elif (b &gt;= a) and (b &gt;= c):\n        maxnum = b\n    return maxnum\n\n\nMake \\(a\\) the largest of the three numbers by swapping it with \\(b\\) and \\(c\\) if required. What would happen if we change the second if into an elif? We don’t seem to be checking for equality here. Is that fine?\ndef maxval(a, b, c):\n    if a &lt; b:\n        a, b = b, a\n    if a &lt; c:\n        a, c = c, a\n    return a\n\n\nThis is perhaps the simplest solution.\ndef maxval(a, b, c):\n    return max(a, b, c)"
  },
  {
    "objectID": "ppa/week-5/PPA-7.html",
    "href": "ppa/week-5/PPA-7.html",
    "title": "PPA-7",
    "section": "",
    "text": "In a throwback to CT days, write the definition of the following five functions, all of which accept a list L as argument.\n\nis_empty: return True if the list is empty, and False otherwise.\nfirst: return the first element if the list is non-empty, return None otherwise.\nlast: return the last element if the list is non-empty, return None otherwise.\ninit: return the first \\(n - 1\\) elements if the list is non-empty and has size \\(n\\), return None otherwise. Note that if L has just one element, init(L) should return the empty list.\nrest: return the last \\(n - 1\\) elements if the list is non-empty and has size \\(n\\), return None otherwise. Note that if L has just one element, rest(L) should return the empty list.\n\n\nYou do not have to accept input from the user or print output to the console. You just have to write the definition of all the five functions. Each test case corresponds to one function call."
  },
  {
    "objectID": "ppa/week-5/PPA-7.html#question",
    "href": "ppa/week-5/PPA-7.html#question",
    "title": "PPA-7",
    "section": "",
    "text": "In a throwback to CT days, write the definition of the following five functions, all of which accept a list L as argument.\n\nis_empty: return True if the list is empty, and False otherwise.\nfirst: return the first element if the list is non-empty, return None otherwise.\nlast: return the last element if the list is non-empty, return None otherwise.\ninit: return the first \\(n - 1\\) elements if the list is non-empty and has size \\(n\\), return None otherwise. Note that if L has just one element, init(L) should return the empty list.\nrest: return the last \\(n - 1\\) elements if the list is non-empty and has size \\(n\\), return None otherwise. Note that if L has just one element, rest(L) should return the empty list.\n\n\nYou do not have to accept input from the user or print output to the console. You just have to write the definition of all the five functions. Each test case corresponds to one function call."
  },
  {
    "objectID": "ppa/week-5/PPA-7.html#hint",
    "href": "ppa/week-5/PPA-7.html#hint",
    "title": "PPA-7",
    "section": "Hint",
    "text": "Hint\nWe will go one function at a time:\n\nis_empty: We are going to write three different solutions for this:\n\nSolution-1\ndef is_empty(L):\n    if L == [ ]:\n        return True\n    else:\n        return False\nSolution-2\ndef is_empty(L):\n    if L == [ ]:\n        return True\n    return False\nSolution-3\ndef is_empty(L):\n    return L == [ ]\nAre all three solutions correct? Which one do you think is better?\n\nfirst: there are again three solutions that we will look at:\n\nSolution-1\ndef first(L):\n    if L == [ ]:\n        return None\n    else:\n        return L[0]\nSolution-2\ndef first(L):\n    if L == [ ]:\n        return None\n    return L[0]\nSolution-3\nHere, we are assuming that is_empty is available to us.\ndef first(L):\n    if is_empty(L):\n        return None\n    return L[0]\nAgain, look at these three solutions and try to identify which one is better.\n\nlast\n\nIs the following solution correct? If not, what do you think is wrong with it?\ndef last(L):\n    return L[-1]\n\ninit\n\ndef init(L):\n    if L == [ ]:\n        return None\n    out = [ ]\n    n = len(L)\n    for x in range(n - 1):\n        out.append(x)\n    return out\nIs there a simpler solution that doesn’t require the explicit creation of a new list out?\n\nrest\n\nThis is similar to the previous function. We just need to leave out the first element and include the rest."
  },
  {
    "objectID": "ppa/week-5/PPA-7.html#solution",
    "href": "ppa/week-5/PPA-7.html#solution",
    "title": "PPA-7",
    "section": "Solution",
    "text": "Solution\ndef is_empty(L):\n    return L == [ ]\n\ndef first(L):\n    if is_empty(L):\n        return None\n    return L[0]\n\ndef last(L):\n    if is_empty(L):\n        return None\n    return L[-1]\n\ndef init(L):\n    if is_empty(L):\n        return None\n    return L[:-1]\n\ndef rest(L):\n    if is_empty(L):\n        return None\n    return L[1: ]"
  },
  {
    "objectID": "ppa/week-5/PPA-2.html",
    "href": "ppa/week-5/PPA-2.html",
    "title": "PPA-2",
    "section": "",
    "text": "In the Gregorian calendar, a leap year has a total of \\(366\\) days instead of the usual \\(365\\) as a result of adding an extra day (February \\(29\\)) to the year. This calendar was introduced in \\(1582\\) to replace the flawed Julian calendar. The criteria given below are used to determine if a year is a leap year or not.\n\nIf a year is divisible by \\(100\\) then it will be a leap year if it is also divisible by \\(400\\).\nIf a year is not divisible by \\(100\\), then it will be a leap year if it is divisible by \\(4\\).\n\n\nWrite a function named check_leap_year that accepts a year between \\(1600\\) and \\(9999\\) as argument. It should return True if the year is a leap year and False otherwise.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-2.html#question",
    "href": "ppa/week-5/PPA-2.html#question",
    "title": "PPA-2",
    "section": "",
    "text": "In the Gregorian calendar, a leap year has a total of \\(366\\) days instead of the usual \\(365\\) as a result of adding an extra day (February \\(29\\)) to the year. This calendar was introduced in \\(1582\\) to replace the flawed Julian calendar. The criteria given below are used to determine if a year is a leap year or not.\n\nIf a year is divisible by \\(100\\) then it will be a leap year if it is also divisible by \\(400\\).\nIf a year is not divisible by \\(100\\), then it will be a leap year if it is divisible by \\(4\\).\n\n\nWrite a function named check_leap_year that accepts a year between \\(1600\\) and \\(9999\\) as argument. It should return True if the year is a leap year and False otherwise.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-2.html#hint",
    "href": "ppa/week-5/PPA-2.html#hint",
    "title": "PPA-2",
    "section": "Hint",
    "text": "Hint\nAssume that the year is not a leap year to begin with. Now use a binary variable, say leap, that is set to False to begin with. Next, use a bunch of if-else statements to update the value of leap. Finally, return leap. Just to make sure that you understand the conditions, are the following leap years?\n\n\\(1900\\)\n\\(2024\\)\n\\(2000\\)"
  },
  {
    "objectID": "ppa/week-5/PPA-2.html#solution",
    "href": "ppa/week-5/PPA-2.html#solution",
    "title": "PPA-2",
    "section": "Solution",
    "text": "Solution\ndef check_leap_year(year):\n    leap = False\n    if year % 100 == 0:\n        if year % 400 == 0:\n            leap = True\n    else:\n        if year % 4 == 0:\n            leap = True\n    return leap"
  },
  {
    "objectID": "ppa/week-5/PPA-10.html",
    "href": "ppa/week-5/PPA-10.html",
    "title": "PPA-10",
    "section": "",
    "text": "Write a function insert that accepts a sorted list L of integers and an integer x as arguments. The function should return a sorted list with the element x inserted at the right place in the input list. The original list should not be disturbed in the process.\n\n\nThe only built-in methods you are allowed to use are append and remove. You should not use any other method provided for lists.\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-10.html#question",
    "href": "ppa/week-5/PPA-10.html#question",
    "title": "PPA-10",
    "section": "",
    "text": "Write a function insert that accepts a sorted list L of integers and an integer x as arguments. The function should return a sorted list with the element x inserted at the right place in the input list. The original list should not be disturbed in the process.\n\n\nThe only built-in methods you are allowed to use are append and remove. You should not use any other method provided for lists.\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-10.html#hint",
    "href": "ppa/week-5/PPA-10.html#hint",
    "title": "PPA-10",
    "section": "Hint",
    "text": "Hint\nFor a moment, forget that this is a problem about functions. How do you approach a problem like this?\nStep-1\nWe are not deleting any elements from the input list. Clearly, the output list should have all the elements in the input list. So, let us write the skeleton of that code:\nout = [ ]\nfor elem in L:\n    out.append(elem)\nStep-2\nNow, we need to decide when to insert an element x. We start from the smallest element at the left-end of the list and keep going right. If x is less than the current elem, then this is the right place to insert x. Remember that this works only if L is sorted.\nout = [ ]\nfor elem in L:\n    if x &lt; elem:\n        out.append(x)\n    out.append(elem)\nThis seems to be a good place to stop. It looks as though we have solved the problem. So, let us just wrap this up in a function:\ndef insert(L, x):\n    out = [ ]\n    for elem in L:\n        if x &lt; elem:\n            out.append(x)\n        out.append(elem)\n    return out\nWhen we test-run this code, we find that it fails the second test case:\nout = insert([1, 3, 7, 10, 20], 8)\nprint(out)  # -&gt; [1, 3, 7, 8, 10, 8, 20]\nThe element \\(8\\) is inserted twice. So, this code is wrong, or at least incomplete. To fix this, we need to keep track of the insertion process. Once an element is inserted, we need some way of signaling that we need not insert it again. Secondly, let us run the following code and see what happens:\nout = insert([1, 3, 7, 10, 20], 22)\nprint(out)  # -&gt; [1, 3, 7, 10, 20]\nThe element \\(22\\) was not even inserted! This is the second problem with the current code. It is now left to you to figure out how to address these two deficiencies with the current solution."
  },
  {
    "objectID": "ppa/week-5/PPA-10.html#solution",
    "href": "ppa/week-5/PPA-10.html#solution",
    "title": "PPA-10",
    "section": "Solution",
    "text": "Solution\nWe maintain the state of the code in the Boolean variable inserted. This variable will remain False as long as x is not inserted into L. We iterate through through each elem of the list and check for two conditions:\n\ninserted == False\nx &lt; elem\n\nIf both conditions evaluate to True, then this is the right place to insert x. We insert it here and update inserted to True. It may so happen that inserted never becomes True even after iterating through all the elements in the list. This could happen in two situations:\n\nx is the larger than the maximum element in L\nL is empty\n\nIn both these cases, we have to get outside the loop and check if x has been inserted or not. If not, we have to insert it at the end of the output list.\ndef insert(L, x):\n    out = [ ]\n    inserted = False\n    for elem in L:\n        if (not inserted) and (x &lt; elem):\n            inserted = True\n            out.append(x)\n        out.append(elem)\n    if not inserted:\n        out.append(x)\n    return out"
  },
  {
    "objectID": "ppa/week-5/docstrings.html",
    "href": "ppa/week-5/docstrings.html",
    "title": "Docstrings",
    "section": "",
    "text": "All the function-templates that we provide the solution area in the portal have what is called a doc-string associated with them. The doc-string is a description of what the function is supposed to do. In our course, the doc string has three elements:\n\none line description of the function\narguments accepted by the function\nreturn value of the function\n\nFor example:\ndef factorial(n):\n    \"\"\"\n    computes the factorial of an integer\n    \n    Argument:\n        n: integer\n    Return:\n        result: integer\n    \"\"\"\n    # start writing code from here\nWe have seen students start populating the function before the doc-string. This is not a good practice. In the above example, the doc-string ends at line-9. The body of the function should start from line-10 and not prior to that. Also, the doc-string is not mandatory. You can go ahead and delete it. The function would still work."
  },
  {
    "objectID": "ppa.html",
    "href": "ppa.html",
    "title": "PPAs",
    "section": "",
    "text": "This section contains the practice programming problems (PPAs) used in the course organized week-wise. Each PPA has a separate page dedicated to it. There are three components to each PPA:\n\nQuestion\nHint\nSolution\n\n\n\n\n\n\n\nWarning\n\n\n\nWe earnestly request you to first attempt a question for about \\(15\\) minutes without looking at any external resource. If you are not able to make any headway, look at the hint. Spend another \\(15\\) minutes and see if you can solve the problem with the hint. If you are still not able to figure out the solution, you can refer to the one provided by us.\nIf you directly head to the solution, you are cheating yourself and you will learn NOTHING in the process. Take this as a friendly suggestion from our side, and we hope you will make the best use of this resource. Test cases will not be provided. You have to head to the portal to verify the correctness of your solution. Finally, if you are able to solve the problem yourself, congratulations. You can compare your solution with the one provided by us and learn different ways of approaching the same problem."
  },
  {
    "objectID": "students.html",
    "href": "students.html",
    "title": "Student Corner",
    "section": "",
    "text": "This page contains contributions from students of the BS program.\n\n\n\nVideo\nConcept\nAuthor\n\n\n\n\nProblem-1\nFile handling\nJanani\n\n\nProblem-2\nStrings\nJanani\n\n\nProblem-3\nRecursion\nPranav\n\n\nProblem-4\nRecursion\nJanani\n\n\nProblem-5\nMap\nPranav\n\n\nProblem-6\nDictionary and String\nJanani\n\n\nProblem-7\nList Comprehension\nPranav"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website is maintained by Karthik Thiagarajan, instructor, IIT Madras."
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "NOTES ARE STILL UNDER REVIEW"
  },
  {
    "objectID": "notes.html#chapter-0-warm-up",
    "href": "notes.html#chapter-0-warm-up",
    "title": "Notes",
    "section": "Chapter-0: Warm-up",
    "text": "Chapter-0: Warm-up\nLesson-0"
  },
  {
    "objectID": "notes.html#chapter-1-introduction-to-python",
    "href": "notes.html#chapter-1-introduction-to-python",
    "title": "Notes",
    "section": "Chapter-1: Introduction to Python",
    "text": "Chapter-1: Introduction to Python\nLesson-1.1\n\nPython shell | Replit Console\nPrompts | Output\nEmojis\nLiterals and Variables\nBasic Data types | type()\nComments\n\nLesson-1.2\n\nOperators\nConvention\nExpressions\nType of Expressions\n\nLesson-1.3\n\nArithmetic Expressions\nBoolean Expressions\n\nLesson-1.4\n\nReplit Editor\nErrors | Debugging\nExceptions\nWrong Code Snippets\n\nLesson-1.5\n\nStrings\n\nQuotes\nLength\nOperations\nEscape Characters\nSubstrings\n\n\nLesson-1.6\n\nStrings\n\nIndexing\nSlicing\nImmutability\nMethods"
  },
  {
    "objectID": "notes.html#chapter-2-conditionals",
    "href": "notes.html#chapter-2-conditionals",
    "title": "Notes",
    "section": "Chapter-2: Conditionals",
    "text": "Chapter-2: Conditionals\nLesson-2.1\n\nVariables | Assignment operator | Dynamic Typing\nReferencing versus Defining | Keywords and Naming Rules\nReusing Variables | Multiple Assignment | Deleting Variables\n\nLesson-2.2\n\nInput\nType Conversion | Built-in Functions\n\nLesson-2.3\n\nConditional Statements\n\nif\nif-else\nif-elif-else\n\nNested Conditional Statements\nDefining Variables inside if\n\nLesson-2.4\n\nSystem libraries\n\ncalendar\ntime\nthis"
  },
  {
    "objectID": "notes.html#chapter-3-loops",
    "href": "notes.html#chapter-3-loops",
    "title": "Notes",
    "section": "Chapter-3: Loops",
    "text": "Chapter-3: Loops\nLesson-3.1\n\nwhile loop\nbreak, continue\n\nLesson-3.2\n\nfor loop\nrange()\nIterating through Strings\n\nLesson-3.3\n\nNested loops\nwhile versus for\nprint\n\nend\nsep\n\n\nLesson-3.4\n\nFormatted printing\n\nf-strings\nformat()\n\nFormat Specifiers\n\nLesson-3.5\nSystem libraries\n\nmath\nrandom\n\nLesson-3.6\nMathematics and Programming\n\nLimits\nRecurrence relations\nRational approximation"
  },
  {
    "objectID": "notes.html#chapter-4-functions",
    "href": "notes.html#chapter-4-functions",
    "title": "Notes",
    "section": "Chapter-4: Functions",
    "text": "Chapter-4: Functions\nLesson-4.1\n\nIntroduction\nExamples\n\nLesson-4.2\n\nArguments\n\nPositional Arguments\nKeyword Arguments\nDefault Arguments\n\nCall by Value\n\nLesson-4.3\n\nScope\n\nLocal\nGlobal\n\nNamespaces\n\nlocals\nglobals\n\nScope and Namespaces\n\nLesson-4.4\n\nRecursion\nCaution in Recursion"
  },
  {
    "objectID": "notes.html#chapter-5-lists-and-tuples",
    "href": "notes.html#chapter-5-lists-and-tuples",
    "title": "Notes",
    "section": "Chapter-5: Lists and Tuples",
    "text": "Chapter-5: Lists and Tuples\nLesson-5.1\n\nLists\n\nIntroduction\nIterating through Lists\nGrowing a List\nOperations on Lists\nUseful Functions\n\n\nLesson-5.2\n\nLists\n\nMutability\nCall by Reference\n\n\nLesson-5.3\n\nLists\n\nSimulating an IPL Innings\n\n\nLesson-5.4\n\nLists\n\nList Methods\nStack and Queue\nStrings and Lists\n\nsplit\njoin\n\n\n\nLesson-5.5\n\nLists\n\nNested Lists\nMatrices\nShallow and Deep Copy\n\n\nLesson-5.6\n\nTuples\n\nIntroduction\nMore on Tuples\nLists and Tuples\nPacking and Unpacking"
  },
  {
    "objectID": "notes.html#chapter-6-dictionaries-and-sets",
    "href": "notes.html#chapter-6-dictionaries-and-sets",
    "title": "Notes",
    "section": "Chapter-6: Dictionaries and Sets",
    "text": "Chapter-6: Dictionaries and Sets\nLesson-6.1\n\nDictionaries\n\nIntroduction\nExamples\nIterating over Dictionaries\nGrowing a Dictionary\nMutability\n\n\nLesson-6.2\n\nText Processing\n\nNumber of Sentences\nNumber of Words\nNumber of Unique Words\nFrequent Words\n\n\nLesson-6.3\n\nDictionaries\n\nPangrams and Dictionaries\nDictionary Methods\n\n\nLesson-6.4\n\nDictionaries in Action: LMS\n\nAssignment Model\nSubmission Model\nGrader\n\n\nLesson-6.5\n\nSets\n\nIntroduction\nIterating over Sets\nGrowing Sets\nSet Operations"
  },
  {
    "objectID": "notes.html#chapter-7-file-handling",
    "href": "notes.html#chapter-7-file-handling",
    "title": "Notes",
    "section": "Chapter-7: File Handling",
    "text": "Chapter-7: File Handling\nLesson-7.1\n\nFile Handling\n\nWhy Files\nFile Handling\n\n\nLesson-7.2\n\nFile Handling\n\nCreating a file in Replit\nOpening and Reading from a file\nWriting to a file\n\n\nLesson-7.3\n\nFile Handling\n\nFile object analogy\nMode\n\n\nLesson-7.4\n\nFile Handling\n\nFile methods\n\nread\nreadline\nreadlines\nwrite\nwritelines\n\n\n\nLesson-7.5\n\nFile Handling\n\nCSV files\n\nReading a CSV file\nFiles to Collections"
  },
  {
    "objectID": "notes.html#chapter-8-object-oriented-programming",
    "href": "notes.html#chapter-8-object-oriented-programming",
    "title": "Notes",
    "section": "Chapter-8: Object Oriented Programming",
    "text": "Chapter-8: Object Oriented Programming\nLesson-8.1\n\nObjects and Classes\nOOP in Python: an example\n\nLesson-8.2\n\nClasses and Objects\nself\nClass Attributes vs Object Attributes\n\nLesson-8.3\n\nInheritance\nConcrete Example\nParent-child relationship\nMethod Overriding\n\nLesson-8.4\n\nVector: Mathematical Preliminaries\nVector: Specification\nVector: Definition\nCollection of Vectors"
  },
  {
    "objectID": "presentations/week-1.html#question",
    "href": "presentations/week-1.html#question",
    "title": "Week-1",
    "section": "Question",
    "text": "Question\nPrint the first \\(5\\) positive integers in ascending order with one number in each line."
  },
  {
    "objectID": "presentations/week-1.html#approach",
    "href": "presentations/week-1.html#approach",
    "title": "Week-1",
    "section": "Approach",
    "text": "Approach\n\nUse the print statement five times.\nOne on each line."
  },
  {
    "objectID": "presentations/week-1.html#solution",
    "href": "presentations/week-1.html#solution",
    "title": "Week-1",
    "section": "Solution",
    "text": "Solution\nprint(1)\nprint(2)\nprint(3)\nprint(4)\nprint(5)"
  },
  {
    "objectID": "presentations/week-1.html#question-2",
    "href": "presentations/week-1.html#question-2",
    "title": "Week-1",
    "section": "Question-2",
    "text": "Question-2\nPrint the following pattern.\n*\n**\n***\n****\n*****\nThere are no spaces between consecutive stars. There are no spaces at the end of each line."
  },
  {
    "objectID": "presentations/week-1.html#approach-1",
    "href": "presentations/week-1.html#approach-1",
    "title": "Week-1",
    "section": "Approach-1",
    "text": "Approach-1\n\nUse five print statements\nOne on each line."
  },
  {
    "objectID": "presentations/week-1.html#solution-1",
    "href": "presentations/week-1.html#solution-1",
    "title": "Week-1",
    "section": "Solution-1",
    "text": "Solution-1\nprint('*')\nprint('**')\nprint('***')\nprint('****')\nprint('*****')"
  },
  {
    "objectID": "presentations/week-1.html#approach-2",
    "href": "presentations/week-1.html#approach-2",
    "title": "Week-1",
    "section": "Approach-2",
    "text": "Approach-2\n\nStrings can be replicated using the * operator.\nFor example\n\n'*' * 2 == '**'\n'*' * 3 == '***'"
  },
  {
    "objectID": "presentations/week-1.html#solution-2",
    "href": "presentations/week-1.html#solution-2",
    "title": "Week-1",
    "section": "Solution-2",
    "text": "Solution-2\nprint('*')\nprint('*' * 2)\nprint('*' * 3)\nprint('*' * 4)\nprint('*' * 5)"
  },
  {
    "objectID": "presentations/week-1.html#question-1",
    "href": "presentations/week-1.html#question-1",
    "title": "Week-1",
    "section": "Question",
    "text": "Question\nAccept an integer as input and print its square as output."
  },
  {
    "objectID": "presentations/week-1.html#approach-3",
    "href": "presentations/week-1.html#approach-3",
    "title": "Week-1",
    "section": "Approach",
    "text": "Approach\n\ninput() function always returns a string.\nTo accept an integer, first accept a string and then convert it into an integer.\n* is the multiplication operator\n** is the exponentiation operator"
  },
  {
    "objectID": "presentations/week-1.html#solution-3",
    "href": "presentations/week-1.html#solution-3",
    "title": "Week-1",
    "section": "Solution",
    "text": "Solution\nx = int(input())\nprint(x ** 2)"
  },
  {
    "objectID": "presentations/week-1.html#question-3",
    "href": "presentations/week-1.html#question-3",
    "title": "Week-1",
    "section": "Question",
    "text": "Question\nAccept two integers as input and print their sum as output."
  },
  {
    "objectID": "presentations/week-1.html#approach-4",
    "href": "presentations/week-1.html#approach-4",
    "title": "Week-1",
    "section": "Approach",
    "text": "Approach\n\nInputs can be accepted on the same line.\nx, y = 2, 3\n\nx is assigned the value 2\ny is assigned the value 3"
  },
  {
    "objectID": "presentations/week-1.html#solution-4",
    "href": "presentations/week-1.html#solution-4",
    "title": "Week-1",
    "section": "Solution",
    "text": "Solution\n\nSolution-1Solution-2\n\n\nx = int(input())\ny = int(input())\nprint(x + y)\n\n\nx, y = int(input()), int(input())\nprint(x + y)"
  },
  {
    "objectID": "presentations/week-1.html#question-4",
    "href": "presentations/week-1.html#question-4",
    "title": "Week-1",
    "section": "Question",
    "text": "Question\nAccept two words as input and print the two words after adding a space between them."
  },
  {
    "objectID": "presentations/week-1.html#approach-5",
    "href": "presentations/week-1.html#approach-5",
    "title": "Week-1",
    "section": "Approach",
    "text": "Approach\n\nString concatenation\n\n'one' + 'two' == 'onetwo'\n'one' + ' ' + 'two' == 'one two'"
  },
  {
    "objectID": "presentations/week-1.html#solution-5",
    "href": "presentations/week-1.html#solution-5",
    "title": "Week-1",
    "section": "Solution",
    "text": "Solution\nfirst = input()\nsecond = input()\nspace = ' ' # there is one space between the quotes\nout = first + space + second\nprint(out)"
  },
  {
    "objectID": "presentations/week-1.html#question-5",
    "href": "presentations/week-1.html#question-5",
    "title": "Week-1",
    "section": "Question",
    "text": "Question\nAccept the registration number of a vehicle as input and print its state-code as output. Sample registration numbers:\n\nTN-10-AB-2010\nHR-15-XZ-1999\n\nThe template for registration numbers will be the same."
  },
  {
    "objectID": "presentations/week-1.html#approach-6",
    "href": "presentations/week-1.html#approach-6",
    "title": "Week-1",
    "section": "Approach",
    "text": "Approach\n\nString slicing\n\nword = 'ABCD'\nword[0:2] == 'AB'\nword[:2] == 'AB'"
  },
  {
    "objectID": "presentations/week-1.html#solutions",
    "href": "presentations/week-1.html#solutions",
    "title": "Week-1",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nregno = input()\ncode = regno[0:2]\nprint(code)\n\n\nregno = input()\ncode = regno[:2]\nprint(code)"
  },
  {
    "objectID": "presentations/week-1.html#question-6",
    "href": "presentations/week-1.html#question-6",
    "title": "Week-1",
    "section": "Question",
    "text": "Question\nAccept a five digit number as input and print the sum of its digits as output."
  },
  {
    "objectID": "presentations/week-1.html#approach-1-1",
    "href": "presentations/week-1.html#approach-1-1",
    "title": "Week-1",
    "section": "Approach-1",
    "text": "Approach-1\n\nRetain input as a string.\nConvert each character of the string into an integer.\n\nIf num = '12345'\n\nint(num[0]) == 1\nint(num[1]) == 2\n…\n\n\nFinally, add all these digits."
  },
  {
    "objectID": "presentations/week-1.html#solution-1-3",
    "href": "presentations/week-1.html#solution-1-3",
    "title": "Week-1",
    "section": "Solution-1",
    "text": "Solution-1\nx = input()\nfirst = int(x[0])\nsecond = int(x[1])\nthird = int(x[2])\nfourth = int(x[3])\nfifth = int(x[4])\nprint(first + second + third + fourth + fifth)"
  },
  {
    "objectID": "presentations/week-1.html#approach-2-1",
    "href": "presentations/week-1.html#approach-2-1",
    "title": "Week-1",
    "section": "Approach-2",
    "text": "Approach-2\n\nStep-1\n\nExtract the last digit of the number by taking remainder when it is divided by \\(10\\).\n\nIf x = 12345, then x % 10 == 5.\n\n\nStep-2\n\nDivide the number by \\(10\\) and retain the quotient.\n\nIf x = 12345, then x // 10 == 1234.\n\n\nRepeat steps 1 and 2 five times\nFinally, sum all the digits."
  },
  {
    "objectID": "presentations/week-1.html#solution-2-3",
    "href": "presentations/week-1.html#solution-2-3",
    "title": "Week-1",
    "section": "Solution-2",
    "text": "Solution-2\nx = int(input())\nfifth = x % 10\nx = x // 10\nfourth = x % 10\nx = x // 10\nthird = x % 10\nx = x // 10\nsecond = x % 10\nx = x // 10\nfirst = x % 10\nprint(first + second + third + fourth + fifth)"
  },
  {
    "objectID": "presentations.html",
    "href": "presentations.html",
    "title": "Presentations",
    "section": "",
    "text": "This is a collection of presentations."
  },
  {
    "objectID": "ppa/week-5/PPA-8.html",
    "href": "ppa/week-5/PPA-8.html",
    "title": "PPA-8",
    "section": "",
    "text": "Write a recursive function named fibo that accepts a positive integer \\(n\\) as argument and returns the \\(n^{\\text{th}}\\) Fibonacci number. For this problem, \\(F_1 = F_2 = 1\\) are the first two Fibonacci numbers.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-8.html#question",
    "href": "ppa/week-5/PPA-8.html#question",
    "title": "PPA-8",
    "section": "",
    "text": "Write a recursive function named fibo that accepts a positive integer \\(n\\) as argument and returns the \\(n^{\\text{th}}\\) Fibonacci number. For this problem, \\(F_1 = F_2 = 1\\) are the first two Fibonacci numbers.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-8.html#hint",
    "href": "ppa/week-5/PPA-8.html#hint",
    "title": "PPA-8",
    "section": "Hint",
    "text": "Hint\nEvery recursive function has two parts:\n\nrecursive call\nbase case\n\nIf \\(F_n\\) is the \\(n^{th}\\) Fibonacci number, we have: \\[\nF_n = F_{n - 1} + F_{n - 2}\n\\] In Pythonic terms, if \\(\\text{fibo}\\) is a Python function that returns the \\(n^{th}\\) Fibonacci number, then, we can express it as: \\[\n\\text{fibo}(n - 1) + \\text{fibo}(n - 2)\n\\] This is what \\(\\text{fibo}(n)\\) should return and will be our recursive call. The base case of the recursion is based on the fact that \\(F_1 = F_2 = 1\\). This is done using a simple if-condition."
  },
  {
    "objectID": "ppa/week-5/PPA-8.html#solution",
    "href": "ppa/week-5/PPA-8.html#solution",
    "title": "PPA-8",
    "section": "Solution",
    "text": "Solution\ndef fibo(n):\n    if n &lt;= 2:\n        return 1\n    return fibo(n - 1) + fibo(n - 2)"
  },
  {
    "objectID": "ppa/week-5/PPA-6.html",
    "href": "ppa/week-5/PPA-6.html",
    "title": "PPA-6",
    "section": "",
    "text": "A class of English words is called mysterious if it satisfies certain conditions. These conditions are hidden from you. Instead, you are given a function named mysterious that accepts a word as argument and returns True if the word is mysterious and False otherwise.\n\nWrite a function named type_of_sequence that accepts a list of words as an argument. Its return value is a string that depends on the number of mysterious words in the sequence. The exact conditions are given in the following table. If \\(k\\) denotes the number of mysterious words in the sequence, then:\n\n\n\n\n\n\n\n\\(k\\)\nReturn value\n\n\n\n\nLess than \\(2\\)\nmildly mysterious\n\n\nGreater than or equal to \\(2\\) but less than \\(5\\)\nmoderately mysterious\n\n\nGreater than or equal to \\(5\\)\nmost mysterious\n\n\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-6.html#question",
    "href": "ppa/week-5/PPA-6.html#question",
    "title": "PPA-6",
    "section": "",
    "text": "A class of English words is called mysterious if it satisfies certain conditions. These conditions are hidden from you. Instead, you are given a function named mysterious that accepts a word as argument and returns True if the word is mysterious and False otherwise.\n\nWrite a function named type_of_sequence that accepts a list of words as an argument. Its return value is a string that depends on the number of mysterious words in the sequence. The exact conditions are given in the following table. If \\(k\\) denotes the number of mysterious words in the sequence, then:\n\n\n\n\n\n\n\n\\(k\\)\nReturn value\n\n\n\n\nLess than \\(2\\)\nmildly mysterious\n\n\nGreater than or equal to \\(2\\) but less than \\(5\\)\nmoderately mysterious\n\n\nGreater than or equal to \\(5\\)\nmost mysterious\n\n\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-6.html#hint",
    "href": "ppa/week-5/PPA-6.html#hint",
    "title": "PPA-6",
    "section": "Hint",
    "text": "Hint\nThe takeaways from this question are twofold:\n\nthe use of functions in expressions\nthe use of function calls within other functions.\n\nLet us first take up a simpler example:\ndef is_square(x):\n    root = int(x ** 0.5)\n    return root * root == x\nIf we want to print all square numbers in a list L of positive integers, this is how we would do it:\n# L is a list of positive integers\nfor elem in L:\n    if is_square(elem):\n        print(elem)\nThe point to note here is line-3. The function call is a part of a conditional statement. Whenever the interpreter comes across a function call, it is going to go ahead and execute that function first. Once this execution is complete, it will come back to the place from which the function was called.\nis_square(elem) is a function call. After evaluating the function with the argument elem, the expression is_square(elem) will finally be just a Boolean value: True or False. After the function is successfully executed, the returned value is just treated like any other Python expression.\n\nTo illustrate the second point — calling functions from within other functions — we will study the current question:\ndef type_of_sequence(L):\n    count = 0\n    for word in L:\n        if mysterious(word):\n            count += 1\n            \n    ## Complete the rest of the code ##\nNote how we use the function call mysterious(word) inside another function type_of_sequence. The code snippet given above is incomplete. You have most of the information needed to complete it."
  },
  {
    "objectID": "ppa/week-5/PPA-6.html#solution",
    "href": "ppa/week-5/PPA-6.html#solution",
    "title": "PPA-6",
    "section": "Solution",
    "text": "Solution\ndef type_of_sequence(words):\n    count = 0\n    for word in words:\n        if mysterious(word):\n            count += 1\n\n    if count &lt; 2:\n        return 'mildly mysterious'\n    elif 2 &lt;= count &lt; 5:\n        return 'moderately mysterious'\n    else:\n        return 'most mysterious'"
  },
  {
    "objectID": "ppa/week-5/PPA-4.html",
    "href": "ppa/week-5/PPA-4.html",
    "title": "PPA-4",
    "section": "",
    "text": "Write a function named dim_equal that accepts two matrices A and B as arguments. It should return True if the dimensions of both matrices are the same and False otherwise.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-4.html#question",
    "href": "ppa/week-5/PPA-4.html#question",
    "title": "PPA-4",
    "section": "",
    "text": "Write a function named dim_equal that accepts two matrices A and B as arguments. It should return True if the dimensions of both matrices are the same and False otherwise.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-4.html#hint",
    "href": "ppa/week-5/PPA-4.html#hint",
    "title": "PPA-4",
    "section": "Hint",
    "text": "Hint\nConsider the following solution to this problem:\ndef dim_equal(A, B):\n    dim_A = len(A)\n    dim_B = len(B)\n    return dim_A == dim_B\nDo you think this solution is correct? Does it pass all the test cases? What is it missing? For what inputs will it fail?"
  },
  {
    "objectID": "ppa/week-5/PPA-4.html#solution",
    "href": "ppa/week-5/PPA-4.html#solution",
    "title": "PPA-4",
    "section": "Solution",
    "text": "Solution\n\nSolution-1Solution-2Solution-3\n\n\ndef dim_equal(A, B):\n    m_A, n_A = len(A), len(A[0])\n    m_B, n_B = len(B), len(B[0])\n    if (m_A == m_B) and (n_A == n_B):\n        return True\n    return False\n\n\ndef dim_equal(A, B):\n    if ((len(A) == len(B)) and \n        (len(A[0]) == len(B[0]))):\n        return True\n    return False\n\n\ndef dim_equal(A, B):\n    return ((len(A) == len(B)) and\n            (len(A[0]) == len(B[0])))"
  },
  {
    "objectID": "ppa/week-5/PPA-1.html",
    "href": "ppa/week-5/PPA-1.html",
    "title": "PPA-1",
    "section": "",
    "text": "The factorial is a positive integer \\(n\\) is the product of the first \\(n\\) positive integers.\n\nWrite a function named factorial that accepts an integer n as argument. It should return the factorial of n if n is a positive integer. It should return \\(-1\\) if n is a negative integer, and it should return \\(1\\) if n is zero.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-1.html#question",
    "href": "ppa/week-5/PPA-1.html#question",
    "title": "PPA-1",
    "section": "",
    "text": "The factorial is a positive integer \\(n\\) is the product of the first \\(n\\) positive integers.\n\nWrite a function named factorial that accepts an integer n as argument. It should return the factorial of n if n is a positive integer. It should return \\(-1\\) if n is a negative integer, and it should return \\(1\\) if n is zero.\n\nYou do not have to accept input from the user or print output to the console. You just have to write the function definition."
  },
  {
    "objectID": "ppa/week-5/PPA-1.html#hint",
    "href": "ppa/week-5/PPA-1.html#hint",
    "title": "PPA-1",
    "section": "Hint",
    "text": "Hint\nThe main takeaway from this problem is the way functions behave when there are multiple return statements. Let us take a simpler example to begin with.\ndef odd_even(n):\n    if n % 2 == 0:\n        return 'even'\n    return 'odd'\nIn any function that has multiple return statements, exactly one of them will be executed. The moment a return statement is executed, control exits from the function. The function odd_even given above has two return statements. When \\(n\\) is even, the return statement in line-3 will be executed. If \\(n\\) is not even, then the return statement in line-4 will be executed. Now, we come to the factorial function. This has three return statements. The body of the function is simple enough and you should be able to fill it."
  },
  {
    "objectID": "ppa/week-5/PPA-1.html#solution",
    "href": "ppa/week-5/PPA-1.html#solution",
    "title": "PPA-1",
    "section": "Solution",
    "text": "Solution\ndef factorial(n):\n    if n &lt; 0:\n        return -1\n    if n == 0:\n        return 1\n    fact = 1\n    for x in range(1, n + 1):\n        fact = fact * x\n    return fact\nNotice the type of function. This function has a single argument and single return value."
  },
  {
    "objectID": "ppa/week-5/PPA-9.html",
    "href": "ppa/week-5/PPA-9.html",
    "title": "PPA-9",
    "section": "",
    "text": "Implement the following functions:\n\nWrite a function named get_column that accepts a matrix named mat and a non-negative integer named col as arguments. It should return the column that is at index col in the matrix mat as a list. Zero-based indexing is used here.\nWrite a function named get_row that accepts a matrix named mat and a non-negative integer named row as arguments. It should return the row that is at index row in the matrix mat as a list. Zero-based indexing is used here.\n\n\nYou do not have to accept input from the user or print output to the console. You just have to write the definition of both the functions."
  },
  {
    "objectID": "ppa/week-5/PPA-9.html#question",
    "href": "ppa/week-5/PPA-9.html#question",
    "title": "PPA-9",
    "section": "",
    "text": "Implement the following functions:\n\nWrite a function named get_column that accepts a matrix named mat and a non-negative integer named col as arguments. It should return the column that is at index col in the matrix mat as a list. Zero-based indexing is used here.\nWrite a function named get_row that accepts a matrix named mat and a non-negative integer named row as arguments. It should return the row that is at index row in the matrix mat as a list. Zero-based indexing is used here.\n\n\nYou do not have to accept input from the user or print output to the console. You just have to write the definition of both the functions."
  },
  {
    "objectID": "ppa/week-5/PPA-9.html#hint",
    "href": "ppa/week-5/PPA-9.html#hint",
    "title": "PPA-9",
    "section": "Hint",
    "text": "Hint\nSuch functions are extremely useful. They play the role of helper functions. When a problem is broken down into smaller parts, these helper functions will come in handy while solving the sub-problems. You should make it a point to practice writing these functions as many times as possible.\nTo extract a row, iterate through the columns of the matrix. Fix the row index, the first index of the matrix, and vary the column index, the second index, from \\(0\\) to the \\(n - 1\\), where there are \\(n\\) columns in the matrix. A similar operation is required for extracting a column of the matrix."
  },
  {
    "objectID": "ppa/week-5/PPA-9.html#solutions",
    "href": "ppa/week-5/PPA-9.html#solutions",
    "title": "PPA-9",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\ndef get_row(mat, row):\n    row_list = [ ]\n    n = len(mat[0])\n    for col in range(n):\n        row_list.append(mat[row][col])\n    return row_list\n\ndef get_column(mat, col):\n    col_list = [ ]\n    m = len(mat)\n    for row in range(m):\n        col_list.append(mat[row][col])\n    return col_list\n\n\nSince each inner list of mat is one row of the matrix, we can directly extract the given row by indexing into mat.\ndef get_row(mat, row):\n    return mat[row]\n\ndef get_column(mat, col):\n    col_list = [ ]\n    m = len(mat)\n    for row in range(m):\n        col_list.append(mat[row][col])\n    return col_list"
  },
  {
    "objectID": "ppa/week-1/PPA-6.html",
    "href": "ppa/week-1/PPA-6.html",
    "title": "PPA-6",
    "section": "",
    "text": "Accept the registration number of a vehicle as input and print its state-code as output. Sample registration numbers:\n\nTN-10-AB-2010\nHR-15-XZ-1999\n\nThe template for registration numbers will be the same."
  },
  {
    "objectID": "ppa/week-1/PPA-6.html#question",
    "href": "ppa/week-1/PPA-6.html#question",
    "title": "PPA-6",
    "section": "",
    "text": "Accept the registration number of a vehicle as input and print its state-code as output. Sample registration numbers:\n\nTN-10-AB-2010\nHR-15-XZ-1999\n\nThe template for registration numbers will be the same."
  },
  {
    "objectID": "ppa/week-1/PPA-6.html#hint",
    "href": "ppa/week-1/PPA-6.html#hint",
    "title": "PPA-6",
    "section": "Hint",
    "text": "Hint\nSlice the string. Where to start the slice and where to end it? This is something you have to figure out after looking at the test-cases."
  },
  {
    "objectID": "ppa/week-1/PPA-6.html#solutions",
    "href": "ppa/week-1/PPA-6.html#solutions",
    "title": "PPA-6",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nregno = input()\ncode = regno[0:2]\nprint(code)\n\n\nregno = input()\ncode = regno[:2]\nprint(code)"
  },
  {
    "objectID": "ppa/week-1/PPA-4.html",
    "href": "ppa/week-1/PPA-4.html",
    "title": "PPA-4",
    "section": "",
    "text": "Accept two integers as input and print their sum as output."
  },
  {
    "objectID": "ppa/week-1/PPA-4.html#question",
    "href": "ppa/week-1/PPA-4.html#question",
    "title": "PPA-4",
    "section": "",
    "text": "Accept two integers as input and print their sum as output."
  },
  {
    "objectID": "ppa/week-1/PPA-4.html#hint",
    "href": "ppa/week-1/PPA-4.html#hint",
    "title": "PPA-4",
    "section": "Hint",
    "text": "Hint\nWe can accept multiple inputs on the same line:\nx, y = int(input()), int(input())"
  },
  {
    "objectID": "ppa/week-1/PPA-4.html#solutions",
    "href": "ppa/week-1/PPA-4.html#solutions",
    "title": "PPA-4",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nx = int(input())\ny = int(input())\nprint(x + y)\n\n\nx, y = int(input()), int(input())\nprint(x + y)"
  },
  {
    "objectID": "ppa/week-1/PPA-1.html",
    "href": "ppa/week-1/PPA-1.html",
    "title": "PPA-1",
    "section": "",
    "text": "Print the first \\(5\\) positive integers in ascending order with one number in each line."
  },
  {
    "objectID": "ppa/week-1/PPA-1.html#question",
    "href": "ppa/week-1/PPA-1.html#question",
    "title": "PPA-1",
    "section": "",
    "text": "Print the first \\(5\\) positive integers in ascending order with one number in each line."
  },
  {
    "objectID": "ppa/week-1/PPA-1.html#hint",
    "href": "ppa/week-1/PPA-1.html#hint",
    "title": "PPA-1",
    "section": "Hint",
    "text": "Hint\nExecute the following lines and study the output.\nprint(1)\nprint(2)"
  },
  {
    "objectID": "ppa/week-1/PPA-1.html#solution",
    "href": "ppa/week-1/PPA-1.html#solution",
    "title": "PPA-1",
    "section": "Solution",
    "text": "Solution\nprint(1)\nprint(2)\nprint(3)\nprint(4)\nprint(5)"
  },
  {
    "objectID": "ppa/week-1/PPA-5.html",
    "href": "ppa/week-1/PPA-5.html",
    "title": "PPA-5",
    "section": "",
    "text": "Accept two words as input and print the two words after adding a space between them."
  },
  {
    "objectID": "ppa/week-1/PPA-5.html#question",
    "href": "ppa/week-1/PPA-5.html#question",
    "title": "PPA-5",
    "section": "",
    "text": "Accept two words as input and print the two words after adding a space between them."
  },
  {
    "objectID": "ppa/week-1/PPA-5.html#hint",
    "href": "ppa/week-1/PPA-5.html#hint",
    "title": "PPA-5",
    "section": "Hint",
    "text": "Hint\nString concatenation is a good place to start:\nfirst = 'one'\nsecond = 'two'\nprint(first + second)\nThe output is:\nonetwo\nHow do you modify the code so that there is a space between one and two? This is something for you to think about."
  },
  {
    "objectID": "ppa/week-1/PPA-5.html#solutions",
    "href": "ppa/week-1/PPA-5.html#solutions",
    "title": "PPA-5",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2Solution-3\n\n\nfirst = input()\nsecond = input()\nspace = ' ' # there is one space between the quotes\nout = first + space + second\nprint(out)\n\n\nThe print function adds space as a default separator when multiple arguments are passed to it.\nfirst = input()\nsecond = input()\nprint(first, second)\n\n\nHere, we are explicitly specifying the separator to be space.\nfirst = input()\nsecond = input()\nprint(first, second, sep = ' ') # one space between the quotes"
  },
  {
    "objectID": "ppa/week-3/PPA-10.html",
    "href": "ppa/week-3/PPA-10.html",
    "title": "PPA-10",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the sum of all prime numbers in the range \\([1, n]\\), endpoints inclusive. If there are no prime numbers in the given range, then print 0."
  },
  {
    "objectID": "ppa/week-3/PPA-10.html#question",
    "href": "ppa/week-3/PPA-10.html#question",
    "title": "PPA-10",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the sum of all prime numbers in the range \\([1, n]\\), endpoints inclusive. If there are no prime numbers in the given range, then print 0."
  },
  {
    "objectID": "ppa/week-3/PPA-10.html#hint",
    "href": "ppa/week-3/PPA-10.html#hint",
    "title": "PPA-10",
    "section": "Hint",
    "text": "Hint\nYou already know how to find if a number is prime or not. Refer to PPA-4 if you have forgotten this. Now, all that you need is a nested loop, where you go over all numbers in the given range, check if each one is a prime or not, and just add those numbers that are primes."
  },
  {
    "objectID": "ppa/week-3/PPA-10.html#solution",
    "href": "ppa/week-3/PPA-10.html#solution",
    "title": "PPA-10",
    "section": "Solution",
    "text": "Solution\nn = int(input())\ntotal = 0\n\nfor x in range(2, n + 1):\n    is_prime = True\n    for f in range(2, x):\n        if (x % f == 0):\n            is_prime = False\n            break\n    if is_prime:\n        total = total + x\n    \nprint(total)"
  },
  {
    "objectID": "ppa/week-3/PPA-2.html",
    "href": "ppa/week-3/PPA-2.html",
    "title": "PPA-2",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print all the factors of \\(n\\), one number on each line."
  },
  {
    "objectID": "ppa/week-3/PPA-2.html#question",
    "href": "ppa/week-3/PPA-2.html#question",
    "title": "PPA-2",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print all the factors of \\(n\\), one number on each line."
  },
  {
    "objectID": "ppa/week-3/PPA-2.html#hint",
    "href": "ppa/week-3/PPA-2.html#hint",
    "title": "PPA-2",
    "section": "Hint",
    "text": "Hint\nGiven a number \\(n\\), a number \\(f\\) is its factor if \\(n\\) is divisible by \\(f\\). We know that \\(n\\) is divisible by \\(f\\) if the remainder when \\(n\\) is divided by \\(f\\) is \\(0\\). In Python, we have the \\(\\%\\) operator for getting the remainder:\nif n % f == 0:\n    print('a factor')\nelse:\n    print('not a factor')\nThe above snippet is of course just checking if a number \\(f\\) is a factor of \\(n\\) or not. Use the key idea in this snippet to come up with a complete solution to this problem. What is the range of values that you will have to check for \\(f\\), the loop-variable in this case?\nAn important point concerning the choice of variable names. i or j as the name for a loop variable is too generic for most problems. Reserve i and j for indices of strings and lists (we will study this next week). For this problem, f is a good choice because we need to find the factors of a number. The loop variable could also have more descriptive names, two of which are given below:\n\nfact\nfactor\n\nAt the same time, avoid excessively long names. For example, factor_of_n is unnecessarily elaborate. Note that any valid variable name would do and would give the same output, but in the interest of writing readable code, we strongly urge you to be a little more mindful in picking “good” names."
  },
  {
    "objectID": "ppa/week-3/PPA-2.html#solution",
    "href": "ppa/week-3/PPA-2.html#solution",
    "title": "PPA-2",
    "section": "Solution",
    "text": "Solution\nn = int(input())\nfor f in range(1, n + 1):\n    if n % f == 0:\n        print(f)"
  },
  {
    "objectID": "ppa/week-3/PPA-12.html",
    "href": "ppa/week-3/PPA-12.html",
    "title": "PPA-12",
    "section": "",
    "text": "Accept two strings as input and form a new string by removing all characters from the second string which are present in the first string. Print this new string as output. You can assume that all input strings will be in lower case."
  },
  {
    "objectID": "ppa/week-3/PPA-12.html#question",
    "href": "ppa/week-3/PPA-12.html#question",
    "title": "PPA-12",
    "section": "",
    "text": "Accept two strings as input and form a new string by removing all characters from the second string which are present in the first string. Print this new string as output. You can assume that all input strings will be in lower case."
  },
  {
    "objectID": "ppa/week-3/PPA-12.html#hint",
    "href": "ppa/week-3/PPA-12.html#hint",
    "title": "PPA-12",
    "section": "Hint",
    "text": "Hint\nIterating over strings can be done in two ways:\nword = 'abcdef'\nfor char in word:\n    print(char)\nThis is the recommended way of iterating over a string. Here, we directly get hold of each character in the string without resorting to the use of string-indices. The other way uses string-indices:\nword = 'abcdef'\nfor i in range(len(word)):\n    print(word[i])\nThough this is not a wrong approach, this is not appropriate for this problem. The index-based approach should be used only if we need to know the character along with its index. In this problem, we are not interested in the index at all, we only need to know the characters present in the string.\nTo check if a character is present in a string or not, we can simply use the in operator. For example:\nif 'a' in 'abcde':\n    print(True)\nelse:\n    print(False)\nYou have enough information to construct a solution."
  },
  {
    "objectID": "ppa/week-3/PPA-12.html#solution",
    "href": "ppa/week-3/PPA-12.html#solution",
    "title": "PPA-12",
    "section": "Solution",
    "text": "Solution\nThis solution iterates over string_2. It adds characters to out if they are not present in string_1.\nstring_1 = input()\nstring_2 = input()\n\nout = '' # empty string\nfor char in string_2:\n    if char not in string_1:\n        out = out + char\n\nprint(out)"
  },
  {
    "objectID": "ppa/week-3/PPA-1.html",
    "href": "ppa/week-3/PPA-1.html",
    "title": "PPA-1",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the first \\(n\\) positive integers, one number on each line."
  },
  {
    "objectID": "ppa/week-3/PPA-1.html#question",
    "href": "ppa/week-3/PPA-1.html#question",
    "title": "PPA-1",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print the first \\(n\\) positive integers, one number on each line."
  },
  {
    "objectID": "ppa/week-3/PPA-1.html#hint",
    "href": "ppa/week-3/PPA-1.html#hint",
    "title": "PPA-1",
    "section": "Hint",
    "text": "Hint\nWhich loop should we use here, while or for?\nIf we go with a for loop, is the following solution correct?\nn = int(input())\nfor x in range(n):\n    print(x)\nIf it is not correct, then what is the mistake?"
  },
  {
    "objectID": "ppa/week-3/PPA-1.html#solutions",
    "href": "ppa/week-3/PPA-1.html#solutions",
    "title": "PPA-1",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nn = int(input())\nk = 1\nwhile k &lt;= n:\n    print(k)\n    k += 1\n\n\nn = int(input())\nfor x in range(1, n + 1):\n    print(x)"
  },
  {
    "objectID": "ppa/week-3/PPA-9.html",
    "href": "ppa/week-3/PPA-9.html",
    "title": "PPA-9",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print a triangle of zeros for \\(n\\) lines. The \\(i^{th}\\) line should have \\(i\\) zeros. There shouldn’t be any spaces between consecutive zeros. Do not print a space at the end of a line."
  },
  {
    "objectID": "ppa/week-3/PPA-9.html#question",
    "href": "ppa/week-3/PPA-9.html#question",
    "title": "PPA-9",
    "section": "",
    "text": "Accept a positive integer \\(n\\) as input and print a triangle of zeros for \\(n\\) lines. The \\(i^{th}\\) line should have \\(i\\) zeros. There shouldn’t be any spaces between consecutive zeros. Do not print a space at the end of a line."
  },
  {
    "objectID": "ppa/week-3/PPA-9.html#hint",
    "href": "ppa/week-3/PPA-9.html#hint",
    "title": "PPA-9",
    "section": "Hint",
    "text": "Hint\nA nested loop is one way to solve the problem. What should be the ranges for the outer and inner for loops? How many rows are we printing? In each row, how many zeros are we printing? To move to the next row, just use print().\nThere is a way to solve the problem using a single loop. A hint is given below:\n\nstring\ninteger\nmultiplication\n\nHow can you use a combination of the three terms mentioned here to construct a solution?"
  },
  {
    "objectID": "ppa/week-3/PPA-9.html#solutions",
    "href": "ppa/week-3/PPA-9.html#solutions",
    "title": "PPA-9",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nn = int(input())\nfor i in range(1, n + 1):\n    for j in range(1, i + 1):\n        print('0', end = '')\n    print()\n\n\nn = int(input())\nfor i in range(1, n + 1):\n    print('0' * i)"
  },
  {
    "objectID": "ppa/week-3/PPA-5.html",
    "href": "ppa/week-3/PPA-5.html",
    "title": "PPA-5",
    "section": "",
    "text": "Accept a sequence of positive integers as input and print the the maximum number in the sequence. The input will have \\(n + 1\\) lines, where \\(n\\) denotes the number of terms in the sequence. The \\(i^{th}\\) line in the input will contain the \\(i^{th}\\) term in the sequence for \\(1 \\leq i \\leq n\\). The last line of the input will always be the number 0. Each test case will have at least one term in the sequence."
  },
  {
    "objectID": "ppa/week-3/PPA-5.html#question",
    "href": "ppa/week-3/PPA-5.html#question",
    "title": "PPA-5",
    "section": "",
    "text": "Accept a sequence of positive integers as input and print the the maximum number in the sequence. The input will have \\(n + 1\\) lines, where \\(n\\) denotes the number of terms in the sequence. The \\(i^{th}\\) line in the input will contain the \\(i^{th}\\) term in the sequence for \\(1 \\leq i \\leq n\\). The last line of the input will always be the number 0. Each test case will have at least one term in the sequence."
  },
  {
    "objectID": "ppa/week-3/PPA-5.html#hint",
    "href": "ppa/week-3/PPA-5.html#hint",
    "title": "PPA-5",
    "section": "Hint",
    "text": "Hint\nYou have to keep accepting input from the console until it is zero. Since the number of iterations is not known a priori, a while loop is the better choice. The next step is to accept the first input outside the while loop and store it in a variable named t. Now, keep accepting inputs inside the while loop. The termination condition for the loop is t == 0. So, keep running the loop as long as t != 0.\nt = int(input())\nwhile t != 0:\n    t = int(input())\nWith this information, can you now insert the piece of code for finding the maximum number in the sequence? You have seen it so many times in the CT course."
  },
  {
    "objectID": "ppa/week-3/PPA-5.html#solution",
    "href": "ppa/week-3/PPA-5.html#solution",
    "title": "PPA-5",
    "section": "Solution",
    "text": "Solution\nt = int(input())\nmax_t = t\nwhile t != 0:\n    if t &gt; max_t:\n        max_t = t\n    t = int(input())\nprint(max_t)"
  },
  {
    "objectID": "ppa/week-2/PPA-10.html",
    "href": "ppa/week-2/PPA-10.html",
    "title": "PPA-10",
    "section": "",
    "text": "Accept a real number \\(x\\) as input and print the greatest integer less than or equal to \\(x\\) on the first line, followed by the smallest integer greater than or equal to \\(x\\) on the second line."
  },
  {
    "objectID": "ppa/week-2/PPA-10.html#question",
    "href": "ppa/week-2/PPA-10.html#question",
    "title": "PPA-10",
    "section": "",
    "text": "Accept a real number \\(x\\) as input and print the greatest integer less than or equal to \\(x\\) on the first line, followed by the smallest integer greater than or equal to \\(x\\) on the second line."
  },
  {
    "objectID": "ppa/week-2/PPA-10.html#hint",
    "href": "ppa/week-2/PPA-10.html#hint",
    "title": "PPA-10",
    "section": "Hint",
    "text": "Hint\nThe crux of this problem is to look at three cases, two of which are given below:\n\nWhat happens when \\(x\\) is positive?\nWhat happens when \\(x\\) is negative?\n\nHere is another hint:\nf = int(3.3)\nprint(f)\nint(3.3) retains the integer part while truncating whatever comes after the decimal, including the decimal point. Try out the following:\nf = int(-3.3)\nprint(f)\nCan you now go ahead and construct a solution for this problem? These are the floor and ceiling functions that we study in mathematics. Why do you think these functions have been named in this manner?"
  },
  {
    "objectID": "ppa/week-2/PPA-10.html#solution",
    "href": "ppa/week-2/PPA-10.html#solution",
    "title": "PPA-10",
    "section": "Solution",
    "text": "Solution\nx = float(input())\n\nif x == int(x):\n    floor = ceil = int(x)\nelif x &gt; 0:\n    floor = int(x)\n    ceil = floor + 1\nelif x &lt; 0:\n    ceil = int(x)\n    floor = ceil - 1\n\nprint(floor)\nprint(ceil)"
  },
  {
    "objectID": "ppa/week-2/PPA-2.html",
    "href": "ppa/week-2/PPA-2.html",
    "title": "PPA-2",
    "section": "",
    "text": "Consider the piece-wise function given below.\n\\[\nf(x) = \\left\\{\n        \\begin{array}{ll}\n            x + 2 & \\quad 0 &lt; x &lt; 10 \\\\\n            x^2 + 2 & \\quad 10 \\leq x \\\\\n            0 & \\quad \\text{otherwise}\n        \\end{array}\n    \\right.\n\\]\nAccept the value of \\(x\\) as input and print the value of \\(f(x)\\) as output. Note that both the input and output are real numbers. Your code should reflect this aspect. That is, both \\(x\\) and \\(f(x)\\) should be float values."
  },
  {
    "objectID": "ppa/week-2/PPA-2.html#question",
    "href": "ppa/week-2/PPA-2.html#question",
    "title": "PPA-2",
    "section": "",
    "text": "Consider the piece-wise function given below.\n\\[\nf(x) = \\left\\{\n        \\begin{array}{ll}\n            x + 2 & \\quad 0 &lt; x &lt; 10 \\\\\n            x^2 + 2 & \\quad 10 \\leq x \\\\\n            0 & \\quad \\text{otherwise}\n        \\end{array}\n    \\right.\n\\]\nAccept the value of \\(x\\) as input and print the value of \\(f(x)\\) as output. Note that both the input and output are real numbers. Your code should reflect this aspect. That is, both \\(x\\) and \\(f(x)\\) should be float values."
  },
  {
    "objectID": "ppa/week-2/PPA-2.html#hint",
    "href": "ppa/week-2/PPA-2.html#hint",
    "title": "PPA-2",
    "section": "Hint",
    "text": "Hint\nReal numbers are represented as float values. So, you would have to accept the input as follows:\nx = float(input())\nThe output in this case is the value of \\(f(x)\\), which is again to be treated as a float value according to the question. Here is an incomplete code snippet that you can use to complete the solution:\nif 0 &lt; x &lt; 10:\n    print(x + 2)\nNotice the usage 0 &lt; x &lt; 10. This is called operator chaining. This actually corresponds to 0 &lt; x and x &lt; 10. We have chained two operations into a single one. Chaining enables us to smoothly translate the mathematical expression \\(0 &lt; x &lt; 10\\) to the Python expression 0 &lt; x &lt; 10.\nFew more things to consider:\n\nIf you use print statements within the conditional blocks, like the way it is shown here, how many of them would you require to solve this problem?\nIs there a way to solve this problem that requires just one print statement? Can you come up with that solution if it exists?"
  },
  {
    "objectID": "ppa/week-2/PPA-2.html#solutions",
    "href": "ppa/week-2/PPA-2.html#solutions",
    "title": "PPA-2",
    "section": "Solutions",
    "text": "Solutions\nYou have to be careful about printing the value \\(0\\). The expected value is \\(0.0\\), the float value, and not \\(0\\), the integer value.\n\nSolution-1Solution-2Solution-3Solution-4Solution-5\n\n\nx = float(input())\nif 0 &lt; x &lt; 10:\n    print(x + 2)\nelif 10 &lt;= x:\n    print(x ** 2 + 2)\nelse:\n    print(0.0)\n\n\nx = float(input())\nif 0 &lt; x &lt; 10:\n    y = x + 2\nelif 10 &lt;= x:\n    y = x ** 2 + 2\nelse:\n    y = 0.0\nprint(y)\n\n\nHere is a slight variation of solution-2. Can you see what has changed?\nx = float(input())\ny = 0.0\nif 0 &lt; x &lt; 10:\n    y = x + 2\nelif 10 &lt;= x:\n    y = x ** 2 + 2\nprint(y)\n\n\nThis is different from all three solutions before. Instead of using operator chaining, this uses the and operator:\nx = float(input())\ny = 0.0\nif 0 &lt; x and x &lt; 10:\n    y = x + 2\nelif 10 &lt;= x:\n    y = x ** 2 + 2\nprint(y)\n\n\nThis is the last variation. Instead of having elif, we have an if in both places. This is also a valid solution for this problem. This is because the conditions in the two if-blocks are mutually exclusive. That is, if \\(0 &lt; x &lt; 10\\), then the body of the first if-block gets executed. There is no way for the second if-block also to get triggered since \\(10 \\leq x\\) will evaluate to false.\nx = float(input())\ny = 0.0\nif 0 &lt; x &lt; 10:\n    y = x + 2\nif 10 &lt;= x:\n    y = x ** 2 + 2\nprint(y)\nIt is better to stick to if-elif-else ladders wherever possible and avoid a sequence of if conditions. The if-elif-else ladder is more efficient. As soon as one of the conditions is satisfied, the control will exit from the ladder. An if-if-if ladder on the other hand will end up checking every one of the if conditions for every possible input."
  },
  {
    "objectID": "ppa/week-2/PPA-7.html",
    "href": "ppa/week-2/PPA-7.html",
    "title": "PPA-7",
    "section": "",
    "text": "A sequence of five words is called magical if the \\(i^{th}\\) word is a substring of the \\((i + 1)^{th}\\) word for every \\(i\\) in the range \\(1 \\leq i &lt; 5\\). Accept a sequence of five words as input, one word on each line. Print magical if the sequence is magical and non-magical otherwise.\nNote that str_1 is a substring of str_2 if and only if str_1 is present as a sequence of consecutive characters in str_2."
  },
  {
    "objectID": "ppa/week-2/PPA-7.html#question",
    "href": "ppa/week-2/PPA-7.html#question",
    "title": "PPA-7",
    "section": "",
    "text": "A sequence of five words is called magical if the \\(i^{th}\\) word is a substring of the \\((i + 1)^{th}\\) word for every \\(i\\) in the range \\(1 \\leq i &lt; 5\\). Accept a sequence of five words as input, one word on each line. Print magical if the sequence is magical and non-magical otherwise.\nNote that str_1 is a substring of str_2 if and only if str_1 is present as a sequence of consecutive characters in str_2."
  },
  {
    "objectID": "ppa/week-2/PPA-7.html#hint",
    "href": "ppa/week-2/PPA-7.html#hint",
    "title": "PPA-7",
    "section": "Hint",
    "text": "Hint\nThe in keyword is a powerful tool. For example, to see if a string word1 is a substring of another string word2, you just need to type:\nword1 in word2\nIf word1 is a substring of word2 then this expression evaluates to True. If not, it evaluates to False. Now, it is just a question of repeatedly applying this condition across the sequence."
  },
  {
    "objectID": "ppa/week-2/PPA-7.html#solutions",
    "href": "ppa/week-2/PPA-7.html#solutions",
    "title": "PPA-7",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nword_1 = input()\nword_2 = input()\nword_3 = input()\nword_4 = input()\nword_5 = input()\n\nif ((word_1 in word_2) and\n    (word_2 in word_3) and\n    (word_3 in word_4) and\n    (word_4 in word_5)):\n    print('magical')\nelse:\n    print('non-magical')\n\n\nword_1 = input()\nword_2 = input()\nword_3 = input()\nword_4 = input()\nword_5 = input()\n\npresent = False\nif word_1 in word_2:\n    if word_2 in word_3:\n        if word_3 in word_4:\n            if word_4 in word_5:\n                present = True\nif present:\n    print('magical')\nelse:\n    print('non-magical')"
  },
  {
    "objectID": "ppa/week-2/PPA-3.html",
    "href": "ppa/week-2/PPA-3.html",
    "title": "PPA-3",
    "section": "",
    "text": "Accept an integer as input and print the time of the day. Use the following table for reference.\n\n\n\nInput\nOutput\n\n\n\n\n\\(T &lt; 0\\)\nINVALID\n\n\n\\(0 \\leq T \\leq 5\\)\nNIGHT\n\n\n\\(6 \\leq T \\leq 11\\)\nMORNING\n\n\n\\(12 \\leq T \\leq 17\\)\nAFTERNOON\n\n\n\\(18 \\leq T \\leq 23\\)\nEVENING\n\n\n\\(T \\geq 24\\)\nINVALID\n\n\n\nThe input will be a single line containing an integer. The output should be one of these strings: NIGHT, MORNING, AFTERNOON, EVENING, INVALID."
  },
  {
    "objectID": "ppa/week-2/PPA-3.html#question",
    "href": "ppa/week-2/PPA-3.html#question",
    "title": "PPA-3",
    "section": "",
    "text": "Accept an integer as input and print the time of the day. Use the following table for reference.\n\n\n\nInput\nOutput\n\n\n\n\n\\(T &lt; 0\\)\nINVALID\n\n\n\\(0 \\leq T \\leq 5\\)\nNIGHT\n\n\n\\(6 \\leq T \\leq 11\\)\nMORNING\n\n\n\\(12 \\leq T \\leq 17\\)\nAFTERNOON\n\n\n\\(18 \\leq T \\leq 23\\)\nEVENING\n\n\n\\(T \\geq 24\\)\nINVALID\n\n\n\nThe input will be a single line containing an integer. The output should be one of these strings: NIGHT, MORNING, AFTERNOON, EVENING, INVALID."
  },
  {
    "objectID": "ppa/week-2/PPA-3.html#hint",
    "href": "ppa/week-2/PPA-3.html#hint",
    "title": "PPA-3",
    "section": "Hint",
    "text": "Hint\nHow is this problem related to the previous problem? Do they have the same structure?\nThink about the following code snippets:\n\nSnippet-1Snippet-2\n\n\nif T &lt; 0:\n    print('INVALID')\nelif 0 &lt;= T &lt;= 5:\n    print('NIGHT')\n\n\nif T &lt; 0:\n    print('INVALID')\nif 0 &lt;= T &lt;= 5:\n    print('NIGHT')\n\n\n\nCome up with two different solutions to the problem, one that develops snippet-1 and the other which develops snippet-2. What is the difference between these two solutions that you arrive at? Which one is better?"
  },
  {
    "objectID": "ppa/week-2/PPA-3.html#solutions",
    "href": "ppa/week-2/PPA-3.html#solutions",
    "title": "PPA-3",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nt = int(input())\nif 0 &lt;= t &lt;= 5:\n    print('NIGHT')\nelif 6 &lt;= t &lt;= 11:\n    print('MORNING')\nelif 12 &lt;= t &lt;= 17:\n    print('AFTERNOON')\nelif 18 &lt;= t &lt;= 23:\n    print('EVENING')\nelse:\n    print('INVALID')\n\n\nIt is better to stick to if-elif-else ladders wherever possible and avoid a sequence of if conditions. The if-elif-else ladder is more efficient. As soon as one of the conditions is satisfied, the control will exit from the ladder. An if-if-if ladder on the other hand will end up checking every one of the if conditions for every possible input.\nt = int(input())\nif t &lt; 0:\n    print('INVALID')\nif 0 &lt;= t &lt;= 5:\n    print('NIGHT')\nif 6 &lt;= t &lt;= 11:\n    print('MORNING')\nif 12 &lt;= t &lt;= 17:\n    print('AFTERNOON')\nif 18 &lt;= t &lt;= 23:\n    print('EVENING')\nif t &gt;= 24:\n    print('INVALID')"
  },
  {
    "objectID": "ppa/week-2/PPA-5.html",
    "href": "ppa/week-2/PPA-5.html",
    "title": "PPA-5",
    "section": "",
    "text": "Write a program to realize the equation of a line given 2 points \\((x_1,y_1)\\) and \\((x_2,y_2)\\) in 2D space. The input is in 5 lines where, the first, second, third, and fourth lines represent \\(x_1\\), \\(y_1\\), \\(x_2\\), and \\(y_2\\) respectively. The fifth line corresponds to \\(x_3\\). Determine \\(y_3\\) using the equation of a straight line as given below:\n\\[\n\\frac{x-x_1}{x_2-x_1} = \\frac{y-y_1}{y_2-y_1}\n\\]\nThe output should be “Vertical Line” if the line is vertical. In other cases, the output should be 2 lined, where the first line is the value of \\(y_3\\) and the second line indicates whether the slope of the line is positive, negative or zero. Print “Positive Slope”, “Negative Slope” or “Horizontal Line” accordingly.\nNote that all inputs are to be processed as real numbers."
  },
  {
    "objectID": "ppa/week-2/PPA-5.html#question",
    "href": "ppa/week-2/PPA-5.html#question",
    "title": "PPA-5",
    "section": "",
    "text": "Write a program to realize the equation of a line given 2 points \\((x_1,y_1)\\) and \\((x_2,y_2)\\) in 2D space. The input is in 5 lines where, the first, second, third, and fourth lines represent \\(x_1\\), \\(y_1\\), \\(x_2\\), and \\(y_2\\) respectively. The fifth line corresponds to \\(x_3\\). Determine \\(y_3\\) using the equation of a straight line as given below:\n\\[\n\\frac{x-x_1}{x_2-x_1} = \\frac{y-y_1}{y_2-y_1}\n\\]\nThe output should be “Vertical Line” if the line is vertical. In other cases, the output should be 2 lined, where the first line is the value of \\(y_3\\) and the second line indicates whether the slope of the line is positive, negative or zero. Print “Positive Slope”, “Negative Slope” or “Horizontal Line” accordingly.\nNote that all inputs are to be processed as real numbers."
  },
  {
    "objectID": "ppa/week-2/PPA-5.html#hint",
    "href": "ppa/week-2/PPA-5.html#hint",
    "title": "PPA-5",
    "section": "Hint",
    "text": "Hint\nThere are two aspects to this problem. One is mathematical, the other is computational. First, try to figure out the mathematical part. The questions you have to ask yourself are the following:\n\nFor what collection of points does the line joining them become a vertical line?\nIf a line is not vertical, then how does one compute the slope?\nWhat is the slope of a horizontal line?\n\nOnce you have answered these questions, you have all the ingredients necessary to solve the problem computationally. Some of the steps in the computational process:\n\nAccept inputs as real numbers. You know how to do this from PPA-2.\nCalculate the slope.\nFind the y-coordinate of the point.\n\nThere are important details that have been deliberately left out of this hint. These are for you to fill in."
  },
  {
    "objectID": "ppa/week-2/PPA-5.html#solution",
    "href": "ppa/week-2/PPA-5.html#solution",
    "title": "PPA-5",
    "section": "Solution",
    "text": "Solution\nFor the mathematical part, refer to the image given below:\n\nThe slope of a vertical line is undefined. A line is vertical if the x-coordinates of the two points are the same, that is, when \\(x_1 = x_2\\). This gives us the first if-condition.\nx1, y1 = float(input()), float(input())\nx2, y2 = float(input()), float(input())\nx3 = float(input())\n\nif x1 != x2:\n    m = (y2 - y1) / (x2 - x1)   # m is the slope\n    y3 = y1 + m * (x3 - x1)\n    print(y3)\n\n    if m == 0:\n        print('Horizontal Line')\n    elif m &gt; 0:\n        print('Positive Slope')\n    else:\n        print('Negative Slope')\nelse:\n    print('Vertical Line')"
  },
  {
    "objectID": "ppa/week-4/PPA-10.html",
    "href": "ppa/week-4/PPA-10.html",
    "title": "PPA-10",
    "section": "",
    "text": "Accept two square matrices \\(A\\) and \\(B\\) of dimensions \\(n \\times n\\) as input and compute their sum \\(A + B\\).\n\nThe first line will contain the integer \\(n\\). This is followed by \\(2n\\) lines. Each of the first \\(n\\) lines is a sequence of comma-separated integers that denotes one row of the matrix \\(A\\). Each of the last \\(n\\) lines is a sequence of comma-separated integers that denotes one row of the matrix \\(B\\). Your output should again be a sequence of \\(n\\) lines, where each line is a sequence of comma-separated integer that denotes a row of the matrix \\(A + B\\)."
  },
  {
    "objectID": "ppa/week-4/PPA-10.html#question",
    "href": "ppa/week-4/PPA-10.html#question",
    "title": "PPA-10",
    "section": "",
    "text": "Accept two square matrices \\(A\\) and \\(B\\) of dimensions \\(n \\times n\\) as input and compute their sum \\(A + B\\).\n\nThe first line will contain the integer \\(n\\). This is followed by \\(2n\\) lines. Each of the first \\(n\\) lines is a sequence of comma-separated integers that denotes one row of the matrix \\(A\\). Each of the last \\(n\\) lines is a sequence of comma-separated integers that denotes one row of the matrix \\(B\\). Your output should again be a sequence of \\(n\\) lines, where each line is a sequence of comma-separated integer that denotes a row of the matrix \\(A + B\\)."
  },
  {
    "objectID": "ppa/week-4/PPA-10.html#hint",
    "href": "ppa/week-4/PPA-10.html#hint",
    "title": "PPA-10",
    "section": "Hint",
    "text": "Hint\nThis may be one of the longest snippets that you would have to write. While writing this code, note the redundancy involved. You have to accept two matrices as input, so you would have two sets of nested loops, both of which are almost identical in appearance. How can you avoid this redundancy? We will learn functions in week-5 which will solve this problem.\nThat said, once you have two matrices \\(A\\) and \\(B\\) in place, you need a new matrix \\(C\\) such that: \\[\nC[i][j] = A[i][j] + B[i][j]\n\\]"
  },
  {
    "objectID": "ppa/week-4/PPA-10.html#solution",
    "href": "ppa/week-4/PPA-10.html#solution",
    "title": "PPA-10",
    "section": "Solution",
    "text": "Solution\nn = int(input())\n\nA = [ ]\nfor i in range(n):\n    row = [ ]\n    for x in input().split(','):\n        row.append(int(x))\n    A.append(row)\n    \nB = [ ]\nfor i in range(n):\n    row = [ ]\n    for x in input().split(','):\n        row.append(int(x))\n    B.append(row)\n    \nC = [ ]\nfor i in range(n):\n    row = [ ]\n    for j in range(n):\n        row.append(0)\n    C.append(row)\n    \nfor i in range(n):\n    for j in range(n):\n        C[i][j] = A[i][j] + B[i][j]\n        if j != n - 1:\n            print(C[i][j], end = ',')\n        else:\n            print(C[i][j])"
  },
  {
    "objectID": "ppa/week-4/PPA-2.html",
    "href": "ppa/week-4/PPA-2.html",
    "title": "PPA-2",
    "section": "",
    "text": "Accept a sequence of words as input, append all these words to a list in the order in which they are entered, and print this list as output. The first line in the input is a positive integer \\(n\\) that denotes the number of words in the sequence. The next \\(n\\) lines will have one word on each line."
  },
  {
    "objectID": "ppa/week-4/PPA-2.html#question",
    "href": "ppa/week-4/PPA-2.html#question",
    "title": "PPA-2",
    "section": "",
    "text": "Accept a sequence of words as input, append all these words to a list in the order in which they are entered, and print this list as output. The first line in the input is a positive integer \\(n\\) that denotes the number of words in the sequence. The next \\(n\\) lines will have one word on each line."
  },
  {
    "objectID": "ppa/week-4/PPA-2.html#hint",
    "href": "ppa/week-4/PPA-2.html#hint",
    "title": "PPA-2",
    "section": "Hint",
    "text": "Hint\nThere are two steps here:\n\naccept a string during each iteration of the loop\nappend this string to a list\n\nThe easiest thing would be a for loop as the number of iterations is known to us (first line of the input). But what if we go for a while loop?\nwhile n &gt; 0:\n    ### accept string as input ###\n    ### append string to list ###\n    n -= 1\nDo you think the above code works?"
  },
  {
    "objectID": "ppa/week-4/PPA-2.html#solution",
    "href": "ppa/week-4/PPA-2.html#solution",
    "title": "PPA-2",
    "section": "Solution",
    "text": "Solution\n\nSolution-1Solution-2\n\n\nNotice that the loop variable i is not being used anywhere within the body of the loop. It just acts as a syntactic placeholder. Head to solution-2 to see what could be done in such cases.\nn = int(input())\nL = [ ]\nfor i in range(n):\n    word = input()\n    L.append(word)\nprint(L)\n\n\nWhen the loop variable is just a dummy placeholder, coders often use an _ instead of a variable name such as i or j. Check out this Stackoverflow answer for more details.\nn = int(input())\nL = [ ]\nfor _ in range(n):\n    word = input()\n    L.append(word)\nprint(L)"
  },
  {
    "objectID": "ppa/week-4/PPA-7.html",
    "href": "ppa/week-4/PPA-7.html",
    "title": "PPA-7",
    "section": "",
    "text": "Accept a square matrix as input and store it in a variable named matrix. The first line of input will be, \\(n\\), the number of rows in the matrix. Each of the next \\(n\\) lines will have a sequence of \\(n\\) space-separated integers."
  },
  {
    "objectID": "ppa/week-4/PPA-7.html#question",
    "href": "ppa/week-4/PPA-7.html#question",
    "title": "PPA-7",
    "section": "",
    "text": "Accept a square matrix as input and store it in a variable named matrix. The first line of input will be, \\(n\\), the number of rows in the matrix. Each of the next \\(n\\) lines will have a sequence of \\(n\\) space-separated integers."
  },
  {
    "objectID": "ppa/week-4/PPA-7.html#hint",
    "href": "ppa/week-4/PPA-7.html#hint",
    "title": "PPA-7",
    "section": "Hint",
    "text": "Hint\nHow does one accept a row of a matrix?\nA row of input is usually provided as a sequence of numbers:\n1 2 3 4 5\nPPAs 1 to 6 should give you the idea here.\nnums = input().split(' ')   # split by space\nrow = [ ]                   # represents one row of a matrix\nfor num in nums:\n    row.append(int(num))    # convert str to int\nNow, you just need to append this row to another list matrix:\nmatrix = [ ]\nmatrix.append(row)\nprint(matrix)\nYour matrix currently has only one row in it and would look like this:\n[[1, 2, 3, 4, 5]]\nNow it is just a question of using a loop to append all rows of a matrix to the outer list matrix one by one. For the first test case, this is what happens:\nmatrix = [ ]\n# Row-1: 1 2\nrow = [1, 2]\nmatrix.append(row)\n# Matrix becomes [[1, 2]]\n# Row-2: 3 4\nrow = [3, 4]\nmatrix.append(row)\n# Matrix becomes [[1, 2], [3, 4]]\nNow, loopify!"
  },
  {
    "objectID": "ppa/week-4/PPA-7.html#solution",
    "href": "ppa/week-4/PPA-7.html#solution",
    "title": "PPA-7",
    "section": "Solution",
    "text": "Solution\nn = int(input())\n\nmatrix = [ ]\nfor _ in range(n):\n    row = [ ]\n    for num in input().split(' '):\n        row.append(int(num))\n    matrix.append(row)"
  },
  {
    "objectID": "ppa/week-4/PPA-3.html",
    "href": "ppa/week-4/PPA-3.html",
    "title": "PPA-3",
    "section": "",
    "text": "Accept a sequence of comma-separated integers as input and print the maximum value in the sequence as output."
  },
  {
    "objectID": "ppa/week-4/PPA-3.html#question",
    "href": "ppa/week-4/PPA-3.html#question",
    "title": "PPA-3",
    "section": "",
    "text": "Accept a sequence of comma-separated integers as input and print the maximum value in the sequence as output."
  },
  {
    "objectID": "ppa/week-4/PPA-3.html#hint",
    "href": "ppa/week-4/PPA-3.html#hint",
    "title": "PPA-3",
    "section": "Hint",
    "text": "Hint\nConsider the following piece of code.\nnum = '1,2,3,4,5'\nL = num.split(',')\nprint(L)\nWhen this code is executed, it gives the following output:\n['1', '2', '3', '4', '5']\nThe method split is a string method. It can be used with any string variable. The string that is passed as an argument to the split method, in this case it is a comma, is called a delimiter. Sometimes you may have to split using a space. For example:\nnum = '1 2 3 4 5'\nL = num.split(' ') # there is a single space between the quotes\nprint(['1', '2', '3', '4', '5'])\nThe value returned by num.split(' ') is a list of strings. The next step is to convert each element of the string into an integer. This could be done in two ways.\n\nMethod-1Method-2\n\n\nL = ['1', '2', '3', '4', '5']\nfor i in range(len(L)):\n    L[i] = int(L[i])\n\n\nL = ['1', '2', '3', '4', '5']\nL_ints = [ ]\nfor x in L:\n    x_int = int(x)\n    L_ints.append(x_int)\n\n\n\nMethod-1 modifies the list in-place. Method-2 creates a new list. Both methods are valid. From here, it is all about finding the maximum element, something that you should be quite familiar with by now."
  },
  {
    "objectID": "ppa/week-4/PPA-3.html#solution",
    "href": "ppa/week-4/PPA-3.html#solution",
    "title": "PPA-3",
    "section": "Solution",
    "text": "Solution\nnums = input()\nnums = nums.split(',')\n\nmax_num = int(nums[0])\nfor num in nums:\n    num = int(num)\n    if num &gt; max_num:\n        max_num = num\n        \nprint(max_num)"
  },
  {
    "objectID": "ppa/week-4/PPA-11.html",
    "href": "ppa/week-4/PPA-11.html",
    "title": "PPA-11",
    "section": "",
    "text": "L is a list of real numbers that is already given to you. You have to sort this list in descending order and store the sorted list in a variable called sorted_L."
  },
  {
    "objectID": "ppa/week-4/PPA-11.html#question",
    "href": "ppa/week-4/PPA-11.html#question",
    "title": "PPA-11",
    "section": "",
    "text": "L is a list of real numbers that is already given to you. You have to sort this list in descending order and store the sorted list in a variable called sorted_L."
  },
  {
    "objectID": "ppa/week-4/PPA-11.html#hint",
    "href": "ppa/week-4/PPA-11.html#hint",
    "title": "PPA-11",
    "section": "Hint",
    "text": "Hint\nLet us go with the “obvious sort” approach that was covered in the lecture. We have to keep removing the largest element from the list:\nStep-0\n[1, 4, 3, 2, 5]\n\n[ ]\nStep-1\n[1, 4, 3, 2]\n\n[5]\nStep-2\n[1, 3, 2]\n\n[5, 4]\nStep-3\n[1, 2]\n\n[5, 4, 3]\nStep-4\n[1]\n\n[5, 4, 3, 2]\nStep-5\n[ ]\n\n[5, 4, 3, 2, 1]\nThe logic is quite clear. How can we implement this? First, note that we can use L.remove(x) to remove the element x from the list L. What is this element x that we are interested in during each step? It is the maximum element in the list. So, each step has three sub-steps:\n\nFind the maximum element (loop)\nRemove this from the original list (single line statement)\nAppend this to a new list (single line statement)\n\nClearly, the whole thing has to be within a loop. How many times should this outer loop run? Should this outer loop be a for or a while loop? Which do you think is better?"
  },
  {
    "objectID": "ppa/week-4/PPA-11.html#solutions",
    "href": "ppa/week-4/PPA-11.html#solutions",
    "title": "PPA-11",
    "section": "Solutions",
    "text": "Solutions\n\nSolution-1Solution-2\n\n\nsorted_L = [ ]\nwhile L != [ ]:\n    max_elem = L[0]\n    for elem in L:\n        if elem &gt; max_elem:\n            max_elem = elem\n    L.remove(max_elem)\n    sorted_L.append(max_elem)\n\n\nsorted_L = [ ]\nwhile L != [ ]:\n    max_elem = max(L)\n    L.remove(max_elem)\n    sorted_L.append(max_elem)"
  },
  {
    "objectID": "howto/howto-6.html",
    "href": "howto/howto-6.html",
    "title": "Accept a string as input",
    "section": "",
    "text": "string = input()\nFor more details refer to this video."
  },
  {
    "objectID": "howto/howto-9.html",
    "href": "howto/howto-9.html",
    "title": "Create a list of numbers",
    "section": "",
    "text": "L = [1, 2, 3]"
  },
  {
    "objectID": "howto/howto-17.html",
    "href": "howto/howto-17.html",
    "title": "Find the first element in a list",
    "section": "",
    "text": "L = [10, 20, 30, 40]\nfirst = L[0]"
  },
  {
    "objectID": "howto/howto-2.html",
    "href": "howto/howto-2.html",
    "title": "Create a variable and print its value",
    "section": "",
    "text": "name = 'Krishna'\nprint(name)\n\nage = 40\nprint(age)\n\nsalary = 5.5\nprint(salary)\nFor more details refer to this video."
  },
  {
    "objectID": "howto/howto-4.html",
    "href": "howto/howto-4.html",
    "title": "Print multiple values on the same line",
    "section": "",
    "text": "name = 'Krishna'\nage = 40\nprint(name, 'is', age, 'years old')\nFor more details refer to this video."
  },
  {
    "objectID": "howto/howto-1.html",
    "href": "howto/howto-1.html",
    "title": "Print “Hello World!”",
    "section": "",
    "text": "Method-1Method-2\n\n\nprint('Hello World!')\n\n\nprint(\"Hello World!\")\n\n\n\nFor more details refer to this video."
  },
  {
    "objectID": "howto/howto-11.html",
    "href": "howto/howto-11.html",
    "title": "Append an element to a list",
    "section": "",
    "text": "Method-1Method-2\n\n\nL = [1, 2, 3]\nL.append(4)\n\n\nL = [1, 2, 3]\nL = L + [4]"
  },
  {
    "objectID": "howto/howto-21.html",
    "href": "howto/howto-21.html",
    "title": "Extract the second half of a list of even length",
    "section": "",
    "text": "L = [1, 2, 3, 4, 5, 6, 7, 8]\nn = len(L)\nsecond_half = L[n // 2:]\nprint(second_half)"
  },
  {
    "objectID": "howto/howto-15.html",
    "href": "howto/howto-15.html",
    "title": "Print all elements in a list on the same line separated by a space",
    "section": "",
    "text": "L = ['this', 'is', 'a', 'sentence']\nfor word in L:\n    print(word, end = ' ') # a space is passed to the argument end\nThis will add a space after every word. As a result, there will be a space after the last word. This trailing space won’t be perceptible by just viewing the screen. To get rid of it we can use this snippet:\nL = ['this', 'is', 'a', 'sentence']\nfor word in L[:-1]:\n    print(word, end = ' ')\nprint(L[-1])\nThis iterates through the first \\(n - 1\\) entries in the list of length \\(n\\). The last element is printed outside the loop. The code is agnostic to the type of the values inside the list. That is, this snippet would work for a list of integers or a list of float values as well.\nIf we are dealing with a list of strings, there is a smarter way of doing this:\nL = ['this', 'is', 'a', 'sentence']\nsentence = ' '.join(L)\nprint(sentence)\njoin is a string method that accepts a list of strings as argument and joins the elements in the list by using space (the string on which the method is called) as the separator. If join is called using a different string, say a comma, then the separator would be different."
  },
  {
    "objectID": "howto/howto-5.html",
    "href": "howto/howto-5.html",
    "title": "Determine the type of a variable",
    "section": "",
    "text": "name = 'Krishna'\nprint(type(name))\n\nage = 40\nprint(type(age))\n\nsalary = 5.5\nprint(type(salary))\nFor more details refer to this video."
  },
  {
    "objectID": "howto/howto-20.html",
    "href": "howto/howto-20.html",
    "title": "Extract the first half of a list of even length",
    "section": "",
    "text": "L = [1, 2, 3, 4, 5, 6, 7, 8]\nn = len(L)\nfirst_half = L[:n // 2]\nprint(first_half)"
  },
  {
    "objectID": "howto/howto-25.html",
    "href": "howto/howto-25.html",
    "title": "Determine if a number is a factor of another number",
    "section": "",
    "text": "Example-1Example-2\n\n\nx = 10\nf = 5\nif x % f == 0:\n    print(f, 'is a factor of', x)\nelse:\n    print(f, 'is not a factor of', x)\n\n\nx = 14\nf = 3\nif x % f == 0:\n    print(f, 'is a factor of', x)\nelse:\n    print(f, 'is not a factor of', x)"
  },
  {
    "objectID": "howto/howto-7.html",
    "href": "howto/howto-7.html",
    "title": "Accept an integer as input",
    "section": "",
    "text": "x = int(input())\nFor more details refer to this video."
  },
  {
    "objectID": "howto/howto-26.html",
    "href": "howto/howto-26.html",
    "title": "Get the integer part of a decimal number",
    "section": "",
    "text": "x = 3.5\nint_x = int(x)\nprint(int_x)"
  },
  {
    "objectID": "howto.html",
    "href": "howto.html",
    "title": "How to",
    "section": "",
    "text": "This contains a collection of short snippets of code that explain how to do something in Python. A very small number of how-tos have a video to accompany them. These how-tos are organized topic wise. Look for the categories on the right panel. The ideal way to go through these how-tos is to pick a topic and go through each how-to from top to bottom, left to right. Alternatively, you could try to search for a particular how-to by entering some keywords in the filter box given below.\n\n\n\n\n\n\n    \n      \n      \n    \n\n\n\n\n\n\n\nCreate an empty list\n\n\n\n\n\n\n\n\n\n\nPrint “Hello World!”\n\n\n\n\n\n\n\n\n\n\nDetermine the type of a variable\n\n\n\n\n\n\n\n\n\n\nDetermine if a number is a factor of another number\n\n\n\n\n\n\n\n\n\n\nCreate a list of numbers\n\n\n\n\n\n\n\n\n\n\nCreate a variable and print its value\n\n\n\n\n\n\n\n\n\n\nCheck if a variable is of type int\n\n\n\n\n\n\n\n\n\n\nGet the integer part of a decimal number\n\n\n\n\n\n\n\n\n\n\nPrint the values of two variables on the same line\n\n\n\n\n\n\n\n\n\n\nAppend an element to a list\n\n\n\n\n\n\n\n\n\n\nPrint multiple values on the same line\n\n\n\n\n\n\n\n\n\n\nFind number of elements in a list\n\n\n\n\n\n\n\n\n\n\nAccept a string as input\n\n\n\n\n\n\n\n\n\n\nIterate through the elements in a list\n\n\n\n\n\n\n\n\n\n\nPrint all elements in a list, one on each line\n\n\n\n\n\n\n\n\n\n\nAccept an integer as input\n\n\n\n\n\n\n\n\n\n\nFind the first element in a list\n\n\n\n\n\n\n\n\n\n\nAccept a float value as input\n\n\n\n\n\n\n\n\n\n\nFind the last element in a list\n\n\n\n\n\n\n\n\n\n\nExtract the first half of a list of even length\n\n\n\n\n\n\n\n\n\n\nExtract the second half of a list of even length\n\n\n\n\n\n\n\n\n\n\nExtract the sublist that does not contain the first and last elements\n\n\n\n\n\n\n\n\n\n\nFind the maximum element in a list\n\n\n\n\n\n\n\n\n\n\nSort a list of numbers in ascending order\n\n\n\n\n\n\n\n\n\n\nReverse a list of numbers\n\n\n\n\n\n\n\n\n\n\nPrint all elements in a list on the same line separated by a space\n\n\n\n\n\n\n\n\n\n\nPrint all elements in a list on the same line separated by a comma\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "notes/chapter-2/lesson-2.4.html",
    "href": "notes/chapter-2/lesson-2.4.html",
    "title": "Lesson-2.4",
    "section": "",
    "text": "A library is a collection of functions that share a common theme. This is a loose definition and will become clear when we start working with a library.\n\n\nConsider the following problem:\n!!! question ” ” In the year \\(3000\\), \\(15^{\\text{th}}\\)​ August will fall on which day of the week?\nPython to the rescue:\nimport calendar\ncalendar.prmonth(3000, 8)\nWhen the above code is executed, the output is:\n    August 3000\nMo Tu We Th Fr Sa Su\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n15th of August falls on a Friday. Isn’t that lovely? It took just two lines of code! calendar is one among several libraries in Python’s standard library. A comprehensive list can be found here. Going back to the code, calendar is the name of the library and #!py import is the keyword used to include this library as a part of the code.\ncalendar is a collection of functions that are related to calendars. #!py prmonth() is one such function. It accepts &lt;year&gt; and &lt;month&gt;, as input and displays the calendar for &lt;month&gt; in the year &lt;year&gt;. If we want to use a function in calendar, we must first import the library. Let us see what happens if skip this step:\n# import calendar\ncalendar.prmonth(3000, 8)\nIt gives the following error:\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nNameError: name 'calendar' is not defined\nTo access a function defined inside a library, we use the following syntax:\n&lt;calendar&gt;.&lt;function&gt;(&lt;arguments&gt;)\nAnother way to solve the problem is to use the function weekday:\nimport calendar\nprint(calendar.weekday(3000, 8, 15))\nThe output of the above code is 4. Days are mapped to numbers as follows:\n\n\n\nDay\nNumber\n\n\n\n\nMonday\n0\n\n\nTuesday\n1\n\n\nWednesday\n2\n\n\nThursday\n3\n\n\nFriday\n4\n\n\nSaturday\n5\n\n\nSunday\n6\n\n\n\n\n\n\nLet us now try to answer this hypothetical question:\n!!! question ” ” You are stranded on an island in the middle of the Indian Ocean. The island has a computing device that has just one application installed in it: a Python interpreter. You wish to know the current date and time.\nSolution\nfrom time import ctime\nprint('The current time is:', ctime())\nThe output is:\nThe current time is: Fri Apr  2 12:24:43 2021\nThe syntax of the import statement in line-1 looks different. from is a new keyword. The first line of the code is essentially doing the following: from the library called time import the function called ctime. This way of importing functions is useful when we need just one or two functions from a given library:\nfrom time import ctime, sleep\nprint('Current time is:', ctime())\nprint('I am going to sleep for 10 seconds')\nsleep(10)\nprint('Current time is:', ctime())\nsleep(x) is a function in time that suspends the execution of the program for x seconds. If we would be using several functions in the library, then it is a bad idea to keep importing each of them individually. In such cases, it is good to fall back on importing the entire library.\n\n\n\nAs a fun exercise, consider the following code:\nimport this\nThis gives the following output:\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nThese are some nuggets of wisdom from Tim Peters, a “major contributor to the Python programming language” 1. Some of the points make immediate sense, such as “readability counts”."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.4.html#library",
    "href": "notes/chapter-2/lesson-2.4.html#library",
    "title": "Lesson-2.4",
    "section": "",
    "text": "A library is a collection of functions that share a common theme. This is a loose definition and will become clear when we start working with a library.\n\n\nConsider the following problem:\n!!! question ” ” In the year \\(3000\\), \\(15^{\\text{th}}\\)​ August will fall on which day of the week?\nPython to the rescue:\nimport calendar\ncalendar.prmonth(3000, 8)\nWhen the above code is executed, the output is:\n    August 3000\nMo Tu We Th Fr Sa Su\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n15th of August falls on a Friday. Isn’t that lovely? It took just two lines of code! calendar is one among several libraries in Python’s standard library. A comprehensive list can be found here. Going back to the code, calendar is the name of the library and #!py import is the keyword used to include this library as a part of the code.\ncalendar is a collection of functions that are related to calendars. #!py prmonth() is one such function. It accepts &lt;year&gt; and &lt;month&gt;, as input and displays the calendar for &lt;month&gt; in the year &lt;year&gt;. If we want to use a function in calendar, we must first import the library. Let us see what happens if skip this step:\n# import calendar\ncalendar.prmonth(3000, 8)\nIt gives the following error:\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nNameError: name 'calendar' is not defined\nTo access a function defined inside a library, we use the following syntax:\n&lt;calendar&gt;.&lt;function&gt;(&lt;arguments&gt;)\nAnother way to solve the problem is to use the function weekday:\nimport calendar\nprint(calendar.weekday(3000, 8, 15))\nThe output of the above code is 4. Days are mapped to numbers as follows:\n\n\n\nDay\nNumber\n\n\n\n\nMonday\n0\n\n\nTuesday\n1\n\n\nWednesday\n2\n\n\nThursday\n3\n\n\nFriday\n4\n\n\nSaturday\n5\n\n\nSunday\n6\n\n\n\n\n\n\nLet us now try to answer this hypothetical question:\n!!! question ” ” You are stranded on an island in the middle of the Indian Ocean. The island has a computing device that has just one application installed in it: a Python interpreter. You wish to know the current date and time.\nSolution\nfrom time import ctime\nprint('The current time is:', ctime())\nThe output is:\nThe current time is: Fri Apr  2 12:24:43 2021\nThe syntax of the import statement in line-1 looks different. from is a new keyword. The first line of the code is essentially doing the following: from the library called time import the function called ctime. This way of importing functions is useful when we need just one or two functions from a given library:\nfrom time import ctime, sleep\nprint('Current time is:', ctime())\nprint('I am going to sleep for 10 seconds')\nsleep(10)\nprint('Current time is:', ctime())\nsleep(x) is a function in time that suspends the execution of the program for x seconds. If we would be using several functions in the library, then it is a bad idea to keep importing each of them individually. In such cases, it is good to fall back on importing the entire library.\n\n\n\nAs a fun exercise, consider the following code:\nimport this\nThis gives the following output:\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\nThese are some nuggets of wisdom from Tim Peters, a “major contributor to the Python programming language” 1. Some of the points make immediate sense, such as “readability counts”."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.4.html#footnotes",
    "href": "notes/chapter-2/lesson-2.4.html#footnotes",
    "title": "Lesson-2.4",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe brain behind the Zen↩︎"
  },
  {
    "objectID": "notes/chapter-2/lesson-2.3.html",
    "href": "notes/chapter-2/lesson-2.3.html",
    "title": "Lesson-2.3",
    "section": "",
    "text": "Suppose you had to solve the following problem:\n!!! question ” ” Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative, else print zero.\nThis problem can solved by so called Conditional Statements. Conditional Statements is a very important concept in Computer Science in general and are the building blocks to solutions for very complex problems. Conditional Statements, as the name suggests, allow for conditional execution of code. We will we see what this means in detail in the coming sections.\n\n\nLet’s start off with a simpler version of the earlier problem !!! question ” ” Accept an integer as input from the user. If the number is greater than zero, print non-negative.\n#!py if is a keyword in Python. The text adjacent to #!py if is a boolean expression, usually called the if-condition or just the condition. Line-3 is the body of #!py if. If the condition evaluates to True, then line-3 is executed. If it is False, then line-3 doesn’t get executed. The following diagram captures the terms that have been introduced:\n\n\n\nDiagram detailing the syntax of if statement\n\n\nThe control flow of the if-statement as a flow chart is given below:\n\n\n\nControl flow of if statement\n\n\nThus we can solve the problem with if:\nx = int(input())\nif x &gt;= 0:\n    print('non-negative')\nNote that line 3 in the solution code is indented. In this case, the indentation corresponds to four spaces. It is very important to keep this consistent throughout the program. In all lessons, the first level of indentation will have four space . To understand how indentation works and why it is necessary, consider the following code blocks:\nLines 3-5 in the following codes make up the if-block. Lines 4 and 5 which are indented make up the body of #!py if. Whenever the if-condition evaluates to True, the interpreter enters the body of #!py if and executes the lines sequentially. The indentation helps in separating the body of the if-block from the rest of the code.\n=== “Positive x” python     # Left     x = 1     if x &gt;= 0:         print('non-negative')         print('inside if')     print('outside if') The condition is True. So lines 4 and 5 are going to be executed. Once we exit the if-block, the interpreter will resume execution from line 6. The output will be:\n```\nnon-negative\ninside if\noutside if\n```\n=== “Negative x” python     # Right     x = -1     if x &gt;= 0:         print('non-negative')         print('inside if')     print('outside if') The condition is False. So, lines 4 and 5 are not going to be executed. The interpreter will skip the body of if and directly move to line 6. The output will be\n```\noutside if\n```\n\n\n\nLet us add one more level of complexity to the problem.\n!!! question ” ” Accept an integer as input from the user. If the number is greater than or equal to zero, print: non-negative. If the number is less than zero, print negative.\n#!py else is a keyword in Python. When the if-condition evaluates to True, the statements inside the body of the if-block are evaluated. When the condition evaluates to False, the statements inside the body of the else-block are evaluated.\nA visual representation of the control flow:\n\n\n\nif-else control flow\n\n\nNow that with else we can add additional conditional branching to our code and solve the question:\nx = int(input())\nif x &gt;= 0:\n    print('non-negative')\nelse:\n    print('negative')\nLine 2 checks if x is greater than or equal to 0. Upon failing that condition, the else block executes.\nPoints to remember:\n\n#!py if and #!py else are at the same level of indentation.\n#!py else can never occur independent of an #!py if in conditional statements.\n#!py else cannot have any new condition associated with it.\n\nThe following code demonstrates the last two points:\n##### Alarm! Wrong code snippet! #####\nelse:\n    print(1)\n##### Alarm! Wrong code snippet! #####\n\n##### Alarm! Wrong code snippet! #####\nx, y = 1, 2\nif x &gt;= y:\n    print(1)\nelse x &lt; y:\n    print(1)\n##### Alarm! Wrong code snippet! #####\n\n\n\nThis final tool will help us solve the original problem:\n!!! question ” ” Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative, else print zero.\n#!py elif is a keyword in Python. It is a shorthand for else-if. With this final weapon in our conditional statements arsenal, we can solve the problem as thus\nx = int(input())\nif x &gt; 0:\n    print('positive')\nelif x == 0:\n    print('zero')\nelse:\n    print('negative')\n# End of code\nTo understand how this works, let us consider three different inputs and the corresponding outputs.\n\n\n\n\nInput\nOutput\n\n\n\n\nx = 1\npositive\n\n\nx = 0\nzero\n\n\nx = -1\nnegative\n\n\n\n\nThe entire #!py if-#!py elif-#!py else block has three sub-blocks in it:\n\nif-block: lines 2-3\nelif-block: lines 4-5\nelse-block: lines 6-7\n\nThis is the process followed by the interpreter in executing the #!py if-#!py elif-#!py else block:\n\nIf the if-condition evaluates to True, line 3 is executed and then the control transfers to line-8.\nIf the if condition evaluates to False, the control transfers to the elif block. If the elif condition evaluates to True, then line 5 is executed and then the control transfers to line 8.\nIf the elif condition is False, the control transfers to the else block and line 7 is executed. As there are no more conditions to check, control naturally transfers to line 8.\n\nA visual representation of the process is given below:\n\n\n\nelif control flow\n\n\nThe general syntax:\nif &lt;condition_1&gt;:\n    &lt;statement_1&gt;\nelif &lt;condition_2&gt;:\n    &lt;statement_2&gt;\nelse:\n    &lt;statement_3&gt;\nSome features to note:\n\nExactly one of the three statements gets executed.\nThe moment either an #!py if or an #!py elif condition evaluates to True, the body of that block is executed and the flow exits out of the entire #!py if-#!py elif-#!py else block.\nThere could be multiple #!py elif conditions after the #!py if.\nAn #!py else condition cannot come before an #!py elif. The final #!py else block is not mandatory and can be removed. If the #!py else is present, it can only come at the end.\n\n\n\n\n\nConsider the following problem:\n!!! question ” ” Accept three distinct integers as input from the user. If the numbers have been entered in ascending order, print in ascending order. If not, print not in ascending order.\nAn incomplete solution is given below:\n# Incomplete solution\nx = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    print('in ascending order')\nelse:\n    print('not in ascending order')\nThe problem with the above solution is that it doesn’t check if y &lt; z. So, for an input like x, y, z = 1, 3, 2, it will print in ascending order, which is incorrect. The complete solution is given below:\nx = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    if y &lt; z:\n        print('in ascending order')\n    else:\n        print('not in ascending order')\nelse:\n    print('not in ascending order')\nWhenever a new if block is introduced, its body should have exactly one level of indentation with respect to its if condition. Since line 7 makes up the body of the if block starting at line 6, it has one level of indentation with respect to line 6. However, line 6 is already at the first level of indentation with respect to line 5, so line 7 has two levels of indentation with respect to line 5. According to the convention we have chosen, two levels of indentation will correspond to eight spaces.\nHaving a conditional statement inside another conditional statement is called nesting. The if-block from lines 5-9 forms the outer block. The if-else block from lines 6-9 forms the inner block. The #!py else in line 8 is paired with the #!py if in line 6 as they are at the same level of indentation. For similar reasons, the #!py else in line 10 is paired with the #!py if in line 5.\n\n\n\nConsider the following snippet of code:\nx = int(input())\nif x % 5 == 0:\n    output = 'the number is divisible by 5'\nprint(output)\nRun the code multiple times, varying the input each time. What do you observe?\nWhenever the input is a multiple of 5, the code runs without any error. When the input is not divisible by 5, the code throws a NameError. This is because, we are trying to reference a variable that has not been defined. The variable output is created only if line 3 is executed during run-time. Its mere presence in the code is not enough."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.3.html#conditional-statements",
    "href": "notes/chapter-2/lesson-2.3.html#conditional-statements",
    "title": "Lesson-2.3",
    "section": "",
    "text": "Suppose you had to solve the following problem:\n!!! question ” ” Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative, else print zero.\nThis problem can solved by so called Conditional Statements. Conditional Statements is a very important concept in Computer Science in general and are the building blocks to solutions for very complex problems. Conditional Statements, as the name suggests, allow for conditional execution of code. We will we see what this means in detail in the coming sections.\n\n\nLet’s start off with a simpler version of the earlier problem !!! question ” ” Accept an integer as input from the user. If the number is greater than zero, print non-negative.\n#!py if is a keyword in Python. The text adjacent to #!py if is a boolean expression, usually called the if-condition or just the condition. Line-3 is the body of #!py if. If the condition evaluates to True, then line-3 is executed. If it is False, then line-3 doesn’t get executed. The following diagram captures the terms that have been introduced:\n\n\n\nDiagram detailing the syntax of if statement\n\n\nThe control flow of the if-statement as a flow chart is given below:\n\n\n\nControl flow of if statement\n\n\nThus we can solve the problem with if:\nx = int(input())\nif x &gt;= 0:\n    print('non-negative')\nNote that line 3 in the solution code is indented. In this case, the indentation corresponds to four spaces. It is very important to keep this consistent throughout the program. In all lessons, the first level of indentation will have four space . To understand how indentation works and why it is necessary, consider the following code blocks:\nLines 3-5 in the following codes make up the if-block. Lines 4 and 5 which are indented make up the body of #!py if. Whenever the if-condition evaluates to True, the interpreter enters the body of #!py if and executes the lines sequentially. The indentation helps in separating the body of the if-block from the rest of the code.\n=== “Positive x” python     # Left     x = 1     if x &gt;= 0:         print('non-negative')         print('inside if')     print('outside if') The condition is True. So lines 4 and 5 are going to be executed. Once we exit the if-block, the interpreter will resume execution from line 6. The output will be:\n```\nnon-negative\ninside if\noutside if\n```\n=== “Negative x” python     # Right     x = -1     if x &gt;= 0:         print('non-negative')         print('inside if')     print('outside if') The condition is False. So, lines 4 and 5 are not going to be executed. The interpreter will skip the body of if and directly move to line 6. The output will be\n```\noutside if\n```\n\n\n\nLet us add one more level of complexity to the problem.\n!!! question ” ” Accept an integer as input from the user. If the number is greater than or equal to zero, print: non-negative. If the number is less than zero, print negative.\n#!py else is a keyword in Python. When the if-condition evaluates to True, the statements inside the body of the if-block are evaluated. When the condition evaluates to False, the statements inside the body of the else-block are evaluated.\nA visual representation of the control flow:\n\n\n\nif-else control flow\n\n\nNow that with else we can add additional conditional branching to our code and solve the question:\nx = int(input())\nif x &gt;= 0:\n    print('non-negative')\nelse:\n    print('negative')\nLine 2 checks if x is greater than or equal to 0. Upon failing that condition, the else block executes.\nPoints to remember:\n\n#!py if and #!py else are at the same level of indentation.\n#!py else can never occur independent of an #!py if in conditional statements.\n#!py else cannot have any new condition associated with it.\n\nThe following code demonstrates the last two points:\n##### Alarm! Wrong code snippet! #####\nelse:\n    print(1)\n##### Alarm! Wrong code snippet! #####\n\n##### Alarm! Wrong code snippet! #####\nx, y = 1, 2\nif x &gt;= y:\n    print(1)\nelse x &lt; y:\n    print(1)\n##### Alarm! Wrong code snippet! #####\n\n\n\nThis final tool will help us solve the original problem:\n!!! question ” ” Accept an integer as input from the user. If the number is greater than zero, print positive and if number is less than zero, print negative, else print zero.\n#!py elif is a keyword in Python. It is a shorthand for else-if. With this final weapon in our conditional statements arsenal, we can solve the problem as thus\nx = int(input())\nif x &gt; 0:\n    print('positive')\nelif x == 0:\n    print('zero')\nelse:\n    print('negative')\n# End of code\nTo understand how this works, let us consider three different inputs and the corresponding outputs.\n\n\n\n\nInput\nOutput\n\n\n\n\nx = 1\npositive\n\n\nx = 0\nzero\n\n\nx = -1\nnegative\n\n\n\n\nThe entire #!py if-#!py elif-#!py else block has three sub-blocks in it:\n\nif-block: lines 2-3\nelif-block: lines 4-5\nelse-block: lines 6-7\n\nThis is the process followed by the interpreter in executing the #!py if-#!py elif-#!py else block:\n\nIf the if-condition evaluates to True, line 3 is executed and then the control transfers to line-8.\nIf the if condition evaluates to False, the control transfers to the elif block. If the elif condition evaluates to True, then line 5 is executed and then the control transfers to line 8.\nIf the elif condition is False, the control transfers to the else block and line 7 is executed. As there are no more conditions to check, control naturally transfers to line 8.\n\nA visual representation of the process is given below:\n\n\n\nelif control flow\n\n\nThe general syntax:\nif &lt;condition_1&gt;:\n    &lt;statement_1&gt;\nelif &lt;condition_2&gt;:\n    &lt;statement_2&gt;\nelse:\n    &lt;statement_3&gt;\nSome features to note:\n\nExactly one of the three statements gets executed.\nThe moment either an #!py if or an #!py elif condition evaluates to True, the body of that block is executed and the flow exits out of the entire #!py if-#!py elif-#!py else block.\nThere could be multiple #!py elif conditions after the #!py if.\nAn #!py else condition cannot come before an #!py elif. The final #!py else block is not mandatory and can be removed. If the #!py else is present, it can only come at the end."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.3.html#nested-conditional-statements",
    "href": "notes/chapter-2/lesson-2.3.html#nested-conditional-statements",
    "title": "Lesson-2.3",
    "section": "",
    "text": "Consider the following problem:\n!!! question ” ” Accept three distinct integers as input from the user. If the numbers have been entered in ascending order, print in ascending order. If not, print not in ascending order.\nAn incomplete solution is given below:\n# Incomplete solution\nx = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    print('in ascending order')\nelse:\n    print('not in ascending order')\nThe problem with the above solution is that it doesn’t check if y &lt; z. So, for an input like x, y, z = 1, 3, 2, it will print in ascending order, which is incorrect. The complete solution is given below:\nx = int(input())\ny = int(input())\nz = int(input())\n\nif x &lt; y:\n    if y &lt; z:\n        print('in ascending order')\n    else:\n        print('not in ascending order')\nelse:\n    print('not in ascending order')\nWhenever a new if block is introduced, its body should have exactly one level of indentation with respect to its if condition. Since line 7 makes up the body of the if block starting at line 6, it has one level of indentation with respect to line 6. However, line 6 is already at the first level of indentation with respect to line 5, so line 7 has two levels of indentation with respect to line 5. According to the convention we have chosen, two levels of indentation will correspond to eight spaces.\nHaving a conditional statement inside another conditional statement is called nesting. The if-block from lines 5-9 forms the outer block. The if-else block from lines 6-9 forms the inner block. The #!py else in line 8 is paired with the #!py if in line 6 as they are at the same level of indentation. For similar reasons, the #!py else in line 10 is paired with the #!py if in line 5."
  },
  {
    "objectID": "notes/chapter-2/lesson-2.3.html#defining-variables-inside-if",
    "href": "notes/chapter-2/lesson-2.3.html#defining-variables-inside-if",
    "title": "Lesson-2.3",
    "section": "",
    "text": "Consider the following snippet of code:\nx = int(input())\nif x % 5 == 0:\n    output = 'the number is divisible by 5'\nprint(output)\nRun the code multiple times, varying the input each time. What do you observe?\nWhenever the input is a multiple of 5, the code runs without any error. When the input is not divisible by 5, the code throws a NameError. This is because, we are trying to reference a variable that has not been defined. The variable output is created only if line 3 is executed during run-time. Its mere presence in the code is not enough."
  },
  {
    "objectID": "notes/extras/limits.html",
    "href": "notes/extras/limits.html",
    "title": "Shorts",
    "section": "",
    "text": "Shorts\nBefore we close this chapter, let us spend some time at the intersection of mathematics and programming. Consider the following number: \\[\n\\sqrt{2} - 1\n\\] It is known that \\(1 &lt; \\sqrt{2} &lt; 2\\). From this, it follows that \\(0 &lt; \\sqrt{2} - 1 &lt; 1\\). Now, consider the following sequence: \\[\na_n = \\left( \\sqrt{2} - 1 \\right)^n\n\\] As \\(n\\) becomes very large, the values in this sequence will become smaller and smaller. This is because, if you keep multiplying a fraction with itself, it becomes smaller and smaller. In mathematical terms, the limit of this sequence as \\(n\\) tends to infinity is zero. Let us verify this programmatically:\nn = int(input())        # sequence length\nCONST = 2 ** 0.5 - 1    # basic term in the sequence\na_n = 1                 # zeroth term\nfor i in range(n):\n    a_n = a_n * CONST\nprint(a_n)\nTry this out for a few values of \\(n\\). For \\(n = 100\\), the value is \\(5.27 \\times 10^{-39}\\), which is so small that for all practical purposes, it is as good as zero. Now, here is another fact. For every number \\(n\\), there are unique integers \\(x\\) and \\(y\\) such that: \\[\n(\\sqrt{2} - 1)^n = x + y \\cdot \\sqrt{2}\n\\] This can be verified for the first few values of \\(n\\). The following is a sketch of an inductive proof that this is indeed the case. If \\((\\sqrt{2} - 1)^n = x_n + y_n \\cdot \\sqrt{2}\\), then: \\[\n\\begin{align}\n(\\sqrt{2} - 1)^{n + 1} &= (x_n + y_n \\cdot \\sqrt{2}) \\cdot (\\sqrt{2} - 1)\\\\\n&= (2y_n - x_n) + (x_n - y_n) \\cdot \\sqrt{2}\\\\\n&= x_{n + 1} + y_{n + 1} \\cdot \\sqrt{2}\n\\end{align}\n\\] This gives us a programmatic way to compute the \\(n^{th}\\) power of \\(\\sqrt{2} - 1\\) in the above form:\nn = int(input())    # sequence length\nx_n, y_n = -1, 1    # x_1 and y_1\nfor i in range(n):\n    x_n, y_n = 2 * y_n - x_n, x_n - y_n\nThis in turn provides a way to approximate \\(\\sqrt{2}\\) using rational numbers: \\[\n\\sqrt{2} \\approx \\frac{-x_n}{y_n}\n\\] As \\(n\\) becomes large, this approximation will become increasingly accurate. For example, here is an approximation after 100 iterations. It is accurate up to several decimal places! \\[\n\\frac{228725309250740208744750893347264645481}{161733217200188571081311986634082331709}\n\\] Is any of this useful? I don’t know. But honestly, who cares? We don’t do things because they are useful. We do them because they are interesting. And all interesting things will find their use at some point of time in the future."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html",
    "href": "notes/chapter-1/lesson-1.1.html",
    "title": "Lesson-1.1",
    "section": "",
    "text": "In this lesson, we will be working with the Python interpreter in Interactive Mode. It is also often called the Python shell. It is a tool that lets us execute individual lines of code and see the output right away. We will drop the phrase “interactive mode” and just refer to it as the interpreter. Have a look at the official Python documentation for more details about the Python Interpreter . If you have Python installed on your system, then the Python shell will look like this:\n\n\n\n\nPython IDLE\n\n\n\nIn Replit, this corresponds to the console screen on the right of the repl. This will be our playground for quite sometime:\nVideo"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html#python-shell-replit-console",
    "href": "notes/chapter-1/lesson-1.1.html#python-shell-replit-console",
    "title": "Lesson-1.1",
    "section": "",
    "text": "In this lesson, we will be working with the Python interpreter in Interactive Mode. It is also often called the Python shell. It is a tool that lets us execute individual lines of code and see the output right away. We will drop the phrase “interactive mode” and just refer to it as the interpreter. Have a look at the official Python documentation for more details about the Python Interpreter . If you have Python installed on your system, then the Python shell will look like this:\n\n\n\n\nPython IDLE\n\n\n\nIn Replit, this corresponds to the console screen on the right of the repl. This will be our playground for quite sometime:\nVideo"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html#prompts",
    "href": "notes/chapter-1/lesson-1.1.html#prompts",
    "title": "Lesson-1.1",
    "section": "Prompts",
    "text": "Prompts\n\n\n\nReplit prompt\n\n\nThe orange symbol that is displayed above is called a prompt. Its role is similar to that of the blinking cursor while editing documents. It is an invitation to type code. Code that is typed at the prompt is executed by the interpreter. In these lessons, we will use the following symbol to refer to the prompt: &gt;&gt;&gt;.\nWe are all set to write our first line of code:\n&gt;&gt;&gt; print('Hello World!')\nHello World!\nFire up a repl and type the code in the console. You will be getting the output on the next line."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html#output",
    "href": "notes/chapter-1/lesson-1.1.html#output",
    "title": "Lesson-1.1",
    "section": "Output",
    "text": "Output\nLet us take a closer look at the first line of code that we wrote. print() is called a built-in function in Python. A function is an object that accepts inputs and returns outputs. The term built-in refers to the fact that this function is something that is readily provided by Python for our use.\n&gt;&gt;&gt; print('Hello World!')\nHello World!\n&gt;&gt;&gt; print(\"Hello World!\")\nHello World!\nThe sentence enclosed by the parentheses of the print() function is called a string. A string is a sequence of characters enclosed in quotes. Strings can either be in single quotes or double quotes. However, a single quote can’t be matched against a double quote to enclose a string. We have used single quotes in line 1 and double quotes in line 3. Both lines give identical outputs. The ability to use both single quotes and double quotes comes in handy in situations like this. Let us try to print a string that has an apostrophe in it:\n&gt;&gt;&gt; print(\"India's capital is New Delhi.\")\nRun the code given above and observe the output. print() can also be used to print numbers:\n&gt;&gt;&gt; print(1)\n1\n&gt;&gt;&gt; print(2.0)\n2.0\nMultiple items can be printed on the same line in the following way:\n&gt;&gt;&gt; print(1, 2)\n1 2\n&gt;&gt;&gt; print('online', 'degree', 'program')\nonline degree program\nNotice the presence of a space between successive elements. print automatically seperates multiple values with a delimiter, which is space by default.\nIf the print command is called without passing any input to it, then it prints a blank line:\n&gt;&gt;&gt; print()\n\n&gt;&gt;&gt;\nWhat happens if we just use type print without having the parentheses?\n&gt;&gt;&gt; print\n&lt;built-in function print&gt;\nWe don’t get an error. Instead, the message is that print is a built-in function. But when you try the following code:\n&gt;&gt;&gt; print 'Hello World!'\n  File \"&lt;stdin&gt;\", line 1\n    print 'Hello World!'\n          ^\nSyntaxError: Missing parentheses in call to 'print'. Did you mean print('Hello World!')?\nThe interpreter hits back with a SyntaxError. The syntax for a programming language is like the grammar for human languages. Each programming languages has its own syntax that a programmer has to follow to communicate with the computer. Programming language syntaxes, however, are far more strict and have to be followed exactly in order to run code without any errors. Parentheses are used to execute and pass values (called arguments in programming jargon) to functions like print . Note the lack of parentheses in the above snippet which is also pointed out by the handy error message. We will learn the syntax for various commands in Python in the upcoming lessons."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html#emojis",
    "href": "notes/chapter-1/lesson-1.1.html#emojis",
    "title": "Lesson-1.1",
    "section": "Emojis",
    "text": "Emojis\nBefore we jump into more serious discussions, let us try and print some emojis!\n&gt;&gt;&gt; print('\\N{smiling face with smiling eyes}')\n😊\n&gt;&gt;&gt; print('\\N{grinning face}')\n😀\n&gt;&gt;&gt; print('\\N{smiling face with halo}')\n😇\n&gt;&gt;&gt; print('\\N{thinking face}')\n🤔\nTry this out in an interpreter of your choice! A full list of emojis can be found here."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html#literals-and-variables",
    "href": "notes/chapter-1/lesson-1.1.html#literals-and-variables",
    "title": "Lesson-1.1",
    "section": "Literals and Variables",
    "text": "Literals and Variables\nStrings like 'Hello World!' and numbers like 1, 2.0 are called literals in Python. Formally, a literal is something that describes a constant value. Variables are containers that are used to store values. Variables in Python are defined in the following way:\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; print(x)\n1\n&gt;&gt;&gt; y = 'a string'\n&gt;&gt;&gt; print(y)\na string\n&gt;&gt;&gt; foo_bar = 123.456\n&gt;&gt;&gt; print(foo_bar)\n123.456\n= is called the assignment operator. Whenever the assignment operator is present in a statement, it is used for one of the following purposes:\n\ndefine a new variable\nupdate an existing variable\n\n&gt;&gt;&gt; x = 1         # define a new variable\n&gt;&gt;&gt; x = x + 1     # update an existing variable\n&gt;&gt;&gt; print(x)\n2\nThe assignment operator is evaluated from right to left. That is, the expression to the right of the assignment operator is evaluated first. This result is then assigned to the variable on the left. Variables will be taken up in greater detail in the lessons of the second chapter."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html#basic-data-types-type",
    "href": "notes/chapter-1/lesson-1.1.html#basic-data-types-type",
    "title": "Lesson-1.1",
    "section": "Basic Data Types | type()",
    "text": "Basic Data Types | type()\nWe will be looking at the following basic data types:\n\nInteger\nFloat\nString\nBoolean\n\n\nInteger\nThe int type represents integers. Python provides a command called type to determine the type of an object:\n&gt;&gt;&gt; print(1)\n1\n&gt;&gt;&gt; type(1)\n&lt;class 'int'&gt;\n\n\nFloat\nThe float type represents real numbers:\n&gt;&gt;&gt; print(1.0)\n1.0\n&gt;&gt;&gt; type(1.0)\n&lt;class 'float'&gt;\nThe following is also a valid float literal:\n&gt;&gt;&gt; print(1.)\n1.0\n1. and 1.0 are one and the same literal.\n\n\nString\nThe str type represents strings:\n&gt;&gt;&gt; print('one')\none\n&gt;&gt;&gt; type(\"one\")\n&lt;class 'str'&gt;\n\n\nBoolean\nThe bool type represents boolean values:\n&gt;&gt;&gt; print(True)\nTrue\n&gt;&gt;&gt; type(False)\n&lt;class 'bool'&gt;\nPlease note that bool values are case sensitive. That is, true and false are not bool values."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.1.html#comments",
    "href": "notes/chapter-1/lesson-1.1.html#comments",
    "title": "Lesson-1.1",
    "section": "Comments",
    "text": "Comments\nA comment is a line of text that is not executed by the interpreter. Comments begin with the # symbol. The following are comments:\n&gt;&gt;&gt; # This is a comment\n&gt;&gt;&gt; # print(1)\n&gt;&gt;&gt; \nAs line-2 is a comment, 1 is not printed in the next line. Comments can also come at the end of a line of code:\n&gt;&gt;&gt; print(1) # This line is printing the value 1\n1\nAdding comments is one of the ways to make code more readable. Its use will become clear in subsequent chapters."
  },
  {
    "objectID": "notes/chapter-1/lesson-1.2.html",
    "href": "notes/chapter-1/lesson-1.2.html",
    "title": "Lesson-1.2",
    "section": "",
    "text": "The anatomy of an operation is given below:\n\n\n\nAnatomy of an expression\n\n\nThe following table gives the symbols for arithmetic operators and the operations that they correspond to:\n\n\n\n\nOperator\nOperation\n\n\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n//\nFloor division\n\n\n%\nModulus\n\n\n**\nExponentiation\n\n\n\n\nAll the operators in the above table are binary, i.e., they operate on two operands. Let us now take a look at each operator:\n&gt;&gt;&gt; 10 + 5\n15\n&gt;&gt;&gt; 10 - 5\n5\n&gt;&gt;&gt; 10 * 5\n50\n&gt;&gt;&gt; 10 / 5\n2.0\n&gt;&gt;&gt; 10 // 5\n2\n&gt;&gt;&gt; 10 % 5\n0\n&gt;&gt;&gt; 10 ** 5\n100000\nThe last three operators might be new. In more familiar terms, these are the mathematical operations that they correspond to:\n\n// is called the floor division operator. x // y gives the quotient when x is divided by y. For example, 8 // 3 is 2.\n% is called the modulus operator. x % y gives the remainder when x is divided by y. For example, 10 % 3 is 1.\n** is called the exponentiation operator. x ** y returns \\(x^y\\).\n\n/ and // are two different operators. / gives the complete result of division, while // returns the quotient. For example, 5 / 2 results in 2.5 while 5 // 2 gives 2. There are two more arithmetic operators of interest to us, unary plus and unary minus. These are the + and - signs. Unlike the operators that we have seen so far, these two are unary operators, i.e., they operate on one operand. For example:\n&gt;&gt;&gt; - 2\n-2\n&gt;&gt;&gt; + 2\n2\nIt is important to note that the symbols for plus and minus operators are the same as the ones for addition and subtraction. The context determines the nature of the operator:\n&gt;&gt;&gt; - 1    # unary minus\n-1\n&gt;&gt;&gt; 1 - 1  # subtraction operator\nSometimes both of them could come together in the same expression:\n&gt;&gt;&gt; 1 - - 1 \n2\n&gt;&gt;&gt; # The minus on the left is subtraction\n&gt;&gt;&gt; # The minus on the right is unary minus\nIn all the operations that we have seen so far, the operands have been literals. In general, the operands can also be variables:\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = x * 5\n&gt;&gt;&gt; print(x, y)\n1 5\n\n\n\nThe following table gives the symbols for relational operators and the operations that they correspond to:\n\n\n\n\nOperator\nOperation\n\n\n\n\n&gt;\ngreater than\n\n\n&lt;\nless than\n\n\n&gt;=\ngreater than or equal to\n\n\n&lt;=\nless than or equal to\n\n\n==\ndouble equal to\n\n\n!=\nnot equal to\n\n\n\n\nAll the operators in the above table are binary. Let us now take a look at each of them:\n&gt;&gt;&gt; 10 &gt; 5\nTrue\n&gt;&gt;&gt; 10 &lt; 5\nFalse\n&gt;&gt;&gt; 10 &gt;= 5\nTrue\n&gt;&gt;&gt; 10 &lt;= 5\nFalse\n&gt;&gt;&gt; 10 == 5\nFalse\n&gt;&gt;&gt; 10 != 5\nTrue\nRelational operators are also called comparison operators. The result of any comparison operation is a boolean value: True or False. The result of a comparison operation can be assigned to a variable:\n&gt;&gt;&gt; x = 10\n&gt;&gt;&gt; y = 15\n&gt;&gt;&gt; z = y &gt; x\n&gt;&gt;&gt; print(z)\nTrue\nThe == symbol corresponds to the equality operator and should not be confused with =, the assignment operator.\n\n\n\nThe following table gives the logical operators and the operations that they correspond to:\n\n\n\n\nOperator\nOperation\n\n\n\n\nnot\nnegation\n\n\nand\nlogical conjunction\n\n\nor\nlogical disjunction\n\n\n\n\nand and or are binary operators; not is a unary operator. Let us now take a look at each of them:\n&gt;&gt;&gt; True and False\nFalse\n&gt;&gt;&gt; True or False\nTrue\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; y = not x\n&gt;&gt;&gt; print(y)\nTrue\nThe use of parenthesis after not is optional. For example:\n&gt;&gt;&gt; x = True\n&gt;&gt;&gt; not x\nFalse\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; not(x)\nTrue\n\n\n\n\n\n\nNote\n\n\n\nConsider the following lines of code:\n&gt;&gt;&gt; print(1 + 2)\n3\n&gt;&gt;&gt; print(1+2)\n3\nBoth lines 1 and 3 give the same output. Line-1 has a space before and after the + operator, while line-3 doesn’t. Both ways are syntactically correct. In this course, we will be following the first convention: there is always a space separating the operator from the operands. This is also true for the = operator.\n&gt;&gt;&gt; x = 2 # We will follow this\n&gt;&gt;&gt; x=2   # We will NOT follow this\n# But both conventions are valid\n\n\n\n\n\nPython supports chaining relational operators. This enables you to evaluate chains of comparison without having to use logical operators.\n&gt;&gt;&gt; 10 &lt; 11 &lt;= 12\nTrue\n# is the same as\n&gt;&gt;&gt; 10 &lt; 11 and 11 &lt;= 12\nTrue"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.2.html#operators",
    "href": "notes/chapter-1/lesson-1.2.html#operators",
    "title": "Lesson-1.2",
    "section": "",
    "text": "The anatomy of an operation is given below:\n\n\n\nAnatomy of an expression\n\n\nThe following table gives the symbols for arithmetic operators and the operations that they correspond to:\n\n\n\n\nOperator\nOperation\n\n\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n//\nFloor division\n\n\n%\nModulus\n\n\n**\nExponentiation\n\n\n\n\nAll the operators in the above table are binary, i.e., they operate on two operands. Let us now take a look at each operator:\n&gt;&gt;&gt; 10 + 5\n15\n&gt;&gt;&gt; 10 - 5\n5\n&gt;&gt;&gt; 10 * 5\n50\n&gt;&gt;&gt; 10 / 5\n2.0\n&gt;&gt;&gt; 10 // 5\n2\n&gt;&gt;&gt; 10 % 5\n0\n&gt;&gt;&gt; 10 ** 5\n100000\nThe last three operators might be new. In more familiar terms, these are the mathematical operations that they correspond to:\n\n// is called the floor division operator. x // y gives the quotient when x is divided by y. For example, 8 // 3 is 2.\n% is called the modulus operator. x % y gives the remainder when x is divided by y. For example, 10 % 3 is 1.\n** is called the exponentiation operator. x ** y returns \\(x^y\\).\n\n/ and // are two different operators. / gives the complete result of division, while // returns the quotient. For example, 5 / 2 results in 2.5 while 5 // 2 gives 2. There are two more arithmetic operators of interest to us, unary plus and unary minus. These are the + and - signs. Unlike the operators that we have seen so far, these two are unary operators, i.e., they operate on one operand. For example:\n&gt;&gt;&gt; - 2\n-2\n&gt;&gt;&gt; + 2\n2\nIt is important to note that the symbols for plus and minus operators are the same as the ones for addition and subtraction. The context determines the nature of the operator:\n&gt;&gt;&gt; - 1    # unary minus\n-1\n&gt;&gt;&gt; 1 - 1  # subtraction operator\nSometimes both of them could come together in the same expression:\n&gt;&gt;&gt; 1 - - 1 \n2\n&gt;&gt;&gt; # The minus on the left is subtraction\n&gt;&gt;&gt; # The minus on the right is unary minus\nIn all the operations that we have seen so far, the operands have been literals. In general, the operands can also be variables:\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; y = x * 5\n&gt;&gt;&gt; print(x, y)\n1 5\n\n\n\nThe following table gives the symbols for relational operators and the operations that they correspond to:\n\n\n\n\nOperator\nOperation\n\n\n\n\n&gt;\ngreater than\n\n\n&lt;\nless than\n\n\n&gt;=\ngreater than or equal to\n\n\n&lt;=\nless than or equal to\n\n\n==\ndouble equal to\n\n\n!=\nnot equal to\n\n\n\n\nAll the operators in the above table are binary. Let us now take a look at each of them:\n&gt;&gt;&gt; 10 &gt; 5\nTrue\n&gt;&gt;&gt; 10 &lt; 5\nFalse\n&gt;&gt;&gt; 10 &gt;= 5\nTrue\n&gt;&gt;&gt; 10 &lt;= 5\nFalse\n&gt;&gt;&gt; 10 == 5\nFalse\n&gt;&gt;&gt; 10 != 5\nTrue\nRelational operators are also called comparison operators. The result of any comparison operation is a boolean value: True or False. The result of a comparison operation can be assigned to a variable:\n&gt;&gt;&gt; x = 10\n&gt;&gt;&gt; y = 15\n&gt;&gt;&gt; z = y &gt; x\n&gt;&gt;&gt; print(z)\nTrue\nThe == symbol corresponds to the equality operator and should not be confused with =, the assignment operator.\n\n\n\nThe following table gives the logical operators and the operations that they correspond to:\n\n\n\n\nOperator\nOperation\n\n\n\n\nnot\nnegation\n\n\nand\nlogical conjunction\n\n\nor\nlogical disjunction\n\n\n\n\nand and or are binary operators; not is a unary operator. Let us now take a look at each of them:\n&gt;&gt;&gt; True and False\nFalse\n&gt;&gt;&gt; True or False\nTrue\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; y = not x\n&gt;&gt;&gt; print(y)\nTrue\nThe use of parenthesis after not is optional. For example:\n&gt;&gt;&gt; x = True\n&gt;&gt;&gt; not x\nFalse\n&gt;&gt;&gt; x = False\n&gt;&gt;&gt; not(x)\nTrue\n\n\n\n\n\n\nNote\n\n\n\nConsider the following lines of code:\n&gt;&gt;&gt; print(1 + 2)\n3\n&gt;&gt;&gt; print(1+2)\n3\nBoth lines 1 and 3 give the same output. Line-1 has a space before and after the + operator, while line-3 doesn’t. Both ways are syntactically correct. In this course, we will be following the first convention: there is always a space separating the operator from the operands. This is also true for the = operator.\n&gt;&gt;&gt; x = 2 # We will follow this\n&gt;&gt;&gt; x=2   # We will NOT follow this\n# But both conventions are valid\n\n\n\n\n\nPython supports chaining relational operators. This enables you to evaluate chains of comparison without having to use logical operators.\n&gt;&gt;&gt; 10 &lt; 11 &lt;= 12\nTrue\n# is the same as\n&gt;&gt;&gt; 10 &lt; 11 and 11 &lt;= 12\nTrue"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.2.html#expressions",
    "href": "notes/chapter-1/lesson-1.2.html#expressions",
    "title": "Lesson-1.2",
    "section": "Expressions",
    "text": "Expressions\nAn expression is some combination of literals, variables and operators. For example, the following are expressions:\n\n1 + 4 / 4 ** 0\nx / y + z * 2.0\n3 &gt; 4 and 1 &lt; 10\nnot True and False\n\nEach expression evaluates to some value. This value has a type. In the above examples, the first two expressions result in a float, while the next two expressions result in a bool. In the next few sections, we shall study two types of expressions:\n\nArithmetic: an expression whose type is either int or float\nBoolean: an expression whose type is bool"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.2.html#types-of-expressions",
    "href": "notes/chapter-1/lesson-1.2.html#types-of-expressions",
    "title": "Lesson-1.2",
    "section": "Types of Expressions",
    "text": "Types of Expressions\n\nArithmetic Expressions\nLet us now look at the type of simple arithmetic operations. In mathematics, the result of adding two integers is another integer. Is this true in the case of Python? First, let us execute the following statement in the interpreter and see what we get:\n&gt;&gt;&gt; 1 + 2\n3\nThe way to check the type of this expression is to use the type() function. For example, we have:\n&gt;&gt;&gt; 1 + 2\n3\n&gt;&gt;&gt; type(1 + 2)\n&lt;class 'int'&gt;\nSo far the interpreter’s behaviour conforms to our intuition. Let us now change this code slightly:\n&gt;&gt;&gt; 1.0 + 2\n3.0\n&gt;&gt;&gt; type(1.0 + 2)\n&lt;class 'float'&gt;\nWe see that the result is 3.0 which is of type float. The conclusion is that float is more dominant than int as far as the addition operation is concerned. What about other operations? Let us check with the help of the following examples:\n&gt;&gt;&gt; type(7.0 * 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 / 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 // 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 ** 5)\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(7.0 % 5)\n&lt;class 'float'&gt;\nAll the operations result in a float. From this we see that float is more dominant than int, irrespective of the operator involved.\n\n\nBoolean Expressions\nExpressions that involve a relational operator will result in a bool. For example:\n&gt;&gt;&gt; 2 &gt; 1\nTrue\n&gt;&gt;&gt; type(2 &gt; 1)\n&lt;class 'bool'&gt;\nExpressions that involve logical operators will naturally result in a bool. For example:\n&gt;&gt;&gt; True and False\nFalse\n&gt;&gt;&gt; type(True and False)\n&lt;class 'bool'&gt;\nOne way to analyze the outcome of boolean expressions that involve variables is to exhaustively list down the different combinations of values that variables can take and evaluate the expression for each such combination. For example, assume that X and Y are two boolean variables. Now, consider the following expression:\n&gt;&gt;&gt; X or Y\nWe can take the help of a concept called truth table to analyze the outcomes:\n\n\n\n\nX\nY\nX or Y\n\n\n\n\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\n\n\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.5.html",
    "href": "notes/chapter-1/lesson-1.5.html",
    "title": "Lesson-1.5",
    "section": "",
    "text": "We briefly looked at strings in the first lesson. A string is any sequence of characters enclosed within single or double quotes. Some examples:\n\"this is a string\"\n'this is also a string'\n'1 + 1 = 2'\n\"!, ?, _, @ are special characters\"\n\"if you need to use apostrophe ('), you can use double quotes\"\nIt is a good practice to stick to either single or double quotes when using strings. Interestingly, Python also supports triple quotes ''', especially for multi-line strings, i.e., strings that span multiple lines. Let us say that we want the following lines to be captured in a single string:\nfirst line\nsecond line\nthird line\nThe following code will throw a SyntaxError:\nx = 'first line\nsecond line\nthird line'\nprint(x)\nThis is where ''' comes in:\nx = '''first line\nsecond line\nthird line'''\nprint(x)\nAfter executing the above code, head to the console and type x. You will see the following output:\n'first line\\nsecond line\\nthird line'\nThe \\n character that you see above is called a newline character. Head to the section on escape characters in this lesson to know more about them.\n\n\n\nThe length of a string is the number of characters in it. Python provides a built-in function called len to find the length of a string:\nx = 'good'\nprint(len(x))\nThe code given above will give 4 as the output. If you are familiar with other programming languages, such as C, you might be aware of a character data type. Python doesn’t have a separate data type for characters. A character in Python is represented by a string of length 1. In the following examples, x and y are strings of length 1.\nx = 'a'\ny = 'b'\nWe can also define empty strings:\nx = ''\nprint(len(x))\nAs expected, the length of the empty string is 0.\n\n\n\n\n\nWe can concatenate two strings using the + operator. Concatenation is just a fancy term for joining two strings together:\nstring1 = 'first'\nstring2 = ','\nstring3 = 'second'\nstring4 = string1 + string2 + string3\nprint(string4)\nThe output is:\nfirst,second\n\n\n\nWe can make multiple copies of a string and string them all together using the * operator:\ns = 'good'\nfive_s = s * 5\nprint(five_s)\nThe is the output:\ngoodgoodgoodgoodgood\nThe * operator has made the string look too good! This is a fine demonstration of that ancient adage: “multiplication is repeated addition”:\ns = 'good'\ns * 5 == s + s + s + s + s  # This expression evaluates to True\n\n\n\nWe can compare two strings. To begin with, we have the == operator:\nx = 'python'\nprint(x == 'python', x == 'nohtyp')\nThe output is:\nTrue False\nTwo strings are equal if and only if both of them represent exactly the same sequence of characters. Now, consider the following lines of code:\nprint('good' &gt; 'bad')\nprint('nine' &lt; 'one' )\nprint('a' &lt; 'ab' &lt; 'abc' &lt; 'b')\nThe output is:\nTrue\nTrue\nTrue\nIt is clear from the above examples that the length of the string is not a metric used by Python to compare strings. Instead, Python uses the familiar alphabetical ordering to compare two strings. More precisely it employs what is known as lexicographic ordering:\n\nLexicographic ordering\nThe first characters from the two strings are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second character of both the strings are compared. This process continues until either string is exhausted.\n\nThis leads to another question. How does Python compare two characters? The answer is given in one of Python’s official tutorials:\nPython’s string type uses the Unicode standard for representing characters, which lets Python programs work with different possible characters. What is the Unicode standard? Unicode is a specification that aims to list every character used by human languages and give each character its own unique code. The Unicode standard describes how characters are represented by code points. Another unfamiliar term. What is a code point? A code point value is an integer. Lexicographical ordering for strings uses the Unicode code point number to order individual characters.\nPython provides a built-in function called ord that returns the code point of any given character. For example:\nprint(ord('a'), ord('b'))\nprint(ord('a'), ord('A'))\nThe output is:\n97 98\n97 65\nNow, we clearly see why 'a' &lt; 'b' returns True. This is because the code point for 'a' and 'b' are 97 and 98 respectively. As 97 &lt; 98, 'a' &lt; 'b'. We can also infer that 'A' &lt; 'a' should return True.\n\n\n\n\nIn Python, the backslash - \\ - is called the escape character. One of its uses is to represent certain white-space characters such as tabs and newlines. We will look at them one by one using the following examples:\nprint('This is the first sentence.\\nThis is the second sentence.')\nThe output is as follows:\nThis is the first sentence.\nThis is the second sentence.\n\\n is a newline character. Its effect is to introduce a new line. Note that even though there are two separate characters: \\ and n, \\n is still regarded as a single character. To verify this, execute the following code. You should get 1 as the output.\nx = '\\n'\nprint(len(x))\nAnother useful character is the tab: \\t:\nprint('a\\tb')\nThis will give the output:\na   b\nThere is also a way to escape the quotes: \\'. This can come in handy when using the apostrophe symbol in strings with single quotes:\nprint('India\\'s capital is New Delhi')\nThis gives the output:\nIndia's capital is New Delhi\nNow remove the backslash from the above string and try to print it. You will get an error. Why do you think that happens?\n\n\n\nA string is a substring of another string if the first string is contained in the second. For example, 'good' is a substring of 'very good', whereas 'very good' is not a substring of 'verygood'. Python provides a keyword - in - which can be used to check if a given string is a substring of another string. For example:\na = 'good'\nb = 'very good'\npresent = a in b\nprint(present)\nnot_present = b in a\nprint(not_present)\nThis gives the output:\nTrue\nFalse\nin is a powerful keyword which has several other uses. It can also be used along with not in the following manner:\na = 'abc'\nb = 'ab'\nprint(a not in b)\nThis gives the output:\nTrue"
  },
  {
    "objectID": "notes/chapter-1/lesson-1.5.html#strings",
    "href": "notes/chapter-1/lesson-1.5.html#strings",
    "title": "Lesson-1.5",
    "section": "",
    "text": "We briefly looked at strings in the first lesson. A string is any sequence of characters enclosed within single or double quotes. Some examples:\n\"this is a string\"\n'this is also a string'\n'1 + 1 = 2'\n\"!, ?, _, @ are special characters\"\n\"if you need to use apostrophe ('), you can use double quotes\"\nIt is a good practice to stick to either single or double quotes when using strings. Interestingly, Python also supports triple quotes ''', especially for multi-line strings, i.e., strings that span multiple lines. Let us say that we want the following lines to be captured in a single string:\nfirst line\nsecond line\nthird line\nThe following code will throw a SyntaxError:\nx = 'first line\nsecond line\nthird line'\nprint(x)\nThis is where ''' comes in:\nx = '''first line\nsecond line\nthird line'''\nprint(x)\nAfter executing the above code, head to the console and type x. You will see the following output:\n'first line\\nsecond line\\nthird line'\nThe \\n character that you see above is called a newline character. Head to the section on escape characters in this lesson to know more about them.\n\n\n\nThe length of a string is the number of characters in it. Python provides a built-in function called len to find the length of a string:\nx = 'good'\nprint(len(x))\nThe code given above will give 4 as the output. If you are familiar with other programming languages, such as C, you might be aware of a character data type. Python doesn’t have a separate data type for characters. A character in Python is represented by a string of length 1. In the following examples, x and y are strings of length 1.\nx = 'a'\ny = 'b'\nWe can also define empty strings:\nx = ''\nprint(len(x))\nAs expected, the length of the empty string is 0.\n\n\n\n\n\nWe can concatenate two strings using the + operator. Concatenation is just a fancy term for joining two strings together:\nstring1 = 'first'\nstring2 = ','\nstring3 = 'second'\nstring4 = string1 + string2 + string3\nprint(string4)\nThe output is:\nfirst,second\n\n\n\nWe can make multiple copies of a string and string them all together using the * operator:\ns = 'good'\nfive_s = s * 5\nprint(five_s)\nThe is the output:\ngoodgoodgoodgoodgood\nThe * operator has made the string look too good! This is a fine demonstration of that ancient adage: “multiplication is repeated addition”:\ns = 'good'\ns * 5 == s + s + s + s + s  # This expression evaluates to True\n\n\n\nWe can compare two strings. To begin with, we have the == operator:\nx = 'python'\nprint(x == 'python', x == 'nohtyp')\nThe output is:\nTrue False\nTwo strings are equal if and only if both of them represent exactly the same sequence of characters. Now, consider the following lines of code:\nprint('good' &gt; 'bad')\nprint('nine' &lt; 'one' )\nprint('a' &lt; 'ab' &lt; 'abc' &lt; 'b')\nThe output is:\nTrue\nTrue\nTrue\nIt is clear from the above examples that the length of the string is not a metric used by Python to compare strings. Instead, Python uses the familiar alphabetical ordering to compare two strings. More precisely it employs what is known as lexicographic ordering:\n\nLexicographic ordering\nThe first characters from the two strings are compared. If they differ this determines the outcome of the comparison. If they are equal, then the second character of both the strings are compared. This process continues until either string is exhausted.\n\nThis leads to another question. How does Python compare two characters? The answer is given in one of Python’s official tutorials:\nPython’s string type uses the Unicode standard for representing characters, which lets Python programs work with different possible characters. What is the Unicode standard? Unicode is a specification that aims to list every character used by human languages and give each character its own unique code. The Unicode standard describes how characters are represented by code points. Another unfamiliar term. What is a code point? A code point value is an integer. Lexicographical ordering for strings uses the Unicode code point number to order individual characters.\nPython provides a built-in function called ord that returns the code point of any given character. For example:\nprint(ord('a'), ord('b'))\nprint(ord('a'), ord('A'))\nThe output is:\n97 98\n97 65\nNow, we clearly see why 'a' &lt; 'b' returns True. This is because the code point for 'a' and 'b' are 97 and 98 respectively. As 97 &lt; 98, 'a' &lt; 'b'. We can also infer that 'A' &lt; 'a' should return True.\n\n\n\n\nIn Python, the backslash - \\ - is called the escape character. One of its uses is to represent certain white-space characters such as tabs and newlines. We will look at them one by one using the following examples:\nprint('This is the first sentence.\\nThis is the second sentence.')\nThe output is as follows:\nThis is the first sentence.\nThis is the second sentence.\n\\n is a newline character. Its effect is to introduce a new line. Note that even though there are two separate characters: \\ and n, \\n is still regarded as a single character. To verify this, execute the following code. You should get 1 as the output.\nx = '\\n'\nprint(len(x))\nAnother useful character is the tab: \\t:\nprint('a\\tb')\nThis will give the output:\na   b\nThere is also a way to escape the quotes: \\'. This can come in handy when using the apostrophe symbol in strings with single quotes:\nprint('India\\'s capital is New Delhi')\nThis gives the output:\nIndia's capital is New Delhi\nNow remove the backslash from the above string and try to print it. You will get an error. Why do you think that happens?\n\n\n\nA string is a substring of another string if the first string is contained in the second. For example, 'good' is a substring of 'very good', whereas 'very good' is not a substring of 'verygood'. Python provides a keyword - in - which can be used to check if a given string is a substring of another string. For example:\na = 'good'\nb = 'very good'\npresent = a in b\nprint(present)\nnot_present = b in a\nprint(not_present)\nThis gives the output:\nTrue\nFalse\nin is a powerful keyword which has several other uses. It can also be used along with not in the following manner:\na = 'abc'\nb = 'ab'\nprint(a not in b)\nThis gives the output:\nTrue"
  },
  {
    "objectID": "notes/chapter-8/lesson-8.4.html",
    "href": "notes/chapter-8/lesson-8.4.html",
    "title": "Lesson 8.4",
    "section": "",
    "text": "We will take up one final example of classes in action. This is to demonstrate few important points about OOP along the way.\n\n\nTo each point \\(P(x, y)\\) in 2D space, we can associate what is called a vector. Geometrically, this is a directed arrow from the origin to the point \\(P\\). That is, one tip of the vector will always be the origin and the other tip, also called the head of the vector, will be at the point \\(P\\). Here, \\(P_1\\) and \\(P_2\\) are two vectors:\n\nSome operations on vectors:\n\n\nThe magnitude of a vector \\(P(x, y)\\) is the length of the line segment \\(OP\\): \\[\n|OP| = \\sqrt{x^2 + y^2}\n\\]\n\n\n\nA vector can be scaled by a value \\(s\\). Scaling modifies the length of the vector without changing the direction in which it is pointing at. This is equivalent to the following transformation: \\[\ns \\cdot (x, y) \\rightarrow (sx, sy)\n\\]\n\n\n\nTwo vectors \\(P_1(x_1, y_1)\\) and \\(P_2(x_2, y_2)\\) can be added in the following manner: \\[\n(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)\n\\] For example:\n\n\n\n\nA vector can be rotated about the origin. A particular instance of rotation is reflection about an axis. For example, \\(P_r\\) is the reflection of \\(P\\) about the X-axis:\n\nThis corresponds to the transformation: \\[\n(x, y) \\rightarrow (x, -y)\n\\]\n\n\n\n\nFrom the mathematical vector, we need to transition to the programmatic vector. The bridge between these two states is the specification. In this step, we come up with a written description of the attributes and methods that our Vector class should possess. The source for this information comes from the mathematical vector that we just studied.\nThe following is the specification of the Vector class:\n\n\n\nx: the x-coordinate of the vector\ny: the y-coordinate of the vector\n\nThis choice is sufficient as any mathematical vector in 2D space can be completely defined with these two attributes.\n\n\n\n\n#!py __init__(): constructor of the class; populate the attributes based on the arguments\n#!py __str__(): return the coordinates of the vector in the form (x,y) when you call the #!py str() or #!py print() functions on a Vector object.\n#!py magnitude(): return the magnitude of the vector\n#!py scale(): scale the vector by some number, \\(s\\); this transformation should be applied on the current vector\n#!py rotate_xaxis(): reflect the vector about the X-axis; this transformation should be applied on the current vector\n#!py rotate_yaxis(): reflect the vector about the Y-axis; this transformation should be applied on the current vector\n#!py add(): accept a vector as argument; return the sum of this argument with the current vector\n\n\n\n\n\nThe stage is now set to define the class:\nclass Vector:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def print(self):\n        return f'({self.x},{self.y})'\n    def magnitude(self):\n        return (self.x ** 2 + self.y ** 2) ** 0.5\n    def scale(self, s):\n        self.x, self.y = self.x * s, self.y * s\n    def rotate_xaxis(self):\n        self.y = -self.y\n    def rotate_yaxis(self):\n        self.x = -self.x\n    def add(self, P):\n        result = Vector(0, 0)\n        result.x, result.y = self.x + P.x, self.y + P.y\n        return result\nMost methods are self-explanatory. Some require closer attention. Note that all methods except #!py add() and #!py __str__() do not return any value. These are methods that transform the vector itself. The method #!py add() however is interesting. It accepts a vector P as an argument! Within the method, a new Vector object is defined, it is the zero-vector. The current vector is added with P and result is stored in the newly created vector result. This is finally returned.\n\n\n\nThe whole point of having a class is to have objects. The class is just a template. Consider the following use case of a collection of objects:\ntriangle = [Vector(0, 1), Vector(3, 1), Vector(3, 0)]\nThe list triangle is a collection of objects of type Vector. In this instance, triangle represents the following triangle:\n\nWe could now ask various questions here, one of which is this: how do we compute the lengths of the sides of this triangle?\ndef dist(P1, P2):\n    return ((P1.x - P2.x) ** 2 + (P1.y - P2.y) ** 2) ** 0.5\n\ndef side_lengths(triangle):\n    la = dist(triangle[0], triangle[1])\n    lb = dist(triangle[1], triangle[2])\n    lc = dist(triangle[2], triangle[0])\n    return la, lb, lc\nIn this way, we could also define a square to be a list of four vectors. That brings to a close the discussion on object oriented programming in Python. We will cover these concepts in greater detail when we study Java."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.4.html#vector-mathematical-preliminaries",
    "href": "notes/chapter-8/lesson-8.4.html#vector-mathematical-preliminaries",
    "title": "Lesson 8.4",
    "section": "",
    "text": "To each point \\(P(x, y)\\) in 2D space, we can associate what is called a vector. Geometrically, this is a directed arrow from the origin to the point \\(P\\). That is, one tip of the vector will always be the origin and the other tip, also called the head of the vector, will be at the point \\(P\\). Here, \\(P_1\\) and \\(P_2\\) are two vectors:\n\nSome operations on vectors:\n\n\nThe magnitude of a vector \\(P(x, y)\\) is the length of the line segment \\(OP\\): \\[\n|OP| = \\sqrt{x^2 + y^2}\n\\]\n\n\n\nA vector can be scaled by a value \\(s\\). Scaling modifies the length of the vector without changing the direction in which it is pointing at. This is equivalent to the following transformation: \\[\ns \\cdot (x, y) \\rightarrow (sx, sy)\n\\]\n\n\n\nTwo vectors \\(P_1(x_1, y_1)\\) and \\(P_2(x_2, y_2)\\) can be added in the following manner: \\[\n(x_1, y_1) + (x_2, y_2) = (x_1 + x_2, y_1 + y_2)\n\\] For example:\n\n\n\n\nA vector can be rotated about the origin. A particular instance of rotation is reflection about an axis. For example, \\(P_r\\) is the reflection of \\(P\\) about the X-axis:\n\nThis corresponds to the transformation: \\[\n(x, y) \\rightarrow (x, -y)\n\\]"
  },
  {
    "objectID": "notes/chapter-8/lesson-8.4.html#vector-specification",
    "href": "notes/chapter-8/lesson-8.4.html#vector-specification",
    "title": "Lesson 8.4",
    "section": "",
    "text": "From the mathematical vector, we need to transition to the programmatic vector. The bridge between these two states is the specification. In this step, we come up with a written description of the attributes and methods that our Vector class should possess. The source for this information comes from the mathematical vector that we just studied.\nThe following is the specification of the Vector class:\n\n\n\nx: the x-coordinate of the vector\ny: the y-coordinate of the vector\n\nThis choice is sufficient as any mathematical vector in 2D space can be completely defined with these two attributes.\n\n\n\n\n#!py __init__(): constructor of the class; populate the attributes based on the arguments\n#!py __str__(): return the coordinates of the vector in the form (x,y) when you call the #!py str() or #!py print() functions on a Vector object.\n#!py magnitude(): return the magnitude of the vector\n#!py scale(): scale the vector by some number, \\(s\\); this transformation should be applied on the current vector\n#!py rotate_xaxis(): reflect the vector about the X-axis; this transformation should be applied on the current vector\n#!py rotate_yaxis(): reflect the vector about the Y-axis; this transformation should be applied on the current vector\n#!py add(): accept a vector as argument; return the sum of this argument with the current vector"
  },
  {
    "objectID": "notes/chapter-8/lesson-8.4.html#vector-definition",
    "href": "notes/chapter-8/lesson-8.4.html#vector-definition",
    "title": "Lesson 8.4",
    "section": "",
    "text": "The stage is now set to define the class:\nclass Vector:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def print(self):\n        return f'({self.x},{self.y})'\n    def magnitude(self):\n        return (self.x ** 2 + self.y ** 2) ** 0.5\n    def scale(self, s):\n        self.x, self.y = self.x * s, self.y * s\n    def rotate_xaxis(self):\n        self.y = -self.y\n    def rotate_yaxis(self):\n        self.x = -self.x\n    def add(self, P):\n        result = Vector(0, 0)\n        result.x, result.y = self.x + P.x, self.y + P.y\n        return result\nMost methods are self-explanatory. Some require closer attention. Note that all methods except #!py add() and #!py __str__() do not return any value. These are methods that transform the vector itself. The method #!py add() however is interesting. It accepts a vector P as an argument! Within the method, a new Vector object is defined, it is the zero-vector. The current vector is added with P and result is stored in the newly created vector result. This is finally returned."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.4.html#collection-of-vectors",
    "href": "notes/chapter-8/lesson-8.4.html#collection-of-vectors",
    "title": "Lesson 8.4",
    "section": "",
    "text": "The whole point of having a class is to have objects. The class is just a template. Consider the following use case of a collection of objects:\ntriangle = [Vector(0, 1), Vector(3, 1), Vector(3, 0)]\nThe list triangle is a collection of objects of type Vector. In this instance, triangle represents the following triangle:\n\nWe could now ask various questions here, one of which is this: how do we compute the lengths of the sides of this triangle?\ndef dist(P1, P2):\n    return ((P1.x - P2.x) ** 2 + (P1.y - P2.y) ** 2) ** 0.5\n\ndef side_lengths(triangle):\n    la = dist(triangle[0], triangle[1])\n    lb = dist(triangle[1], triangle[2])\n    lc = dist(triangle[2], triangle[0])\n    return la, lb, lc\nIn this way, we could also define a square to be a list of four vectors. That brings to a close the discussion on object oriented programming in Python. We will cover these concepts in greater detail when we study Java."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.1.html",
    "href": "notes/chapter-8/lesson-8.1.html",
    "title": "Lesson 8.1",
    "section": "",
    "text": "Objects are at the core of object oriented programming. With minimum jargon, let us try to understand what it all means. The simplest way of understanding the idea of objects is with the help of this wonderful phrase:\n\nUnity in diversity\n\nWhat unites all of us? We are all humans. We call this planet home.\nAnd yet, each of us is different. Each individual is unique. For example, height and weight are two obvious properties that make each individual stand out. In more philosophical terms, there are two forces in operation here: a global force that unites all of us and a local force that gives each one of us our own special identity. In the terminology of object oriented programming, each human being is an object. But all these objects belong to the class called “Humanity”.\nThis idea can be extended further. As a more mundane example, think about cars on the road. No two cars are the same. The brand of a car is one obvious point of difference. Even two cars of the same brand could be moving at different speeds. The speed of a car is another point of difference. However, a car is not the same as a train. We know a car when we see one. There are certain global features that are common to all cars and there is no mistaking that. In the terminology of object oriented programming, each car is an object. But all these objects belong to the class called “Car”.\nWe are now ready to move from the concrete to the abstract.\n\nObjects are entities that have certain attributes along with operations associated with them.\n\nFor example, cars on the road could have the following attributes: speed, fuel level. The operations associated with it could be: start, stop, accelerate, decelerate, fill fuel tank. Given this basic understanding of what we mean by objects, we are now ready to define a class:\n\nA class is a blueprint or a template that is used to create objects.\n\nThe specification of what constitutes a car is present in a class, say Car, note that capital “C”. The specification of what makes a human is present in another class, say Human. Think about a class as a Google form. A form is nothing but a template. The template is created once and then it is distributed. Each of us fills this form differently hence creating different objects.\n\nObject Oriented Programming (OOP) is a paradigm that looks at the world as a collection of objects and the interactions among them.\n\nRather than focusing on more definitions, let us jump in and look at OOP in action.\n\n\n\nConsider a very simple template for a student that has following information:\n\nName\nMarks\n\nWe want to perform the following operations:\n\nUpdate the marks of the student\nPrint student details\n\nclass Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n           \n    def update_marks(self, marks):\n        self.marks = marks\n        \n    def print_details(self):\n        print(f'{self.name}')\nclass is a keyword in Python to define classes. It is similar to the def keyword that is used to define functions. Student is the name of the class that we are creating. Within the class, we see that there are three functions: __init__, update_marks and print_details. Functions defined inside a class are given a special name, they are called methods of the class. Among the methods that can be defined for a class, __init__ holds a special place and is called the constructor. Let us first see how to create an object of type Student:\nanish = Student('Anish', 95)\nanish is now an object of type Student. To verify this, run the following command:\nprint(type(anish)) # output should be: &lt;class '__main__.Student'&gt;\nWe shall take up this example in the next lesson and understand various features of a class."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.1.html#objects-and-classes",
    "href": "notes/chapter-8/lesson-8.1.html#objects-and-classes",
    "title": "Lesson 8.1",
    "section": "",
    "text": "Objects are at the core of object oriented programming. With minimum jargon, let us try to understand what it all means. The simplest way of understanding the idea of objects is with the help of this wonderful phrase:\n\nUnity in diversity\n\nWhat unites all of us? We are all humans. We call this planet home.\nAnd yet, each of us is different. Each individual is unique. For example, height and weight are two obvious properties that make each individual stand out. In more philosophical terms, there are two forces in operation here: a global force that unites all of us and a local force that gives each one of us our own special identity. In the terminology of object oriented programming, each human being is an object. But all these objects belong to the class called “Humanity”.\nThis idea can be extended further. As a more mundane example, think about cars on the road. No two cars are the same. The brand of a car is one obvious point of difference. Even two cars of the same brand could be moving at different speeds. The speed of a car is another point of difference. However, a car is not the same as a train. We know a car when we see one. There are certain global features that are common to all cars and there is no mistaking that. In the terminology of object oriented programming, each car is an object. But all these objects belong to the class called “Car”.\nWe are now ready to move from the concrete to the abstract.\n\nObjects are entities that have certain attributes along with operations associated with them.\n\nFor example, cars on the road could have the following attributes: speed, fuel level. The operations associated with it could be: start, stop, accelerate, decelerate, fill fuel tank. Given this basic understanding of what we mean by objects, we are now ready to define a class:\n\nA class is a blueprint or a template that is used to create objects.\n\nThe specification of what constitutes a car is present in a class, say Car, note that capital “C”. The specification of what makes a human is present in another class, say Human. Think about a class as a Google form. A form is nothing but a template. The template is created once and then it is distributed. Each of us fills this form differently hence creating different objects.\n\nObject Oriented Programming (OOP) is a paradigm that looks at the world as a collection of objects and the interactions among them.\n\nRather than focusing on more definitions, let us jump in and look at OOP in action."
  },
  {
    "objectID": "notes/chapter-8/lesson-8.1.html#oop-in-python-an-example",
    "href": "notes/chapter-8/lesson-8.1.html#oop-in-python-an-example",
    "title": "Lesson 8.1",
    "section": "",
    "text": "Consider a very simple template for a student that has following information:\n\nName\nMarks\n\nWe want to perform the following operations:\n\nUpdate the marks of the student\nPrint student details\n\nclass Student:\n    def __init__(self, name, marks):\n        self.name = name\n        self.marks = marks\n           \n    def update_marks(self, marks):\n        self.marks = marks\n        \n    def print_details(self):\n        print(f'{self.name}')\nclass is a keyword in Python to define classes. It is similar to the def keyword that is used to define functions. Student is the name of the class that we are creating. Within the class, we see that there are three functions: __init__, update_marks and print_details. Functions defined inside a class are given a special name, they are called methods of the class. Among the methods that can be defined for a class, __init__ holds a special place and is called the constructor. Let us first see how to create an object of type Student:\nanish = Student('Anish', 95)\nanish is now an object of type Student. To verify this, run the following command:\nprint(type(anish)) # output should be: &lt;class '__main__.Student'&gt;\nWe shall take up this example in the next lesson and understand various features of a class."
  },
  {
    "objectID": "notes/chapter-7/lesson-7.5.html",
    "href": "notes/chapter-7/lesson-7.5.html",
    "title": "Lesson 7.5",
    "section": "",
    "text": "Now that we are familiar with reading and writing simple files, let us see how to handle slightly more complex files. CSV files1 are quite common in data science.In a CSV file, adjacent values in each line are separated by commas. A CSV file looks like this:\ncol0,col1,col2,col3\nrow1,item11,item12,item13\nrow2,item21,item22,item23\nrow3,item31,item32,item33\nrow4,item41,item42,item43\nrow5,item51,item52,item53\nSuch files are a good choice for representing tabular data. For the rest of this lesson, we will assume that CSV files are used to represent some such tabular data. The first line in the file is called the header. The header gives information about the fields or columns in the data. The rest of the lines can be treated as rows in the data. If this file is represented as a table, it would look like this:\n\n  col0 | col1 | col2 | col3 |\n|: ——– |: —— :|: —— :|: —— :| | row1 | item11 | item12 | item13 | | row2 | item21 | item22 | item23 | | row3 | item31 | item32 | item33 | | row4 | item41 | item42 | item43 | | row5 | item51 | item52 | item53 |\n\n\n\n\nLet us create a CSV file in Replit and name it table.csv:\n\n\n\nContents of table.csv\n\n\nOpening and reading a CSV file is no different from opening a text file. Let us try to print the lines in the file:\nf = open('table.csv', 'r')\nfor line in f:\n    print(line.strip())\nf.close()\nThis is the output we get:\nName,Physics,Mathematics,Chemistry\nNewton,100,98,90\nEinstein,100,85,88\nRamanujan,70,100,70\nGauss,100,100,70\nSo far so good. Now that we are able to extract the lines from the file, let us start asking some questions.\n!!! question ” ” Print the chemistry marks scored by the students, one in each line.\nThis requires us to extract the last column from the file. How do we do this? Consider any one line in the file, say the second one:\n# The `\\n` at the end will be present for all lines except the last one\nline = 'Newton,100,98,90\\n'     \nline = line.strip() # removes the \\n character\nThis is a string that corresponds to one row in the file. If we need to separate it into different columns, we need to use the #!py split() method and split the line based on a comma:\nline = 'Newton,100,98,90\\n'\nline = line.strip()\ncolumns = line.split(',')\nprint(columns)\nThis returns a list of strings:\n['Newton', '100', '98', '90']\nTo extract the last column, we just need to take the last element from this list and convert it into an integer:\nline = 'Newton,100,98,90'\nline = line.strip()\ncolumns = line.split(',')\nchem_marks = int(columns[-1])\nprint(chem_marks)\nThat is all! We have done this for one row. We need to do this for all the rows. Enter loop:\nf = open('table.csv', 'r')\nfor line in f:\n    line = line.strip()\n    columns = line.split(',')\n    chem_marks = int(columns[-1])\n    print(chem_marks)\nf.close()\nAha, but we get an error:\nTraceback (most recent call last):\n  File \"main.py\", line 5, in &lt;module&gt;\n    chem_marks = int(columns[-1])\nValueError: invalid literal for int() with base 10: 'Chemistry'\nCan you see why? We have tried to convert the last column of the header into an integer as well. The moral of the story is that when we are reading CSV files, we need to find a way to deal with the header. Let us modify our code towards that end:\nf = open('table.csv', 'r')\nheader = f.readline()       \n# The file object has finished reading the first line\n# It is now ready to read from the second line onwards\nfor line in f:\n    line = line.strip()\n    columns = line.split(',')\n    chem_marks = int(columns[-1])\n    print(chem_marks)\nf.close()\nThis works! In the second line, we read the header. Now, when the for loop starts in line 5, we are ready to read from the second line in the file. Consider the following approach that uses the #!py readlines() method alone:\nf = open('table.csv', 'r')\nlines = f.readlines()\n# lines[1: ] is the rest of the list \n# after ignoring the header\nfor line in lines[1: ]:         \n    line = line.strip()             # strip the line of \\n\n    columns = line.split(',')       # split based on comma\n    chem_marks = int(columns[-1])   # convert last column to int\n    print(chem_marks)               \nf.close()\n#!py readlines() is a reasonable choice for reading small files, say under 1000 lines. We get all the lines of the files in a list. Reading a file reduces to processing a list of strings. If lines is the list of lines, then lines[i] corresponds to the \\((i + 1)^{th}\\) line in the file. Going the other way, the \\(i^{th}\\) line in the file corresponds to the string lines[i - 1].\n!!! warning “Processing large files”\nWhen it comes to large files, `#!py readline()` is the best method to use. Processing large files is best done by reading one line at a time. Using `#!py readlines()` for large files is a dangerous idea. This is because, `#!py readlines()` dumps the entire content of the file into a list of strings. When the file is large, this list will occupy a large amount of memory. Let us try to write the same program given above using the `readline` method:\n\n```python\nf = open('table.csv', 'r')\nheader = f.readline().strip()       # this is for the header\nline = f.readline()                 # second line; actual rows begin\nwhile line:\n    line = line.strip()             # strip the line of \\n\n    columns = line.split(',')       # split based on comma\n    chem_marks = int(columns[-1])   # convert last column to int\n    print(chem_marks)\n    line = f.readline()             # read the next line in the file\nf.close()\n```\n\n\n\nIt is often useful to convert a CSV file and store in a suitable collection. We could do this in several ways. Here, let us try to create the following list of dictionaries from the file:\ndata = [\n{'Name': 'Newton', 'Physics': 100, 'Mathematics': 98, 'Chemistry': 90}, \n{'Name': 'Einstein', 'Physics': 100, 'Mathematics': 85, 'Chemistry': 88}, \n{'Name': 'Ramanujan', 'Physics': 70, 'Mathematics': 100, 'Chemistry': 70}, \n{'Name': 'Gauss', 'Physics': 100, 'Mathematics': 100, 'Chemistry': 70}]\nCouple of points to note.\n\nThis is a list of dictionaries. Each dictionary in the list corresponds to one row in the file.\nThe elements in the header appear as keys in every dictionary.\nThe values of the dictionary are of different data types. Names are strings, marks are integers.\n\nThis is going to be a fairly long code. Let us break it down. First, some basic processing to get the list of lines from the file after stripping them of the trailing newlines:\nf = open('table.csv', 'r')\nlines = [ ]\nfor line in f.readlines():\n    line = line.strip()\n    lines.append(line)\n# Now, we have the list of lines\nNext, let us get the details of the header:\npython linenums=\"7\" header = lines[0].split(',')    # lines[0] is the first row num_cols = len(header) # Now, we have the header information # We also know the number of columns in the file\nNow, it is time to go through the remaining lines in the file:\npython linenums=\"11\" ### Block-3 ### data = [ ]                      # list to store the contents for line in lines[1: ]:         # ignore the header     cols = line.split(',')      # split the column based on comma     row_dict = dict()           # create a dict to store this particular row     for i in range(num_cols):   # go through each element (column) in this row         key = header[i]         # key will be this column's name         if key == 'Name':       # are we storing a name or a number?             value = cols[i]     # since this is a name, don't convert to int         else:                value = int(cols[i])    # since this is marks, convert to int         row_dict[key] = value       # update dict     data.append(row_dict)           # append this row to the list data f.close()"
  },
  {
    "objectID": "notes/chapter-7/lesson-7.5.html#reading-csv-files",
    "href": "notes/chapter-7/lesson-7.5.html#reading-csv-files",
    "title": "Lesson 7.5",
    "section": "",
    "text": "Now that we are familiar with reading and writing simple files, let us see how to handle slightly more complex files. CSV files1 are quite common in data science.In a CSV file, adjacent values in each line are separated by commas. A CSV file looks like this:\ncol0,col1,col2,col3\nrow1,item11,item12,item13\nrow2,item21,item22,item23\nrow3,item31,item32,item33\nrow4,item41,item42,item43\nrow5,item51,item52,item53\nSuch files are a good choice for representing tabular data. For the rest of this lesson, we will assume that CSV files are used to represent some such tabular data. The first line in the file is called the header. The header gives information about the fields or columns in the data. The rest of the lines can be treated as rows in the data. If this file is represented as a table, it would look like this:\n\n  col0 | col1 | col2 | col3 |\n|: ——– |: —— :|: —— :|: —— :| | row1 | item11 | item12 | item13 | | row2 | item21 | item22 | item23 | | row3 | item31 | item32 | item33 | | row4 | item41 | item42 | item43 | | row5 | item51 | item52 | item53 |\n\n\n\n\nLet us create a CSV file in Replit and name it table.csv:\n\n\n\nContents of table.csv\n\n\nOpening and reading a CSV file is no different from opening a text file. Let us try to print the lines in the file:\nf = open('table.csv', 'r')\nfor line in f:\n    print(line.strip())\nf.close()\nThis is the output we get:\nName,Physics,Mathematics,Chemistry\nNewton,100,98,90\nEinstein,100,85,88\nRamanujan,70,100,70\nGauss,100,100,70\nSo far so good. Now that we are able to extract the lines from the file, let us start asking some questions.\n!!! question ” ” Print the chemistry marks scored by the students, one in each line.\nThis requires us to extract the last column from the file. How do we do this? Consider any one line in the file, say the second one:\n# The `\\n` at the end will be present for all lines except the last one\nline = 'Newton,100,98,90\\n'     \nline = line.strip() # removes the \\n character\nThis is a string that corresponds to one row in the file. If we need to separate it into different columns, we need to use the #!py split() method and split the line based on a comma:\nline = 'Newton,100,98,90\\n'\nline = line.strip()\ncolumns = line.split(',')\nprint(columns)\nThis returns a list of strings:\n['Newton', '100', '98', '90']\nTo extract the last column, we just need to take the last element from this list and convert it into an integer:\nline = 'Newton,100,98,90'\nline = line.strip()\ncolumns = line.split(',')\nchem_marks = int(columns[-1])\nprint(chem_marks)\nThat is all! We have done this for one row. We need to do this for all the rows. Enter loop:\nf = open('table.csv', 'r')\nfor line in f:\n    line = line.strip()\n    columns = line.split(',')\n    chem_marks = int(columns[-1])\n    print(chem_marks)\nf.close()\nAha, but we get an error:\nTraceback (most recent call last):\n  File \"main.py\", line 5, in &lt;module&gt;\n    chem_marks = int(columns[-1])\nValueError: invalid literal for int() with base 10: 'Chemistry'\nCan you see why? We have tried to convert the last column of the header into an integer as well. The moral of the story is that when we are reading CSV files, we need to find a way to deal with the header. Let us modify our code towards that end:\nf = open('table.csv', 'r')\nheader = f.readline()       \n# The file object has finished reading the first line\n# It is now ready to read from the second line onwards\nfor line in f:\n    line = line.strip()\n    columns = line.split(',')\n    chem_marks = int(columns[-1])\n    print(chem_marks)\nf.close()\nThis works! In the second line, we read the header. Now, when the for loop starts in line 5, we are ready to read from the second line in the file. Consider the following approach that uses the #!py readlines() method alone:\nf = open('table.csv', 'r')\nlines = f.readlines()\n# lines[1: ] is the rest of the list \n# after ignoring the header\nfor line in lines[1: ]:         \n    line = line.strip()             # strip the line of \\n\n    columns = line.split(',')       # split based on comma\n    chem_marks = int(columns[-1])   # convert last column to int\n    print(chem_marks)               \nf.close()\n#!py readlines() is a reasonable choice for reading small files, say under 1000 lines. We get all the lines of the files in a list. Reading a file reduces to processing a list of strings. If lines is the list of lines, then lines[i] corresponds to the \\((i + 1)^{th}\\) line in the file. Going the other way, the \\(i^{th}\\) line in the file corresponds to the string lines[i - 1].\n!!! warning “Processing large files”\nWhen it comes to large files, `#!py readline()` is the best method to use. Processing large files is best done by reading one line at a time. Using `#!py readlines()` for large files is a dangerous idea. This is because, `#!py readlines()` dumps the entire content of the file into a list of strings. When the file is large, this list will occupy a large amount of memory. Let us try to write the same program given above using the `readline` method:\n\n```python\nf = open('table.csv', 'r')\nheader = f.readline().strip()       # this is for the header\nline = f.readline()                 # second line; actual rows begin\nwhile line:\n    line = line.strip()             # strip the line of \\n\n    columns = line.split(',')       # split based on comma\n    chem_marks = int(columns[-1])   # convert last column to int\n    print(chem_marks)\n    line = f.readline()             # read the next line in the file\nf.close()\n```\n\n\n\nIt is often useful to convert a CSV file and store in a suitable collection. We could do this in several ways. Here, let us try to create the following list of dictionaries from the file:\ndata = [\n{'Name': 'Newton', 'Physics': 100, 'Mathematics': 98, 'Chemistry': 90}, \n{'Name': 'Einstein', 'Physics': 100, 'Mathematics': 85, 'Chemistry': 88}, \n{'Name': 'Ramanujan', 'Physics': 70, 'Mathematics': 100, 'Chemistry': 70}, \n{'Name': 'Gauss', 'Physics': 100, 'Mathematics': 100, 'Chemistry': 70}]\nCouple of points to note.\n\nThis is a list of dictionaries. Each dictionary in the list corresponds to one row in the file.\nThe elements in the header appear as keys in every dictionary.\nThe values of the dictionary are of different data types. Names are strings, marks are integers.\n\nThis is going to be a fairly long code. Let us break it down. First, some basic processing to get the list of lines from the file after stripping them of the trailing newlines:\nf = open('table.csv', 'r')\nlines = [ ]\nfor line in f.readlines():\n    line = line.strip()\n    lines.append(line)\n# Now, we have the list of lines\nNext, let us get the details of the header:\npython linenums=\"7\" header = lines[0].split(',')    # lines[0] is the first row num_cols = len(header) # Now, we have the header information # We also know the number of columns in the file\nNow, it is time to go through the remaining lines in the file:\npython linenums=\"11\" ### Block-3 ### data = [ ]                      # list to store the contents for line in lines[1: ]:         # ignore the header     cols = line.split(',')      # split the column based on comma     row_dict = dict()           # create a dict to store this particular row     for i in range(num_cols):   # go through each element (column) in this row         key = header[i]         # key will be this column's name         if key == 'Name':       # are we storing a name or a number?             value = cols[i]     # since this is a name, don't convert to int         else:                value = int(cols[i])    # since this is marks, convert to int         row_dict[key] = value       # update dict     data.append(row_dict)           # append this row to the list data f.close()"
  },
  {
    "objectID": "notes/chapter-7/lesson-7.5.html#footnotes",
    "href": "notes/chapter-7/lesson-7.5.html#footnotes",
    "title": "Lesson 7.5",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCSV stands for comma-seperated values. Learn more about this file type here↩︎"
  },
  {
    "objectID": "notes/chapter-7/lesson-7.1.html",
    "href": "notes/chapter-7/lesson-7.1.html",
    "title": "Lesson 7.1",
    "section": "",
    "text": "The best way to motivate files is to take the human example. Consider our memory. There is a certain volume of information that we can retain in our working memory. A popular claim is that we can retain around seven chunks of information in our short-term memory. Anything that exceeds this volume of information, we have to resort to external aids such as notebooks.\nSomething similar happens in computers. Modern day computers are quite powerful and can retain several chunks of information at a time. Though computers are machines, the amount of short-term memory that they possess is still finite. This is where the idea of external storage comes in. Files are to computers what books are to humans. A file is used to record information in a permanent location so that it can be retrieved as and when needed.\n\n\n\nWe are all used to opening files in our computers by simply double clicking on an icon. Let us take the example of a simple file having the following contents:\nIncome      Expenditure\n12,000      10,000\n50,000      45,000\n75,000      35,000\n14,000      12,000\n60,000      40,000\nThis file has the income-expenditure details of a family for five months. We wish to create a new file that has the savings details added as a third column. That is, we wish to generate the following file:\nIncome      Expenditure     Savings\n12,000      10,000          2,000\n50,000      45,000          5,000\n75,000      35,000          40,000\n14,000      12,000          2,000\n60,000      40,000          20,000\nThis seems like a simple task. Open this file, plug the numbers in the calculator, get the result and paste it in a new column and we are done. But what if the number of entries in the file increases? For example, let us say we wish to perform this operation for all families in the neighborhood. If we have 10 years worth data for 1000 families, we are looking at \\(1000 * 10 * 12 = 120,000\\) entries! Our calculator will break down and so will we out of exhaustion.\nThis is where Python comes to our rescue. We can write a piece of code to automate the whole process. And all it is going to take is a few lines of code! In the next few lessons, we will see how to process files. We will learn the following operations:\n\nopening a file and closing it\nreading from a file\nwriting to a file\n\nFile handling is an umbrella term that denotes all these operations."
  },
  {
    "objectID": "notes/chapter-7/lesson-7.1.html#file-handling",
    "href": "notes/chapter-7/lesson-7.1.html#file-handling",
    "title": "Lesson 7.1",
    "section": "",
    "text": "The best way to motivate files is to take the human example. Consider our memory. There is a certain volume of information that we can retain in our working memory. A popular claim is that we can retain around seven chunks of information in our short-term memory. Anything that exceeds this volume of information, we have to resort to external aids such as notebooks.\nSomething similar happens in computers. Modern day computers are quite powerful and can retain several chunks of information at a time. Though computers are machines, the amount of short-term memory that they possess is still finite. This is where the idea of external storage comes in. Files are to computers what books are to humans. A file is used to record information in a permanent location so that it can be retrieved as and when needed.\n\n\n\nWe are all used to opening files in our computers by simply double clicking on an icon. Let us take the example of a simple file having the following contents:\nIncome      Expenditure\n12,000      10,000\n50,000      45,000\n75,000      35,000\n14,000      12,000\n60,000      40,000\nThis file has the income-expenditure details of a family for five months. We wish to create a new file that has the savings details added as a third column. That is, we wish to generate the following file:\nIncome      Expenditure     Savings\n12,000      10,000          2,000\n50,000      45,000          5,000\n75,000      35,000          40,000\n14,000      12,000          2,000\n60,000      40,000          20,000\nThis seems like a simple task. Open this file, plug the numbers in the calculator, get the result and paste it in a new column and we are done. But what if the number of entries in the file increases? For example, let us say we wish to perform this operation for all families in the neighborhood. If we have 10 years worth data for 1000 families, we are looking at \\(1000 * 10 * 12 = 120,000\\) entries! Our calculator will break down and so will we out of exhaustion.\nThis is where Python comes to our rescue. We can write a piece of code to automate the whole process. And all it is going to take is a few lines of code! In the next few lessons, we will see how to process files. We will learn the following operations:\n\nopening a file and closing it\nreading from a file\nwriting to a file\n\nFile handling is an umbrella term that denotes all these operations."
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html",
    "href": "notes/chapter-0/lesson-0.html",
    "title": "Lesson-0",
    "section": "",
    "text": "The strongest reasons are utility and popularity. Python powers a large number of applications and is used by companies like Google, Netflix, Dropbox, Quora. If a language is popular in the developer community, then there must be something good about it. In a 2023 survey conducted by the company StackOverflow, Python was rated as the third most popular language.\n\nNearly \\(50\\%\\) of the \\(87,585\\) respondents voted for Python as the most popular technology. Another strong reason to learn Python is that it lets us create beautiful things such as this animation1:\n\nThis was the code used to generate this video:\n\n\nCode\n\nfrom manim import *\nclass sinx(GraphScene, MovingCameraScene):\n    def setup(self):\n        GraphScene.setup(self)\n    def construct(self):\n        # Setup graph\n        self.camera.frame.save_state()\n        self.graph_origin = 3.5 * LEFT,\n        self.x_max = round(5 * PI) + 1\n        self.y_min, self.y_max = -1.5, 1.5\n        self.setup_axes(animate=True)\n        # Graph to be plotted\n        graph = self.get_graph(lambda x: np.sin(x),\n                               color = BLUE,\n                               x_min = 0,\n                               x_max = 5 * PI\n                               )\n        # Place dots\n        moving_dot = Dot().move_to(graph.points[0]).set_color(ORANGE)\n        dot_at_start_graph = Dot().move_to(graph.points[0])\n        dot_at_end_graph = Dot().move_to(graph.points[-1])\n        # Draw Graph\n        self.wait(1)\n        self.play(ShowCreation(graph), run_time = 4)\n        self.wait(1)\n        # Write Equation\n        equation = MathTex('y = \\sin(x)').move_to(5.5 * LEFT)\n        self.play(Write(equation), run_time = 3)\n        self.wait(1)\n        # Move camera\n        self.add(dot_at_end_graph, dot_at_start_graph, moving_dot)\n        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))\n        def update_curve(mob):\n            mob.move_to(moving_dot.get_center())\n        self.camera.frame.add_updater(update_curve)\n        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear), run_time = 5)\n        self.camera.frame.remove_updater(update_curve)\n        # Restore position\n        self.play(Restore(self.camera.frame))\n        self.wait(1)\n\nBeing able to create something like this is the end goal of this course. Musicians create music; musical instruments are their tools. Painters create paintings; the brush and the canvas are their tools. Coders create software; programming languages are their tools. Python is one of the most versatile and accessible languages out there in the universe of programming languages. It is a suitable choice to be the first language for beginners."
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html#why-learn-python",
    "href": "notes/chapter-0/lesson-0.html#why-learn-python",
    "title": "Lesson-0",
    "section": "",
    "text": "The strongest reasons are utility and popularity. Python powers a large number of applications and is used by companies like Google, Netflix, Dropbox, Quora. If a language is popular in the developer community, then there must be something good about it. In a 2023 survey conducted by the company StackOverflow, Python was rated as the third most popular language.\n\nNearly \\(50\\%\\) of the \\(87,585\\) respondents voted for Python as the most popular technology. Another strong reason to learn Python is that it lets us create beautiful things such as this animation1:\n\nThis was the code used to generate this video:\n\n\nCode\n\nfrom manim import *\nclass sinx(GraphScene, MovingCameraScene):\n    def setup(self):\n        GraphScene.setup(self)\n    def construct(self):\n        # Setup graph\n        self.camera.frame.save_state()\n        self.graph_origin = 3.5 * LEFT,\n        self.x_max = round(5 * PI) + 1\n        self.y_min, self.y_max = -1.5, 1.5\n        self.setup_axes(animate=True)\n        # Graph to be plotted\n        graph = self.get_graph(lambda x: np.sin(x),\n                               color = BLUE,\n                               x_min = 0,\n                               x_max = 5 * PI\n                               )\n        # Place dots\n        moving_dot = Dot().move_to(graph.points[0]).set_color(ORANGE)\n        dot_at_start_graph = Dot().move_to(graph.points[0])\n        dot_at_end_graph = Dot().move_to(graph.points[-1])\n        # Draw Graph\n        self.wait(1)\n        self.play(ShowCreation(graph), run_time = 4)\n        self.wait(1)\n        # Write Equation\n        equation = MathTex('y = \\sin(x)').move_to(5.5 * LEFT)\n        self.play(Write(equation), run_time = 3)\n        self.wait(1)\n        # Move camera\n        self.add(dot_at_end_graph, dot_at_start_graph, moving_dot)\n        self.play(self.camera.frame.animate.scale(0.5).move_to(moving_dot))\n        def update_curve(mob):\n            mob.move_to(moving_dot.get_center())\n        self.camera.frame.add_updater(update_curve)\n        self.play(MoveAlongPath(moving_dot, graph, rate_func=linear), run_time = 5)\n        self.camera.frame.remove_updater(update_curve)\n        # Restore position\n        self.play(Restore(self.camera.frame))\n        self.wait(1)\n\nBeing able to create something like this is the end goal of this course. Musicians create music; musical instruments are their tools. Painters create paintings; the brush and the canvas are their tools. Coders create software; programming languages are their tools. Python is one of the most versatile and accessible languages out there in the universe of programming languages. It is a suitable choice to be the first language for beginners."
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html#lessons",
    "href": "notes/chapter-0/lesson-0.html#lessons",
    "title": "Lesson-0",
    "section": "Lessons",
    "text": "Lessons\n\nOrganization\nThe notes are organized as a sequence of chapters each containing a set of lessons. Lessons will be numbered as &lt;chapter&gt;.&lt;lesson&gt;. Each chapter will have about four lessons. These lessons are best read in the sequence in which they appear, starting from chapter-1 and going all the way up to chapter-8. If you are already familiar with Python, then have a look at the table of contents in the home page and jump into the lesson that seems least familiar.\nEach chapter introduces one important programming concept in Python. This will be that chapter’s title. This doesn’t mean that all the lessons in the chapter will focus on only that particular concept. For example, chapter-2 introduces the idea of conditionals, but built-in functions and Python’s standard libraries also feature in the same week.\nThe outline of the notes is as follows:\n\nChapter-1: Introduction to Python\nChapter-2: Conditionals\nChapter-3: Loops\nChapter-4: Functions\nChapter-5: Lists and Tuples\nChapter-6: Sets and dictionaries\nChapter-7: File handling\nChapter-8: Object Oriented Programming\n\n\n\nHow to read these lessons?\n\nDo not trust any piece of code blindly.\nExecute the code and observe the output.\nThink about the output.\nVerify if the explanation given in the text matches your observations.\n\nProgramming courses are among the few courses where the learner has an upper hand over instructors. No one can trick you. Code does not lie. All that is demanded of you is to make an effort to execute every snippet of code that you see in these lessons.\n\n\nPython Version\nWe will be using Python-3.8 or higher throughout these lessons. If some of you are already familiar with Python and are used to Python-2, it is strongly recommended that you shift to Python-3. This is not an arbitrary choice as Python-2 has reached the end of its life."
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html#online-programming-environments",
    "href": "notes/chapter-0/lesson-0.html#online-programming-environments",
    "title": "Lesson-0",
    "section": "Online Programming Environments",
    "text": "Online Programming Environments\nYou can try out either Replit or Google Colab. Both are excellent choices to learn programming. The advantage is that you can do all your coding on the browser without having to install anything locally on your system. Files created by you will live on the cloud and will be autosaved as and when you type code. This way, you can stop worrying about installing Python on your system and focus more on learning how to code."
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html#installing-python-on-your-system",
    "href": "notes/chapter-0/lesson-0.html#installing-python-on-your-system",
    "title": "Lesson-0",
    "section": "Installing Python on your System",
    "text": "Installing Python on your System\nHowever, if you wish to use Python on your system, you can install it from here. You can refer to this guide to get a step-by-step process of installing Python. Having a functional Python environment on your system will be useful in some of the subjects in the programming diploma."
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html#history",
    "href": "notes/chapter-0/lesson-0.html#history",
    "title": "Lesson-0",
    "section": "History",
    "text": "History\nPython first appeared on the programming landscape more than 30 years ago, in February 1991. It was created as a hobby project by a Dutch programmer, Guido van Rossum. He served as the benevolent dictator for life of Python’s development until 2018, when he stepped down from the post.\n\n\n\nGuido Van Rossum at the Dropbox Headquarters in 20142\n\n\nA popular question that gets asked often is how the language got its name. This is the answer from the official Python documentation:\n\nWhen he began implementing Python, Guido van Rossum was also reading the published scripts from “Monty Python’s Flying Circus”, a BBC comedy series from the 1970s. Van Rossum thought he needed a name that was short, unique, and slightly mysterious, so he decided to call the language Python.\n\nProgrammers who boarded the Python-bus more than 30 years back lovingly talk of it as though it were a friend. This is not an exaggeration! This is a language that has been built by people like you and me, and is being used by thousands of people around the globe. Let us jump in with an open mind and see what it has to offer!"
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html#explore",
    "href": "notes/chapter-0/lesson-0.html#explore",
    "title": "Lesson-0",
    "section": "Explore",
    "text": "Explore\n\nCheck out the website of the Python Software Foundation and get to know more about the organization behind Python.\nHave a look at this interesting interview of Guido Van Rossum. This is a blog maintained by Dropbox. Another trivia: Guido worked at Dropbox for six and a half years.\nTry to watch documentaries and interviews on the web where Guido talks about how Python came into existence. It is always good to know about some non-technical aspects of the language, such as its history and something about the people who were behind its development. It gives a humanistic flavor to technology. We often forget that a lot of software is written by humans, for humans.\nIn the next few weeks to come, StackOverflow might become the most visited website by most of you. Some of you might be familiar with it, but for the others, StackOverflow is a question-answer forum for programming related questions. It is extremely popular not just among beginners but even experienced developers. Do check it out, but use it wisely. Refrain from using it to get answers to assignment questions; you won’t learn anything that way.\nYou can also look into the official documentation on the python website."
  },
  {
    "objectID": "notes/chapter-0/lesson-0.html#footnotes",
    "href": "notes/chapter-0/lesson-0.html#footnotes",
    "title": "Lesson-0",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThanks to Manim Community for the source code. The code that was used to render this animation can be found here.↩︎\nImage-Source: Wikipedia↩︎"
  },
  {
    "objectID": "notes/chapter-3/lesson-3.1.html",
    "href": "notes/chapter-3/lesson-3.1.html",
    "title": "Lesson-3.1",
    "section": "",
    "text": "Consider the following problem:\n!!! question ” ” Print the sum of the first five positive integers.\nWith our current knowledge of Python, how do we solve this?\nprint(1 + 2 + 3 + 4 + 5)\nNot a very elegant solution, but it gets the job done. Now, how about the following problem?\n!!! question ” ” Print the sum of the first 1,000,000 positive integers.\nThe earlier approach is not going to work. One million is just too big a number to count down to. Let’s take a diversion and instead ponder: If it takes about five seconds on average to write a number followed by the #!py + symbol, how much time will it take to find the sum of all 1 million numbers? Let’s find an answer using python:\n\nnum = 1_000_000     # _ in a number is used when we have large numbers; improves readability\navg_time = 5\nseconds = num * avg_time\nminutes = seconds / 60\nhours = minutes / 60\ndays = hours / 24\nprint('Approximate number of days =', round(days))\nIt will take nearly 58 days to sum all 1 million integers! This is assuming that we work like machines that don’t need food or sleep. All of this just to do something as trivial as finding the sum of numbers. This is where loops come in.\n\n\n\n#!py while is a keyword in Python. The expression adjacent to #!py while is a boolean expression, called the while condition, or just the condition. The loopy solution to the problem:\ntotal = 0\nnum = 0\nwhile num &lt; 1_000_000:\n    num = num + 1\n    total = total + num\nprint(total)\n# Rest of code will follow below this comment\nThere’s a lot to unpack here. Lines 4 and 5 make up the body of while. If the condition evaluates to True, control enters the body of while. The lines in the body are sequentially executed. After the last line in the body is executed, the control loops back to line 3, where the condition is evaluated again. As long as the condition is True, the body of while keeps getting executed. The moment the condition becomes False, the body of the while is skipped and control transfers to line 6. The body of the while loop must always be indented; this helps to separate it from the rest of the code.\nA visual representation is given below:\n\n\n\nControl flow of while\n\n\nLet us consider another example:\n!!! question ” ” Keep accepting integers as input from the user until the user enters a negative number. Print the sum of the positive numbers entered by the user. Print 0 if the user doesn’t enter any positive integer.\nThe visual representation of the code is given below:\n\n\n\nPrevious code explained\n\n\nOne final example before closing this section:\n!!! question ” ” Keep accepting integers as input from the user until the user enters a negative number. Print the maximum among the positive numbers entered by the user. Print 0 if the user doesn’t enter any positive integer.\nSolution\n# Initialize\nnum = int(input())\nmax_num = 0\n# Loop\nwhile num &gt;= 0:\n    if num &gt; max_num:\n        max_num = num\n    num = int(input())\n# Print output\nprint(max_num)\nNote that lines 6-8 make up the body of #!py while and are indented. Lines 1, 4 and 9 have some comments which are meant to help the reader understand what is happening in the code that follows them.\n\n\n\n\n#!py break and #!py continue are keywords in Python and are associated with loops. The #!py break statement is used to exit out of a loop without executing any code that comes below it. For example:\nnum = 1\nwhile True:\n    if (num % 2 == 0) and (num % 3 == 0) and (num % 4 == 0):\n        break\n    num = num + 1\nprint(num)\nThe above code prints the smallest positive integer that is divisible by 2, 3 and 4, which is the same as the LCM of \\((2, 3, 4)\\). The moment this number is found, the code breaks out of the loop.\nThe #!py continue statement is used to move to the next iteration of the loop, skipping whatever code comes below it. For example:\nx = 0\nwhile x &lt; 50:\n    x = x + 1\n    if x % 3 != 0:\n        continue\n    print(x)\nThe code given above prints all positive integers less than or equal to 50 that are divisible by 3. Whenever x is not divisible by 3, we do not want to print the number, so we continue to the next iteration.\nThe similarity between #!py break and #!py continue is that whenever either statement is encountered in a loop, all the statements that follow it are skipped. The main difference is that, #!py break exits the loop whereas #!py continue moves to the next iteration.\n#!py break and #!py continue are interesting features offered by Python. However, it is important to note that both the examples that we just discussed can be written without using #!py break or #!py continue. It is left as an exercise for the reader to figure out how this can be done."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.1.html#loops",
    "href": "notes/chapter-3/lesson-3.1.html#loops",
    "title": "Lesson-3.1",
    "section": "",
    "text": "Consider the following problem:\n!!! question ” ” Print the sum of the first five positive integers.\nWith our current knowledge of Python, how do we solve this?\nprint(1 + 2 + 3 + 4 + 5)\nNot a very elegant solution, but it gets the job done. Now, how about the following problem?\n!!! question ” ” Print the sum of the first 1,000,000 positive integers.\nThe earlier approach is not going to work. One million is just too big a number to count down to. Let’s take a diversion and instead ponder: If it takes about five seconds on average to write a number followed by the #!py + symbol, how much time will it take to find the sum of all 1 million numbers? Let’s find an answer using python:\n\nnum = 1_000_000     # _ in a number is used when we have large numbers; improves readability\navg_time = 5\nseconds = num * avg_time\nminutes = seconds / 60\nhours = minutes / 60\ndays = hours / 24\nprint('Approximate number of days =', round(days))\nIt will take nearly 58 days to sum all 1 million integers! This is assuming that we work like machines that don’t need food or sleep. All of this just to do something as trivial as finding the sum of numbers. This is where loops come in.\n\n\n\n#!py while is a keyword in Python. The expression adjacent to #!py while is a boolean expression, called the while condition, or just the condition. The loopy solution to the problem:\ntotal = 0\nnum = 0\nwhile num &lt; 1_000_000:\n    num = num + 1\n    total = total + num\nprint(total)\n# Rest of code will follow below this comment\nThere’s a lot to unpack here. Lines 4 and 5 make up the body of while. If the condition evaluates to True, control enters the body of while. The lines in the body are sequentially executed. After the last line in the body is executed, the control loops back to line 3, where the condition is evaluated again. As long as the condition is True, the body of while keeps getting executed. The moment the condition becomes False, the body of the while is skipped and control transfers to line 6. The body of the while loop must always be indented; this helps to separate it from the rest of the code.\nA visual representation is given below:\n\n\n\nControl flow of while\n\n\nLet us consider another example:\n!!! question ” ” Keep accepting integers as input from the user until the user enters a negative number. Print the sum of the positive numbers entered by the user. Print 0 if the user doesn’t enter any positive integer.\nThe visual representation of the code is given below:\n\n\n\nPrevious code explained\n\n\nOne final example before closing this section:\n!!! question ” ” Keep accepting integers as input from the user until the user enters a negative number. Print the maximum among the positive numbers entered by the user. Print 0 if the user doesn’t enter any positive integer.\nSolution\n# Initialize\nnum = int(input())\nmax_num = 0\n# Loop\nwhile num &gt;= 0:\n    if num &gt; max_num:\n        max_num = num\n    num = int(input())\n# Print output\nprint(max_num)\nNote that lines 6-8 make up the body of #!py while and are indented. Lines 1, 4 and 9 have some comments which are meant to help the reader understand what is happening in the code that follows them.\n\n\n\n\n#!py break and #!py continue are keywords in Python and are associated with loops. The #!py break statement is used to exit out of a loop without executing any code that comes below it. For example:\nnum = 1\nwhile True:\n    if (num % 2 == 0) and (num % 3 == 0) and (num % 4 == 0):\n        break\n    num = num + 1\nprint(num)\nThe above code prints the smallest positive integer that is divisible by 2, 3 and 4, which is the same as the LCM of \\((2, 3, 4)\\). The moment this number is found, the code breaks out of the loop.\nThe #!py continue statement is used to move to the next iteration of the loop, skipping whatever code comes below it. For example:\nx = 0\nwhile x &lt; 50:\n    x = x + 1\n    if x % 3 != 0:\n        continue\n    print(x)\nThe code given above prints all positive integers less than or equal to 50 that are divisible by 3. Whenever x is not divisible by 3, we do not want to print the number, so we continue to the next iteration.\nThe similarity between #!py break and #!py continue is that whenever either statement is encountered in a loop, all the statements that follow it are skipped. The main difference is that, #!py break exits the loop whereas #!py continue moves to the next iteration.\n#!py break and #!py continue are interesting features offered by Python. However, it is important to note that both the examples that we just discussed can be written without using #!py break or #!py continue. It is left as an exercise for the reader to figure out how this can be done."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.5.html",
    "href": "notes/chapter-3/lesson-3.5.html",
    "title": "Lesson-3.5",
    "section": "",
    "text": "We will look at two more libraries — math and random — and use them to solve some fascinating problems in mathematics.\n\n\nConsider the following sequence: \\[\n\\sqrt{2}, \\sqrt{2 + \\sqrt{2}}, \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}},\\ \\dots\n\\] Mathematically, it is known that this sequence converges or approaches a specific value. In other words, this sequence gets closer and closer to a well defined number as more terms are added. This number is called the limit of the sequence. What is the limit for the above sequence? Can we use whatever we have learned so far to estimate this value?\nimport math\nx = 0\nfor n in range(1, 6):\n    x = math.sqrt(2 + x)\n    print(f'n = {n}, x_n = {x:.3f}')\nIf we execute the above code, we get the following output:\nn = 1, x_n = 1.414\nn = 2, x_n = 1.848\nn = 3, x_n = 1.962\nn = 4, x_n = 1.990\nn = 5, x_n = 1.998\n#!py sqrt() is a function in the math library that returns the square root of the number that is entered as argument. Representing the output shown above as a table:\n\n\\(n\\) | \\(x_n\\) | Approximate value |\n—- |: —————————————————— :| —————– :|\n1 | \\(\\sqrt{2}\\) | 1.414 |\n2 | \\(\\sqrt{2 + \\sqrt{2}}\\) | 1.848 |\n3 | \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}\\) | 1.962 |\n4 | \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}\\) | 1.990 |\n5 | \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}}\\) | 1.998 |\n\nIsn’t that beautiful? It looks like this sequence — the train of square roots — is approaching the value 2. Let us run the loop for more number of iterations this time:\nimport math\nx = 0\nfor n in range(1, 20):\n    x = math.sqrt(2 + x)\nprint(x)\nAfter just 20 iterations, the value is so close to two: #!py 1.9999999999910236. But we have used trial and error to decide when to terminate the iteration. A better way to do this is to define a tolerance: if the difference between the previous value and the current value in the sequence is less than some predefined value (tolerance), then we terminate the iteration.\nimport math\nx_prev, x_curr = 0, math.sqrt(2)\ntol, count = 0.00001, 0\nwhile abs(x_curr - x_prev) &gt;= tol:\n    x_prev = x_curr\n    x_curr = math.sqrt(2 + x_prev)\n    count += 1\nprint(f'Value of x at {tol} tolerance is {x_curr}')\nprint(f'It took {count} iterations')\n\n\n\nHow do we toss a coin using Python?\nimport random\nprint(random.choice('HT'))\nThat is all there is to it! random is a library and #!py choice() is a function defined in it. It accepts any sequence as input and returns an element chosen at random from this sequence. In this case, the input is a string, which is nothing but a sequence of characters.\nWe know that the probability of obtaining a head on a coin toss is 0.5. This is the theory. Is there a way to see this rule in action? Can we computationally verify if this is indeed the case? For that, we have to set up the following experiment. Toss a coin \\(n\\) times and count the number of heads. Dividing the total number of heads by \\(n\\) will give the empirical probability. As \\(n\\) becomes large, this probability must approach 0.5.\nimport random\nn = int(input())\nheads = 0\nfor i in range(n):\n    toss = random.choice('HT')\n    if toss == 'H':\n        heads += 1\nprint(f'P(H) = {heads / n}')\nLet us run the above code for different values of \\(n\\) and tabulate our results:\n\n\n\n\n\\(n\\)\n\\(P(H)\\)\n\n\n\n\n10\n0.2\n\n\n100\n0.52\n\n\n1,000\n0.517\n\n\n10,000\n0.5033\n\n\n100,000\n0.49926\n\n\n1,000,000\n0.499983\n\n\n\n\nThe value is approaching #!py 0.5 as expected! random is quite versatile.\n\n!!! question “Exercise” Let us now roll a dice! randint(a, b) returns a random integer \\(N\\) such that \\(a \\leq N \\leq b\\).\n```python\nimport random\nprint(random.randint(1, 6))\n```\n\nNow find the empirical probability for the numbers on each face of a die using this function."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.5.html#library",
    "href": "notes/chapter-3/lesson-3.5.html#library",
    "title": "Lesson-3.5",
    "section": "",
    "text": "We will look at two more libraries — math and random — and use them to solve some fascinating problems in mathematics.\n\n\nConsider the following sequence: \\[\n\\sqrt{2}, \\sqrt{2 + \\sqrt{2}}, \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}},\\ \\dots\n\\] Mathematically, it is known that this sequence converges or approaches a specific value. In other words, this sequence gets closer and closer to a well defined number as more terms are added. This number is called the limit of the sequence. What is the limit for the above sequence? Can we use whatever we have learned so far to estimate this value?\nimport math\nx = 0\nfor n in range(1, 6):\n    x = math.sqrt(2 + x)\n    print(f'n = {n}, x_n = {x:.3f}')\nIf we execute the above code, we get the following output:\nn = 1, x_n = 1.414\nn = 2, x_n = 1.848\nn = 3, x_n = 1.962\nn = 4, x_n = 1.990\nn = 5, x_n = 1.998\n#!py sqrt() is a function in the math library that returns the square root of the number that is entered as argument. Representing the output shown above as a table:\n\n\\(n\\) | \\(x_n\\) | Approximate value |\n—- |: —————————————————— :| —————– :|\n1 | \\(\\sqrt{2}\\) | 1.414 |\n2 | \\(\\sqrt{2 + \\sqrt{2}}\\) | 1.848 |\n3 | \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}\\) | 1.962 |\n4 | \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}\\) | 1.990 |\n5 | \\(\\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2 + \\sqrt{2}}}}}\\) | 1.998 |\n\nIsn’t that beautiful? It looks like this sequence — the train of square roots — is approaching the value 2. Let us run the loop for more number of iterations this time:\nimport math\nx = 0\nfor n in range(1, 20):\n    x = math.sqrt(2 + x)\nprint(x)\nAfter just 20 iterations, the value is so close to two: #!py 1.9999999999910236. But we have used trial and error to decide when to terminate the iteration. A better way to do this is to define a tolerance: if the difference between the previous value and the current value in the sequence is less than some predefined value (tolerance), then we terminate the iteration.\nimport math\nx_prev, x_curr = 0, math.sqrt(2)\ntol, count = 0.00001, 0\nwhile abs(x_curr - x_prev) &gt;= tol:\n    x_prev = x_curr\n    x_curr = math.sqrt(2 + x_prev)\n    count += 1\nprint(f'Value of x at {tol} tolerance is {x_curr}')\nprint(f'It took {count} iterations')\n\n\n\nHow do we toss a coin using Python?\nimport random\nprint(random.choice('HT'))\nThat is all there is to it! random is a library and #!py choice() is a function defined in it. It accepts any sequence as input and returns an element chosen at random from this sequence. In this case, the input is a string, which is nothing but a sequence of characters.\nWe know that the probability of obtaining a head on a coin toss is 0.5. This is the theory. Is there a way to see this rule in action? Can we computationally verify if this is indeed the case? For that, we have to set up the following experiment. Toss a coin \\(n\\) times and count the number of heads. Dividing the total number of heads by \\(n\\) will give the empirical probability. As \\(n\\) becomes large, this probability must approach 0.5.\nimport random\nn = int(input())\nheads = 0\nfor i in range(n):\n    toss = random.choice('HT')\n    if toss == 'H':\n        heads += 1\nprint(f'P(H) = {heads / n}')\nLet us run the above code for different values of \\(n\\) and tabulate our results:\n\n\n\n\n\\(n\\)\n\\(P(H)\\)\n\n\n\n\n10\n0.2\n\n\n100\n0.52\n\n\n1,000\n0.517\n\n\n10,000\n0.5033\n\n\n100,000\n0.49926\n\n\n1,000,000\n0.499983\n\n\n\n\nThe value is approaching #!py 0.5 as expected! random is quite versatile.\n\n!!! question “Exercise” Let us now roll a dice! randint(a, b) returns a random integer \\(N\\) such that \\(a \\leq N \\leq b\\).\n```python\nimport random\nprint(random.randint(1, 6))\n```\n\nNow find the empirical probability for the numbers on each face of a die using this function."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.4.html",
    "href": "notes/chapter-3/lesson-3.4.html",
    "title": "Lesson-3.4",
    "section": "",
    "text": "Consider the following program:\nname = input()\nprint('Hi,', name, '!')\nWhen this code is executed with Sachin as the input, we get the following output:\nHi, Sachin !\nThis looks messy as there is an unwanted space after the name. This is a formatting issue. Python provides some useful tools to format text in the way we want.\n\n\nThe first method that we will look at is called formatted string literals or f-strings for short. Let us jump into the syntax:\nname = input()\nprint(f'Hi, {name}!')\nWhen this code is executed with Sachin as the input, we get the following output:\nHi, Sachin!\nThe messy formatting has been corrected. Let us take a closer look at the string that was passed to #!py print():\nf'Hi, {name}'\nThis is called a formatted string literal or f-string. The f in front of the string differentiates f-strings from normal strings. f-string is an object which when evaluated results in a string. The value of the variable name is inserted in place of {name} in the f-string. Two things are important for f-strings to do our bidding:\n\nThe f in front of the string.\nThe curly braces enclosing the variable.\n\nLet us see what happens if we miss one of these two:\nname = 'Sachin'\nprint('Hi, {name}!')\nprint(f'Hi, name!')\nThis will give the output:\nHi, {name}!\nHi, name!\nLet us now look at few other examples:\nl, b = int(input()), int(input())\nprint(f'The length of the rectangle is {l} units')\nprint(f'The breadth of the rectangle is {b} units')\nprint(f'The area of the rectangle is {l * b} square units')\nFor l = 4, b = 5, the output is:\nThe length of the rectangle is 4 units\nThe breadth of the rectangle is 5 units\nThe area of the rectangle is 20 square units\nGoing back to the code, lines 2 and 3 are quite clear. Notice that line-4 has an expression — l * b — inside the curly braces and not just a variable. f-strings allow any valid Python expression inside the curly braces. If the f-string has some {expression} in it, the interpreter will substitute the value of expression in the place of {expression}. Another example:\nx = int(input())\nprint(f'Multiplication table for {x}')\nfor i in range(1, 11):\n    print(f'{x} X {i} \\t=\\t {x * i}')\nFor an input of 3, this will give the following result:\nMultiplication table for 3\n3 X 1   =    3\n3 X 2   =    6\n3 X 3   =    9\n3 X 4   =    12\n3 X 5   =    15\n3 X 6   =    18\n3 X 7   =    21\n3 X 8   =    24\n3 X 9   =    27\n3 X 10  =    30\nThe \\t is a tab character. It has been added before and after the =. Remove both the tabs and run the code. Do you see any change in the output?\nTill now we have passed f-strings to the #!py print() function. Nothing stops us from using it to define other string variables:\nname = input()\nqual = input()\ngender = input()\nif qual == 'phd':\n    name_respect = f'Dr. {name}'\nelif gender == 'male':\n    name_respect = f'Mr. {name}'\nelif gender == 'female':\n    name_respect = f'Ms. {name}'\nprint(f'Hello, {name_respect}')\nTry to guess what this code is doing.\n\n\n\nAnother way to format strings is using a string method called #!py format().\nname = input()\nprint('Hi, {}!'.format(name))\nIn the above string, the curly braces will be replaced by the value of the variable name. Another example:\nl, b = int(input()), int(input())\nprint('The length of the rectangle is {} units'.format(l))\nprint('The breadth of the rectangle is {} units'.format(b))\nprint('The area of the rectangle is {} square units'.format(l * b))\nLet us now print the multiplication table using #!py format():\nx = int(input())\nfor i in range(1, 11):\n    print('{} X {} \\t=\\t {}'.format(x, i, x * i))\nThe output will be identical to the one we saw when we used f-strings. Some points to note in line 3 of this code-block. There are three pairs of curly braces. The values that go into these three positions are given as three arguments in the #!py format() function. Starting from the left, the first pair of curly braces in the string is replaced by the first argument in #!py format, the second pair by the second argument and so on. Few more examples:\nFirst, consider the following code:\nfruit1 = 'apple'\nfruit2 = 'banana'\nprint('{} and {} are fruits'.format(fruit1, fruit2))\nIn this code, the mapping is implicit. The first pair of curly braces is mapped to the first argument and so on. This can be made explicit by specifying which argument a particular curly braces will be mapped to:\nfruit1 = 'apple'\nfruit2 = 'banana'\nprint('{0} and {1} are fruits'.format(fruit1, fruit2))\nThe integer inside the curly braces gives the index of the argument in the #!py format() function. The arguments of the #!py format() function are indexed from 0 and start from the left. Changing the order of arguments will change the output. A third way of writing this as follows:\nfruit1 = 'apple'\nfruit2 = 'banana'\nprint('{string1} and {string2} are fruits'.format(string1 = fruit1, string2 = fruit2))\nThis method uses the concept of keyword arguments which we will explore in the lessons on functions in the next chapter. Until then, let us put this last method on the back-burner.\n\n\n\nConsider the following code:\npi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx}')\nThis gives the following output:\nThe value of pi is approximately 3.142857142857143\nThere are too many numbers after the decimal point. In many real world applications, having two or at most three places after the decimal point is sufficient. In fact, having as many as fifteen numbers after the decimal point only confuses readers. Format specifiers are a way to solve this problem:\npi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx:.2f}')\nThis gives the following output:\nThe value of pi is approximately 3.14\nLet us look at the content inside the curly braces: {pi_approx:.2f}. The first part before the : is the variable. Nothing new here. The part after : is called a format specifier. .2f means the following:\n\n. - this signifies the decimal point.\n2 - since this comes after the decimal point, it stipulates that there should be exactly two numbers after the decimal point. In other words, the value (pi_approx) should be rounded off to two decimal places.\nf - this signifies that we are dealing with a float value.\n\nLet us consider a variant of this code:\npi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx:.3f}')\nThis gives the following output:\nThe value of pi is approximately 3.143\nLet us now take another example. Let us say we want to print the marks of three students in a class:\nroll_1, marks_1 = 'BSC1001', 90.5\nroll_2, marks_2 = 'BSC1002', 100\nroll_3, marks_3 = 'BSC1003', 90.15\nprint(f'{roll_1}: {marks_1}')\nprint(f'{roll_2}: {marks_2}')\nprint(f'{roll_3}: {marks_3}')\nThis gives the following output:\nBSC1001: 90.5\nBSC1002: 100\nBSC1003: 90.15\nWhile this is not bad, we would like the marks to be right aligned and have a uniform representation for the marks. The following code helps us achieve this:This is what we wish to see:\nroll_1, marks_1 = 'BSC1001', 90.5\nroll_2, marks_2 = 'BSC1002', 100\nroll_3, marks_3 = 'BSC1003', 90.15\nprint(f'{roll_1}: {marks_1:10.2f}')\nprint(f'{roll_2}: {marks_2:10.2f}')\nprint(f'{roll_3}: {marks_3:10.2f}')\nThe output of the above code will be:\nBSC1001:      90.50\nBSC1002:     100.00\nBSC1003:      90.15\nThis is much more neater.\nThe part that might be confusing is the second curly braces in each of the print statements. Let us take a closer look: {marks_1:10.2f}. The part before the : is the variable. The part after the : is 10.2f. Here again, .2f signifies that the float value should be rounded off to two decimal places. The 10 before the decimal point is the minimum width of the column used for printing this value. If the number has fewer than 10 characters (including the decimal point), this will be compensated by adding spaces before the number.\nFor a better understanding of this concept, let us turn to printing integers with a specific formatting. This time, we will use the #!py format() function:\nprint('{0:5d}'.format(1))\nprint('{0:5d}'.format(11))\nprint('{0:5d}'.format(111))\nprint('{:5d}'.format(1111))\nprint('{:5d}'.format(11111))\nprint('{:5d}'.format(111111))\nThis gives the following output:\n    1\n   11\n  111\n 1111\n11111\n111111\nPoints to note in the code:\n\nThe d stands for integer.\nFirst three print statements have the index of the argument — 0 in this case — before the :. Last three statements do not have the index of the argument. In fact there is nothing before the :. Both representations are valid.\nThe 5d after the : means that the width of the column used for printing must be at least 5.\nLines 1 to 4 have spaces before them as the integer being printed has fewer than five characters."
  },
  {
    "objectID": "notes/chapter-3/lesson-3.4.html#formatted-printing",
    "href": "notes/chapter-3/lesson-3.4.html#formatted-printing",
    "title": "Lesson-3.4",
    "section": "",
    "text": "Consider the following program:\nname = input()\nprint('Hi,', name, '!')\nWhen this code is executed with Sachin as the input, we get the following output:\nHi, Sachin !\nThis looks messy as there is an unwanted space after the name. This is a formatting issue. Python provides some useful tools to format text in the way we want.\n\n\nThe first method that we will look at is called formatted string literals or f-strings for short. Let us jump into the syntax:\nname = input()\nprint(f'Hi, {name}!')\nWhen this code is executed with Sachin as the input, we get the following output:\nHi, Sachin!\nThe messy formatting has been corrected. Let us take a closer look at the string that was passed to #!py print():\nf'Hi, {name}'\nThis is called a formatted string literal or f-string. The f in front of the string differentiates f-strings from normal strings. f-string is an object which when evaluated results in a string. The value of the variable name is inserted in place of {name} in the f-string. Two things are important for f-strings to do our bidding:\n\nThe f in front of the string.\nThe curly braces enclosing the variable.\n\nLet us see what happens if we miss one of these two:\nname = 'Sachin'\nprint('Hi, {name}!')\nprint(f'Hi, name!')\nThis will give the output:\nHi, {name}!\nHi, name!\nLet us now look at few other examples:\nl, b = int(input()), int(input())\nprint(f'The length of the rectangle is {l} units')\nprint(f'The breadth of the rectangle is {b} units')\nprint(f'The area of the rectangle is {l * b} square units')\nFor l = 4, b = 5, the output is:\nThe length of the rectangle is 4 units\nThe breadth of the rectangle is 5 units\nThe area of the rectangle is 20 square units\nGoing back to the code, lines 2 and 3 are quite clear. Notice that line-4 has an expression — l * b — inside the curly braces and not just a variable. f-strings allow any valid Python expression inside the curly braces. If the f-string has some {expression} in it, the interpreter will substitute the value of expression in the place of {expression}. Another example:\nx = int(input())\nprint(f'Multiplication table for {x}')\nfor i in range(1, 11):\n    print(f'{x} X {i} \\t=\\t {x * i}')\nFor an input of 3, this will give the following result:\nMultiplication table for 3\n3 X 1   =    3\n3 X 2   =    6\n3 X 3   =    9\n3 X 4   =    12\n3 X 5   =    15\n3 X 6   =    18\n3 X 7   =    21\n3 X 8   =    24\n3 X 9   =    27\n3 X 10  =    30\nThe \\t is a tab character. It has been added before and after the =. Remove both the tabs and run the code. Do you see any change in the output?\nTill now we have passed f-strings to the #!py print() function. Nothing stops us from using it to define other string variables:\nname = input()\nqual = input()\ngender = input()\nif qual == 'phd':\n    name_respect = f'Dr. {name}'\nelif gender == 'male':\n    name_respect = f'Mr. {name}'\nelif gender == 'female':\n    name_respect = f'Ms. {name}'\nprint(f'Hello, {name_respect}')\nTry to guess what this code is doing.\n\n\n\nAnother way to format strings is using a string method called #!py format().\nname = input()\nprint('Hi, {}!'.format(name))\nIn the above string, the curly braces will be replaced by the value of the variable name. Another example:\nl, b = int(input()), int(input())\nprint('The length of the rectangle is {} units'.format(l))\nprint('The breadth of the rectangle is {} units'.format(b))\nprint('The area of the rectangle is {} square units'.format(l * b))\nLet us now print the multiplication table using #!py format():\nx = int(input())\nfor i in range(1, 11):\n    print('{} X {} \\t=\\t {}'.format(x, i, x * i))\nThe output will be identical to the one we saw when we used f-strings. Some points to note in line 3 of this code-block. There are three pairs of curly braces. The values that go into these three positions are given as three arguments in the #!py format() function. Starting from the left, the first pair of curly braces in the string is replaced by the first argument in #!py format, the second pair by the second argument and so on. Few more examples:\nFirst, consider the following code:\nfruit1 = 'apple'\nfruit2 = 'banana'\nprint('{} and {} are fruits'.format(fruit1, fruit2))\nIn this code, the mapping is implicit. The first pair of curly braces is mapped to the first argument and so on. This can be made explicit by specifying which argument a particular curly braces will be mapped to:\nfruit1 = 'apple'\nfruit2 = 'banana'\nprint('{0} and {1} are fruits'.format(fruit1, fruit2))\nThe integer inside the curly braces gives the index of the argument in the #!py format() function. The arguments of the #!py format() function are indexed from 0 and start from the left. Changing the order of arguments will change the output. A third way of writing this as follows:\nfruit1 = 'apple'\nfruit2 = 'banana'\nprint('{string1} and {string2} are fruits'.format(string1 = fruit1, string2 = fruit2))\nThis method uses the concept of keyword arguments which we will explore in the lessons on functions in the next chapter. Until then, let us put this last method on the back-burner.\n\n\n\nConsider the following code:\npi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx}')\nThis gives the following output:\nThe value of pi is approximately 3.142857142857143\nThere are too many numbers after the decimal point. In many real world applications, having two or at most three places after the decimal point is sufficient. In fact, having as many as fifteen numbers after the decimal point only confuses readers. Format specifiers are a way to solve this problem:\npi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx:.2f}')\nThis gives the following output:\nThe value of pi is approximately 3.14\nLet us look at the content inside the curly braces: {pi_approx:.2f}. The first part before the : is the variable. Nothing new here. The part after : is called a format specifier. .2f means the following:\n\n. - this signifies the decimal point.\n2 - since this comes after the decimal point, it stipulates that there should be exactly two numbers after the decimal point. In other words, the value (pi_approx) should be rounded off to two decimal places.\nf - this signifies that we are dealing with a float value.\n\nLet us consider a variant of this code:\npi_approx = 22 / 7\nprint(f'The value of pi is approximately {pi_approx:.3f}')\nThis gives the following output:\nThe value of pi is approximately 3.143\nLet us now take another example. Let us say we want to print the marks of three students in a class:\nroll_1, marks_1 = 'BSC1001', 90.5\nroll_2, marks_2 = 'BSC1002', 100\nroll_3, marks_3 = 'BSC1003', 90.15\nprint(f'{roll_1}: {marks_1}')\nprint(f'{roll_2}: {marks_2}')\nprint(f'{roll_3}: {marks_3}')\nThis gives the following output:\nBSC1001: 90.5\nBSC1002: 100\nBSC1003: 90.15\nWhile this is not bad, we would like the marks to be right aligned and have a uniform representation for the marks. The following code helps us achieve this:This is what we wish to see:\nroll_1, marks_1 = 'BSC1001', 90.5\nroll_2, marks_2 = 'BSC1002', 100\nroll_3, marks_3 = 'BSC1003', 90.15\nprint(f'{roll_1}: {marks_1:10.2f}')\nprint(f'{roll_2}: {marks_2:10.2f}')\nprint(f'{roll_3}: {marks_3:10.2f}')\nThe output of the above code will be:\nBSC1001:      90.50\nBSC1002:     100.00\nBSC1003:      90.15\nThis is much more neater.\nThe part that might be confusing is the second curly braces in each of the print statements. Let us take a closer look: {marks_1:10.2f}. The part before the : is the variable. The part after the : is 10.2f. Here again, .2f signifies that the float value should be rounded off to two decimal places. The 10 before the decimal point is the minimum width of the column used for printing this value. If the number has fewer than 10 characters (including the decimal point), this will be compensated by adding spaces before the number.\nFor a better understanding of this concept, let us turn to printing integers with a specific formatting. This time, we will use the #!py format() function:\nprint('{0:5d}'.format(1))\nprint('{0:5d}'.format(11))\nprint('{0:5d}'.format(111))\nprint('{:5d}'.format(1111))\nprint('{:5d}'.format(11111))\nprint('{:5d}'.format(111111))\nThis gives the following output:\n    1\n   11\n  111\n 1111\n11111\n111111\nPoints to note in the code:\n\nThe d stands for integer.\nFirst three print statements have the index of the argument — 0 in this case — before the :. Last three statements do not have the index of the argument. In fact there is nothing before the :. Both representations are valid.\nThe 5d after the : means that the width of the column used for printing must be at least 5.\nLines 1 to 4 have spaces before them as the integer being printed has fewer than five characters."
  },
  {
    "objectID": "notes/chapter-6/lesson-6.5.html",
    "href": "notes/chapter-6/lesson-6.5.html",
    "title": "Lesson-6.5",
    "section": "",
    "text": "A set is an unordered collection with no duplicate elements [refer]. Unlike lists and tuples, there is no notion of order in a set. This is why it is called an unordered collection as opposed to a sequence. A set can be defined as follows:\neven_nums = {2, 4, 6, 8, 10}\nprint(type(even_nums))\nprint(isinstance(even_nums, set))\nOutput\n&lt;class 'set'&gt;\nTrue\nNotice the similarity in syntax between sets and dictionaries. Both are enclosed within curly braces. While a dictionary has key-value pairs in it, a set just has a collection of values. A set in Python is a remarkably accurate representation of a mathematical set. Therefore, most of the properties that you are used to seeing in mathematical sets nicely carry over to Python sets. This connection is so strong that you can often forget that you are dealing with Python sets.\nnums_1 = {2, 4, 6, 8, 10}\nnums_2 = {2, 2, 4, 4, 6, 6, 8, 8, 10, 10}\nprint(nums_1, nums_2)\nprint(nums_1 == nums_2)\nprint(nums_1 is not nums_2)\nOutput\n{2, 4, 6, 8, 10} {2, 4, 6, 8, 10}\nTrue\nTrue\nAs stated before, sets do not support duplicate elements. We see that nums_1 and nums_2 are equal sets. However, they don’t point to the same object. Sets support membership just like lists, tuples and dictionaries.\nnums = {1, 2, 3, 4, 5}\nprint(1 in nums)\nprint(6 not in nums)\nThe number of elements in a set, which is the same as its cardinality, is given by the len() function:\nnums = {1, 2, 3, 4, 5}\nprint(f'Cardinality of nums is {len(nums)}')\nSets cannot be indexed. This is quite reasonable as they are not ordered collections. The following code will throw an error:\n##### Alarm! Wrong code snippet! #####\nsome_set = {'this', 'is', 'a', 'set'}\nprint(some_set[0])\n##### Alarm! Wrong code snippet! #####\nAny hashable object can be added to sets. This means most of the immutable types such as int, float, str and tuple can be added to sets. A small caveat as far as tuples are concerned: a tuple of lists is unhashable and therefore cannot be added to sets.\na_set = {1.0, 'one', 1, True, (1, )}    # valid set\nnot_a_set = {([1, 2], [3, 4])}          # not a valid set\nnot_a_set returns a TypeError as expected.\n\n\n\nThough a set is not a sequence, iterating through the elements of a set is supported.\nnums = {1, 2, 3, 4, 5}\nfor num in nums:\n    print(num)\n\n\n\nHow do we define an empty set?\n##### Alarm! Be careful about the variable name! #####\nempty_set = { }\nprint(isinstance(empty_set, set))\nprint(isinstance(empty_set, dict))\n##### Alarm! Be careful about the variable name! #####\nWe see that empty_set is in fact an empty dictionary. Computers are precise machines, which makes them very faithful. Few lessons back we used { } to initialize an empty dictionary. It hasn’t changed. { } is still an empty dictionary. So, how do we define an empty set then?\nempty_set = set()\nprint(isinstance(empty_set, set))\nSimple enough! With the empty set and set-iteration defined, we can now grow sets from scratch.\n\nConsider the first 100 powers of 7: \\[\n7^1, 7^2, \\cdots, 7^{100}\n\\] Note down the last digit of each of these powers. How many of them are unique? What are these numbers?\n\nThis problem has a simple mathematical solution. But humor me and assume that you don’t know how to solve this problem. Let us go for a computational solution.\nnum = 1\ndigits = set()\nfor i in range(100):\n    num *= 7\n    last = num % 10\n    digits.add(last)\nprint(digits)\nadd is a method used to add elements to a set. The solution to this problem is a typical use case of sets. When you expect duplicate elements to come up often and if you are not concerned with duplicates, then sets are ideal objects for storage. The same problem can be solved using lists:\nnum = 1\ndigits = [ ]\nfor i in range(100):\n    num *= 7\n    last = num % 10\n    if last not in digits:\n        digits.append(last)\nprint(digits)\n\n\n\nMathematical sets are friendly objects. They routinely interact with each other through one of the following operations:\n\nSubset\nSuperset\nUnion\nIntersection\nDifference\n\nPython sets strive to be as friendly as their mathematical counterparts. We will see how each of these operations are represented:\n\nSubset: \\(A\\) is a subset of \\(B\\) if every element of \\(A\\) is present in \\(B\\). It is denoted by \\(A \\subseteq B\\). This is a binary relationship and its outcome can be determined in one of the two ways:\n\nA = {1, 3, 5}\nB = {1, 2, 3, 4, 5}\nprint(A.issubset(B))    # method-1\nprint(A &lt;= B)           # method-2\nBoth lines return the value True. A set \\(A\\) is a proper subset of \\(B\\) if every element in \\(A\\) is present in \\(B\\) and \\(A \\neq B\\). It is denoted by \\(A \\subset B\\). That is, there is at least one element in \\(B\\) which is not in \\(A\\):\nA = {1, 2, 3}\nB = {1, 2, 3}\nprint(A &lt;= B)   # method-1\nprint(A &lt; B)    # method-2\nThe A &lt; B operator checks if A is a proper subset of B. In this case A is not a proper subset of B, so the second print statement returns False.\n\nSuperset: \\(A\\) is a superset of \\(B\\) if every element of \\(B\\) is present in \\(A\\). It is denoted by \\(A \\supset B\\):\n\nA = {1, 3, 5}\nB = {1, 2, 3, 4, 5}\nB.issuperset(A)     # method-1\nprint(B &gt;= A)       # method-2\n\nUnion: The union of two sets \\(A\\) and \\(B\\) is the set of elements that are present in either \\(A\\) or \\(B\\) or both. It is denoted by \\(A \\cup B\\).\n\nA = {1, 3, 5}\nB = {2, 4, 6}\nC1 = A.union(B)     # method-1\nC2 = A | B          # method-2\nprint(C1, C2)\nprint(C1 == C2)\nWhen there are multiple sets, we could do the following:\nA1, A2, A3, A4 = {1}, {2, 3}, {4, 5, 6}, {7, 8, 9, 10}\nB1 = A1.union(A2, A3, A4)   # method-1\nB2 = A1 | A2 | A3 | A4      # method-2\nprint(B1, B2)\nprint(B1 == B2)\n\nIntersection: The intersection of two sets \\(A\\) and \\(B\\) is the set of elements common to both. It is denoted by \\(A \\cap B\\).\n\nA = {2, 4, 6}\nB = {2, 4}\nC1 = A.intersection(B)  # method-1\nC2 = A & B              # method-2\nprint(C1, C2)\nprint(C1 == C2)\nWhat happens if there are no elements in common? We should get the empty set:\neven, odd = {2, 4, 6}, {1, 3, 5}\ncommon = even & odd\nassert common == set()\nWe have used an assert statement just to introduce some variation. As it doesn’t raise an AssertionError, we are right on target.\n\nDifference: The difference between two sets \\(A\\) and \\(B\\) is the set of elements present in one set but not in the other. It is denoted by \\(A - B\\) or \\(B - A\\), and the two are not the same!\n\n\\(A - B\\) is the set of elements in \\(A\\) which are not in \\(B\\).\n\\(B - A\\) is the set of elements in \\(B\\) which are not in \\(A\\).\n\n\nA = {1, 2, 3, 4}\nB = {2, 4, 5}\nC1 = A.difference(B)    # method-1\nC2 = A - B              # method-2\nprint(C1, C2)\nprint(C1 == C2)\nD1 = B.difference(A)    # method-1\nD2 = B - A              # method-2\nprint(D1, D2)\nprint(D1 == D2)\n\n\n\nThe methods that we saw in the previous section had a mathematical flavor. Now, we shall look at those methods that have a computational flavor!\nTo remove an element from the set, we can use the remove method:\nA = {'this', 'is', 'a', 'set'}\nprint('Before', A)\nA.remove('this')\nprint('After', A)\nIf we try to remove an element that is not present in the set, the interpreter will throw a KeyError:\nA = {'this', 'is', 'a', 'set'}\nA.remove('cool')    # error!\nConsider the following problem:\n\nGiven a list L, extract all unique elements from it and store the result in another list, L_uniq. The order of elements does not matter.\n\nLet us first look at a solution that doesn’t use sets:\nL = [1, 2, 3, 3, 4, 5, 6, 1, 2, 2]\nL_uniq = [ ]\nfor elem in L:\n    if elem not in L_uniq:\n        L_uniq.append(elem)\nprint(L_uniq)\nNow, for some set magic:\nL = [1, 2, 3, 3, 4, 5, 6, 1, 2, 2]\nS = set(L)\nL_uniq = list(S)\nprint(L_uniq)\nPassing a list to the set function removes all duplicates and returns the unique elements.\n\n\n\nSets are mutable entities.\nA = {1, 2, 3}\nB = A\nB.add(4)\nprint(A, B)\nprint(A is B)\nA and B are the same objects. As before, there are two ways to do a shallow copy:\nA = {1, 2, 3}\nB1 = A.copy()\nB2 = set(A)\nB1.add(4)\nB2.add(0)\nprint(A, B1, B2)\nprint(A is not B1)\nprint(A is not B2)"
  },
  {
    "objectID": "notes/chapter-6/lesson-6.5.html#sets",
    "href": "notes/chapter-6/lesson-6.5.html#sets",
    "title": "Lesson-6.5",
    "section": "",
    "text": "A set is an unordered collection with no duplicate elements [refer]. Unlike lists and tuples, there is no notion of order in a set. This is why it is called an unordered collection as opposed to a sequence. A set can be defined as follows:\neven_nums = {2, 4, 6, 8, 10}\nprint(type(even_nums))\nprint(isinstance(even_nums, set))\nOutput\n&lt;class 'set'&gt;\nTrue\nNotice the similarity in syntax between sets and dictionaries. Both are enclosed within curly braces. While a dictionary has key-value pairs in it, a set just has a collection of values. A set in Python is a remarkably accurate representation of a mathematical set. Therefore, most of the properties that you are used to seeing in mathematical sets nicely carry over to Python sets. This connection is so strong that you can often forget that you are dealing with Python sets.\nnums_1 = {2, 4, 6, 8, 10}\nnums_2 = {2, 2, 4, 4, 6, 6, 8, 8, 10, 10}\nprint(nums_1, nums_2)\nprint(nums_1 == nums_2)\nprint(nums_1 is not nums_2)\nOutput\n{2, 4, 6, 8, 10} {2, 4, 6, 8, 10}\nTrue\nTrue\nAs stated before, sets do not support duplicate elements. We see that nums_1 and nums_2 are equal sets. However, they don’t point to the same object. Sets support membership just like lists, tuples and dictionaries.\nnums = {1, 2, 3, 4, 5}\nprint(1 in nums)\nprint(6 not in nums)\nThe number of elements in a set, which is the same as its cardinality, is given by the len() function:\nnums = {1, 2, 3, 4, 5}\nprint(f'Cardinality of nums is {len(nums)}')\nSets cannot be indexed. This is quite reasonable as they are not ordered collections. The following code will throw an error:\n##### Alarm! Wrong code snippet! #####\nsome_set = {'this', 'is', 'a', 'set'}\nprint(some_set[0])\n##### Alarm! Wrong code snippet! #####\nAny hashable object can be added to sets. This means most of the immutable types such as int, float, str and tuple can be added to sets. A small caveat as far as tuples are concerned: a tuple of lists is unhashable and therefore cannot be added to sets.\na_set = {1.0, 'one', 1, True, (1, )}    # valid set\nnot_a_set = {([1, 2], [3, 4])}          # not a valid set\nnot_a_set returns a TypeError as expected.\n\n\n\nThough a set is not a sequence, iterating through the elements of a set is supported.\nnums = {1, 2, 3, 4, 5}\nfor num in nums:\n    print(num)\n\n\n\nHow do we define an empty set?\n##### Alarm! Be careful about the variable name! #####\nempty_set = { }\nprint(isinstance(empty_set, set))\nprint(isinstance(empty_set, dict))\n##### Alarm! Be careful about the variable name! #####\nWe see that empty_set is in fact an empty dictionary. Computers are precise machines, which makes them very faithful. Few lessons back we used { } to initialize an empty dictionary. It hasn’t changed. { } is still an empty dictionary. So, how do we define an empty set then?\nempty_set = set()\nprint(isinstance(empty_set, set))\nSimple enough! With the empty set and set-iteration defined, we can now grow sets from scratch.\n\nConsider the first 100 powers of 7: \\[\n7^1, 7^2, \\cdots, 7^{100}\n\\] Note down the last digit of each of these powers. How many of them are unique? What are these numbers?\n\nThis problem has a simple mathematical solution. But humor me and assume that you don’t know how to solve this problem. Let us go for a computational solution.\nnum = 1\ndigits = set()\nfor i in range(100):\n    num *= 7\n    last = num % 10\n    digits.add(last)\nprint(digits)\nadd is a method used to add elements to a set. The solution to this problem is a typical use case of sets. When you expect duplicate elements to come up often and if you are not concerned with duplicates, then sets are ideal objects for storage. The same problem can be solved using lists:\nnum = 1\ndigits = [ ]\nfor i in range(100):\n    num *= 7\n    last = num % 10\n    if last not in digits:\n        digits.append(last)\nprint(digits)\n\n\n\nMathematical sets are friendly objects. They routinely interact with each other through one of the following operations:\n\nSubset\nSuperset\nUnion\nIntersection\nDifference\n\nPython sets strive to be as friendly as their mathematical counterparts. We will see how each of these operations are represented:\n\nSubset: \\(A\\) is a subset of \\(B\\) if every element of \\(A\\) is present in \\(B\\). It is denoted by \\(A \\subseteq B\\). This is a binary relationship and its outcome can be determined in one of the two ways:\n\nA = {1, 3, 5}\nB = {1, 2, 3, 4, 5}\nprint(A.issubset(B))    # method-1\nprint(A &lt;= B)           # method-2\nBoth lines return the value True. A set \\(A\\) is a proper subset of \\(B\\) if every element in \\(A\\) is present in \\(B\\) and \\(A \\neq B\\). It is denoted by \\(A \\subset B\\). That is, there is at least one element in \\(B\\) which is not in \\(A\\):\nA = {1, 2, 3}\nB = {1, 2, 3}\nprint(A &lt;= B)   # method-1\nprint(A &lt; B)    # method-2\nThe A &lt; B operator checks if A is a proper subset of B. In this case A is not a proper subset of B, so the second print statement returns False.\n\nSuperset: \\(A\\) is a superset of \\(B\\) if every element of \\(B\\) is present in \\(A\\). It is denoted by \\(A \\supset B\\):\n\nA = {1, 3, 5}\nB = {1, 2, 3, 4, 5}\nB.issuperset(A)     # method-1\nprint(B &gt;= A)       # method-2\n\nUnion: The union of two sets \\(A\\) and \\(B\\) is the set of elements that are present in either \\(A\\) or \\(B\\) or both. It is denoted by \\(A \\cup B\\).\n\nA = {1, 3, 5}\nB = {2, 4, 6}\nC1 = A.union(B)     # method-1\nC2 = A | B          # method-2\nprint(C1, C2)\nprint(C1 == C2)\nWhen there are multiple sets, we could do the following:\nA1, A2, A3, A4 = {1}, {2, 3}, {4, 5, 6}, {7, 8, 9, 10}\nB1 = A1.union(A2, A3, A4)   # method-1\nB2 = A1 | A2 | A3 | A4      # method-2\nprint(B1, B2)\nprint(B1 == B2)\n\nIntersection: The intersection of two sets \\(A\\) and \\(B\\) is the set of elements common to both. It is denoted by \\(A \\cap B\\).\n\nA = {2, 4, 6}\nB = {2, 4}\nC1 = A.intersection(B)  # method-1\nC2 = A & B              # method-2\nprint(C1, C2)\nprint(C1 == C2)\nWhat happens if there are no elements in common? We should get the empty set:\neven, odd = {2, 4, 6}, {1, 3, 5}\ncommon = even & odd\nassert common == set()\nWe have used an assert statement just to introduce some variation. As it doesn’t raise an AssertionError, we are right on target.\n\nDifference: The difference between two sets \\(A\\) and \\(B\\) is the set of elements present in one set but not in the other. It is denoted by \\(A - B\\) or \\(B - A\\), and the two are not the same!\n\n\\(A - B\\) is the set of elements in \\(A\\) which are not in \\(B\\).\n\\(B - A\\) is the set of elements in \\(B\\) which are not in \\(A\\).\n\n\nA = {1, 2, 3, 4}\nB = {2, 4, 5}\nC1 = A.difference(B)    # method-1\nC2 = A - B              # method-2\nprint(C1, C2)\nprint(C1 == C2)\nD1 = B.difference(A)    # method-1\nD2 = B - A              # method-2\nprint(D1, D2)\nprint(D1 == D2)\n\n\n\nThe methods that we saw in the previous section had a mathematical flavor. Now, we shall look at those methods that have a computational flavor!\nTo remove an element from the set, we can use the remove method:\nA = {'this', 'is', 'a', 'set'}\nprint('Before', A)\nA.remove('this')\nprint('After', A)\nIf we try to remove an element that is not present in the set, the interpreter will throw a KeyError:\nA = {'this', 'is', 'a', 'set'}\nA.remove('cool')    # error!\nConsider the following problem:\n\nGiven a list L, extract all unique elements from it and store the result in another list, L_uniq. The order of elements does not matter.\n\nLet us first look at a solution that doesn’t use sets:\nL = [1, 2, 3, 3, 4, 5, 6, 1, 2, 2]\nL_uniq = [ ]\nfor elem in L:\n    if elem not in L_uniq:\n        L_uniq.append(elem)\nprint(L_uniq)\nNow, for some set magic:\nL = [1, 2, 3, 3, 4, 5, 6, 1, 2, 2]\nS = set(L)\nL_uniq = list(S)\nprint(L_uniq)\nPassing a list to the set function removes all duplicates and returns the unique elements.\n\n\n\nSets are mutable entities.\nA = {1, 2, 3}\nB = A\nB.add(4)\nprint(A, B)\nprint(A is B)\nA and B are the same objects. As before, there are two ways to do a shallow copy:\nA = {1, 2, 3}\nB1 = A.copy()\nB2 = set(A)\nB1.add(4)\nB2.add(0)\nprint(A, B1, B2)\nprint(A is not B1)\nprint(A is not B2)"
  },
  {
    "objectID": "notes/chapter-6/lesson-6.4.html",
    "href": "notes/chapter-6/lesson-6.4.html",
    "title": "Lesson-6.4",
    "section": "",
    "text": "The online degree portal — our virtual classroom — is called a learning Management system (LMS). In more accessible terms, an LMS is the software application that powers the portal. Have you ever wondered how your assignment submissions get recorded and graded? This is the question that we will try to answer in this lesson. At a high level, the LMS is made of two components: frontend and backend.\n\n\n\n\nHigh level flow chart of LMS\n\n\n\nAs a user, your communicate with the frontend. The frontend is the website where you see all the content displayed. When you make an action, say clicking the submit button in a graded assignment, that action is fed to the backend as input. The backend processes this input and returns some output to the frontend, which is then displayed as the outcome of your action. Where does Python come into the picture? It features prominently in the backend.\nSo how do we expect grading to work? It needs two inputs. The assignment and the submission corresponding to this assignment. It will return the result as output:\n\n\n\n\nHigh level\n\n\n\nThe grader can be expressed as a function:\ndef grader(assignment, submission):\n    \"\"\"Grading logic\"\"\"\n    result = 0.0\n    return result\nThe function is incomplete. We need to decide how an assignment and its corresponding submission are going to be modeled.\n\n\nLet us consider an assignment. It is essentially a list of problems. So, modeling an assignment breaks down to modeling a problem. A problem could have the following attributes:\n\nAttribute | Type |\n|: ——- :|: —- :| | id | string | | question | string | | type | string | | options | list | | answers | tuple | | marks | float |\n\nFor grading, we only need two attributes, the problem-id and the answers. With this, the assignment model will look like the following. The entire assignment will now be a list of dictionaries:\n# assume that the assignment has three problems\n# the assignment will be a list of dictionaries\nassignment = [\n                {'id': '10001', 'answers': (0, 1), 'marks': 2.0},\n                {'id': '10002', 'answers': (1, ), 'marks': 1.0 },\n                {'id': '10003', 'answers': (2, ), 'marks': 2.0}\n             ]\nA point to note. A singleton tuple is represented as (&lt;item&gt;, ). The comma cannot be ignored. Coming back to the assignment model, we see that there are several attributes in the table that haven’t entered into the assignment dictionary since they are not relevant from the point of view of grading. They have been mentioned so that it gives a better understanding of how assignments can be modeled.\n\n\n\nThe submission model is slightly more involved. There are some global attributes like name of the user, the user’s roll number and the time of submission. And then there are local attributes like the options selected for each problem.\n\nAttribute | Type |\n|: ——— :|: —- :| | name | string | | roll_number | string | | timestamp | string | | problems | list |\n\nLet us look at a sample submission:\nsubmission = {\n                'name': 'Kapil Dev',\n                'roll_number': 'BSC1001',\n                'time': 'Sunday 18 April 2021 10:23:30 PM IST',\n                'problems': [\n                                {'id': '10001', 'selected': (0, 1)},\n                                {'id': '10002', 'selected': (1, )},\n                                {'id': '10003', 'selected': (3, )}                    \n                            ]\n              }\nsubmission is a fairly complicated object. To begin with, it is a dictionary. The first three keys do not pose any challenges. The value of the key #!py 'problems' is a list of dictionaries! We could add one more level of complexity. Since a user could make multiple submissions, we could have a list of submissions! But for now, let us not complicate things any further.\n\n\n\nThe assignment is a list of dictionaries. While this is not a bad representation, the grader has to search for the problem id through this list every time it has to grade a problem. Since the problem id is unique, we can come up with a better representation for the assignment:\nassignment_ = [\n                {'id': '10001', 'answers': (0, 1), 'marks': 2.0},\n                {'id': '10002', 'answers': (1, ), 'marks': 1.0 },\n                {'id': '10003', 'answers': (2, ), 'marks': 2.0}\n             ]\nassignment = dict()\nfor problem in assignment_:\n    problem_id = problem['id']\n    answers = problem['answers']\n    marks = problem['marks']\n    assignment[problem_id] = {'answers': answers, 'marks': marks}\nThe assignment now looks like this:\nassignment = {\n                '10001': {\n                            'answers': (0, 1),\n                            'marks': 2.0\n                         },\n                '10002': {\n                            'answers': (1, ),\n                            'marks': 1.0\n                         },\n                '10003': {\n                            'answers': (2, ),\n                            'marks': 2.0\n                         },    \n             }\nWe are now ready to complete the grader using this new assignment model:\ndef grader(assignment, submission):\n    \"\"\"Grading logic\"\"\"\n    result = 0.0\n    for problem in submission['problems']:\n        problem_id = problem['id']\n        selected = problem['selected']\n        answers = assignment[problem_id]['answers']\n        if answers == selected:\n            result += assignment[problem_id]['marks']\n    return result"
  },
  {
    "objectID": "notes/chapter-6/lesson-6.4.html#dictionaries-in-action-lms",
    "href": "notes/chapter-6/lesson-6.4.html#dictionaries-in-action-lms",
    "title": "Lesson-6.4",
    "section": "",
    "text": "The online degree portal — our virtual classroom — is called a learning Management system (LMS). In more accessible terms, an LMS is the software application that powers the portal. Have you ever wondered how your assignment submissions get recorded and graded? This is the question that we will try to answer in this lesson. At a high level, the LMS is made of two components: frontend and backend.\n\n\n\n\nHigh level flow chart of LMS\n\n\n\nAs a user, your communicate with the frontend. The frontend is the website where you see all the content displayed. When you make an action, say clicking the submit button in a graded assignment, that action is fed to the backend as input. The backend processes this input and returns some output to the frontend, which is then displayed as the outcome of your action. Where does Python come into the picture? It features prominently in the backend.\nSo how do we expect grading to work? It needs two inputs. The assignment and the submission corresponding to this assignment. It will return the result as output:\n\n\n\n\nHigh level\n\n\n\nThe grader can be expressed as a function:\ndef grader(assignment, submission):\n    \"\"\"Grading logic\"\"\"\n    result = 0.0\n    return result\nThe function is incomplete. We need to decide how an assignment and its corresponding submission are going to be modeled.\n\n\nLet us consider an assignment. It is essentially a list of problems. So, modeling an assignment breaks down to modeling a problem. A problem could have the following attributes:\n\nAttribute | Type |\n|: ——- :|: —- :| | id | string | | question | string | | type | string | | options | list | | answers | tuple | | marks | float |\n\nFor grading, we only need two attributes, the problem-id and the answers. With this, the assignment model will look like the following. The entire assignment will now be a list of dictionaries:\n# assume that the assignment has three problems\n# the assignment will be a list of dictionaries\nassignment = [\n                {'id': '10001', 'answers': (0, 1), 'marks': 2.0},\n                {'id': '10002', 'answers': (1, ), 'marks': 1.0 },\n                {'id': '10003', 'answers': (2, ), 'marks': 2.0}\n             ]\nA point to note. A singleton tuple is represented as (&lt;item&gt;, ). The comma cannot be ignored. Coming back to the assignment model, we see that there are several attributes in the table that haven’t entered into the assignment dictionary since they are not relevant from the point of view of grading. They have been mentioned so that it gives a better understanding of how assignments can be modeled.\n\n\n\nThe submission model is slightly more involved. There are some global attributes like name of the user, the user’s roll number and the time of submission. And then there are local attributes like the options selected for each problem.\n\nAttribute | Type |\n|: ——— :|: —- :| | name | string | | roll_number | string | | timestamp | string | | problems | list |\n\nLet us look at a sample submission:\nsubmission = {\n                'name': 'Kapil Dev',\n                'roll_number': 'BSC1001',\n                'time': 'Sunday 18 April 2021 10:23:30 PM IST',\n                'problems': [\n                                {'id': '10001', 'selected': (0, 1)},\n                                {'id': '10002', 'selected': (1, )},\n                                {'id': '10003', 'selected': (3, )}                    \n                            ]\n              }\nsubmission is a fairly complicated object. To begin with, it is a dictionary. The first three keys do not pose any challenges. The value of the key #!py 'problems' is a list of dictionaries! We could add one more level of complexity. Since a user could make multiple submissions, we could have a list of submissions! But for now, let us not complicate things any further.\n\n\n\nThe assignment is a list of dictionaries. While this is not a bad representation, the grader has to search for the problem id through this list every time it has to grade a problem. Since the problem id is unique, we can come up with a better representation for the assignment:\nassignment_ = [\n                {'id': '10001', 'answers': (0, 1), 'marks': 2.0},\n                {'id': '10002', 'answers': (1, ), 'marks': 1.0 },\n                {'id': '10003', 'answers': (2, ), 'marks': 2.0}\n             ]\nassignment = dict()\nfor problem in assignment_:\n    problem_id = problem['id']\n    answers = problem['answers']\n    marks = problem['marks']\n    assignment[problem_id] = {'answers': answers, 'marks': marks}\nThe assignment now looks like this:\nassignment = {\n                '10001': {\n                            'answers': (0, 1),\n                            'marks': 2.0\n                         },\n                '10002': {\n                            'answers': (1, ),\n                            'marks': 1.0\n                         },\n                '10003': {\n                            'answers': (2, ),\n                            'marks': 2.0\n                         },    \n             }\nWe are now ready to complete the grader using this new assignment model:\ndef grader(assignment, submission):\n    \"\"\"Grading logic\"\"\"\n    result = 0.0\n    for problem in submission['problems']:\n        problem_id = problem['id']\n        selected = problem['selected']\n        answers = assignment[problem_id]['answers']\n        if answers == selected:\n            result += assignment[problem_id]['marks']\n    return result"
  },
  {
    "objectID": "notes/chapter-5/lesson-5.2.html",
    "href": "notes/chapter-5/lesson-5.2.html",
    "title": "Lesson-5.2",
    "section": "",
    "text": "Consider the following problem:\n\nAssume that you work at a company that analyzes cricket matches. As a part of the data collection process in the IPL, the data-processing team is tasked with recording the runs scored in every ball in every match. It is your colleague’s turn to do the bookkeeping for the final match between CSK and MI. Just before the start, the “0” key on his keyboard stops functioning. As a workaround, you cleverly suggest that he use the letter “O” instead of 0. Once the match is over, you collect the list of runs scored. Write a program that replaces all appearances of the letter “O” with the number 0. I leave it to your imagination to decide who won the finals!\n\nSolution\nruns = [1, 4, 2, 'O', 4, 'O'] # the data for one over is given here\nprint(runs)\nfor i in range(len(runs)):\n    if runs[i] == 'O':\n        runs[i] = 0\nprint(runs)\nThe most interesting line is the fifth one: runs[i] = 0. We are updating a list in-place. Python permits this operation because lists are mutable. Contrast this with strings that are immutable, which means that they cannot be updated in-place. Mutability makes lists powerful; but reckless exercise of power always results in instability as is demonstrated by this notorious example:\nlist1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1)\nprint(list2)\nBoth give the same output even though we are only modifying list2 in-place!\n[100, 2, 3]\n[100, 2, 3]\nWhat is happening here? To understand this, we will take the help of a built-in function called id. Every object in Python has a unique identity: if x is an object, then id(x) returns this object’s identity. From the Python documentation, “this is guaranteed to be unique among simultaneously existing objects”. In the implementation of the Python that we use, this unique id is nothing but the object’s memory address.\n\n\n\nReferencing\n\n\nIn line-2, we are not creating a new object. We are merely creating another name, also called an alias, for the same object. Think of this like having a nickname. Your name and nickname are two different words, but both of them refer to you. To see if two Python names point to the same object, we can use the is keyword:\nlist1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1 is list2)\nThis prints True. Now consider another scenario:\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\nprint(list1 == list2)\nprint(list1 is list2)\nThis gives the following output:\nTrue\nFalse\nThis because equality and identity are two different things. In the code, line-3 checks for equality of two lists, line-4 checks if the two lists point to the same object. list1 and list2 point to two different objects and consequently have different identities. But, they store the same sequence of items and are hence equal.\nHow do we create a copy of a list so that updating one doesn’t end up changing both? Python provides three ways to do this:\nlist1 = [1, 2,  3]\nlist2 = list(list1)\nlist3 = list1[:]\nlist4 = list1.copy()\n\nlist2[0] = 100\nlist3[0] = 200\nlist4[0] = 300\n\nprint(list1, list2, list3, list4)\nprint(list1 is not list2, list1 is not list3, list1 is not list4)\nThis results in the following output:\n[1, 2, 3] [100, 2, 3] [200, 2, 3] [300, 2, 3]\nTrue True True\n\nIn line-2, we pass list1 as an argument to the list function which returns a new list object with the same sequence of elements as list1.\nIn line-3, we are slicing the list. Slicing a list results in a new list object. As no start or stop values are mentioned, they are going to default to 0 and len(list1) respectively. So, the entire list is returned. However, it is a brand new object.\nIn line-4, we use a method call copy that is defined for the list object.\n\nLines 10 and 11 verify that the methods used to copy lists in lines 2, 3 and 4 actually work.\n\n\n\nMutability impacts the way lists are handled in functions. Consider these two snippets:\n# Snippet-1\ndef foo():\n    L.append(1)\n    \nL = [0]\nprint(f'L before: {L}')\nfoo()\nprint(f'L after: {L}')\nSnippet-1 doesn’t have any parameters. Since L is not being assigned a new value inside foo, the scope of L remains global.\n# Snippet-2\ndef foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n\nL = [0]\nprint(f'L before: {L}')\nfoo(L)\nprint(f'L after: {L}')\nSnippet-2 has L_foo as a parameter whose scope is local to foo. But note that modifying L_foo within the function changes L outside the function. This is because, L_foo and L point to the same object. How did this aliasing happen? The function call at line-8 works something like an assignment statement: L_foo = L, so L_foo is just another name that refers to the object that L is bound to. This type of function call where a reference to an object is passed is termed call by reference. Whenever a mutable variable is passed as an argument to a function, the references to the corresponding object are passed.\nIf all this seems too complicated, just remember that modifying mutable objects within a function produces side effects outside the function. What if we don’t want these side effects? We have to create a new list object like we did before:\ndef foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n    \nL = [0]\nprint(f'L before: {L}')\nfoo(list(L))\nprint(f'L after: {L}')\nfoo doesn’t produce any side effects. Line-7 could be replaced with foo(L[:]) or foo(L.copy())."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.2.html#lists",
    "href": "notes/chapter-5/lesson-5.2.html#lists",
    "title": "Lesson-5.2",
    "section": "",
    "text": "Consider the following problem:\n\nAssume that you work at a company that analyzes cricket matches. As a part of the data collection process in the IPL, the data-processing team is tasked with recording the runs scored in every ball in every match. It is your colleague’s turn to do the bookkeeping for the final match between CSK and MI. Just before the start, the “0” key on his keyboard stops functioning. As a workaround, you cleverly suggest that he use the letter “O” instead of 0. Once the match is over, you collect the list of runs scored. Write a program that replaces all appearances of the letter “O” with the number 0. I leave it to your imagination to decide who won the finals!\n\nSolution\nruns = [1, 4, 2, 'O', 4, 'O'] # the data for one over is given here\nprint(runs)\nfor i in range(len(runs)):\n    if runs[i] == 'O':\n        runs[i] = 0\nprint(runs)\nThe most interesting line is the fifth one: runs[i] = 0. We are updating a list in-place. Python permits this operation because lists are mutable. Contrast this with strings that are immutable, which means that they cannot be updated in-place. Mutability makes lists powerful; but reckless exercise of power always results in instability as is demonstrated by this notorious example:\nlist1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1)\nprint(list2)\nBoth give the same output even though we are only modifying list2 in-place!\n[100, 2, 3]\n[100, 2, 3]\nWhat is happening here? To understand this, we will take the help of a built-in function called id. Every object in Python has a unique identity: if x is an object, then id(x) returns this object’s identity. From the Python documentation, “this is guaranteed to be unique among simultaneously existing objects”. In the implementation of the Python that we use, this unique id is nothing but the object’s memory address.\n\n\n\nReferencing\n\n\nIn line-2, we are not creating a new object. We are merely creating another name, also called an alias, for the same object. Think of this like having a nickname. Your name and nickname are two different words, but both of them refer to you. To see if two Python names point to the same object, we can use the is keyword:\nlist1 = [1, 2, 3]\nlist2 = list1\nlist2[0] = 100\nprint(list1 is list2)\nThis prints True. Now consider another scenario:\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\nprint(list1 == list2)\nprint(list1 is list2)\nThis gives the following output:\nTrue\nFalse\nThis because equality and identity are two different things. In the code, line-3 checks for equality of two lists, line-4 checks if the two lists point to the same object. list1 and list2 point to two different objects and consequently have different identities. But, they store the same sequence of items and are hence equal.\nHow do we create a copy of a list so that updating one doesn’t end up changing both? Python provides three ways to do this:\nlist1 = [1, 2,  3]\nlist2 = list(list1)\nlist3 = list1[:]\nlist4 = list1.copy()\n\nlist2[0] = 100\nlist3[0] = 200\nlist4[0] = 300\n\nprint(list1, list2, list3, list4)\nprint(list1 is not list2, list1 is not list3, list1 is not list4)\nThis results in the following output:\n[1, 2, 3] [100, 2, 3] [200, 2, 3] [300, 2, 3]\nTrue True True\n\nIn line-2, we pass list1 as an argument to the list function which returns a new list object with the same sequence of elements as list1.\nIn line-3, we are slicing the list. Slicing a list results in a new list object. As no start or stop values are mentioned, they are going to default to 0 and len(list1) respectively. So, the entire list is returned. However, it is a brand new object.\nIn line-4, we use a method call copy that is defined for the list object.\n\nLines 10 and 11 verify that the methods used to copy lists in lines 2, 3 and 4 actually work.\n\n\n\nMutability impacts the way lists are handled in functions. Consider these two snippets:\n# Snippet-1\ndef foo():\n    L.append(1)\n    \nL = [0]\nprint(f'L before: {L}')\nfoo()\nprint(f'L after: {L}')\nSnippet-1 doesn’t have any parameters. Since L is not being assigned a new value inside foo, the scope of L remains global.\n# Snippet-2\ndef foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n\nL = [0]\nprint(f'L before: {L}')\nfoo(L)\nprint(f'L after: {L}')\nSnippet-2 has L_foo as a parameter whose scope is local to foo. But note that modifying L_foo within the function changes L outside the function. This is because, L_foo and L point to the same object. How did this aliasing happen? The function call at line-8 works something like an assignment statement: L_foo = L, so L_foo is just another name that refers to the object that L is bound to. This type of function call where a reference to an object is passed is termed call by reference. Whenever a mutable variable is passed as an argument to a function, the references to the corresponding object are passed.\nIf all this seems too complicated, just remember that modifying mutable objects within a function produces side effects outside the function. What if we don’t want these side effects? We have to create a new list object like we did before:\ndef foo(L_foo):\n    L_foo.append(1)\n    print(L is L_foo)\n    \nL = [0]\nprint(f'L before: {L}')\nfoo(list(L))\nprint(f'L after: {L}')\nfoo doesn’t produce any side effects. Line-7 could be replaced with foo(L[:]) or foo(L.copy())."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.3.html",
    "href": "notes/chapter-5/lesson-5.3.html",
    "title": "Lesson-5.3",
    "section": "",
    "text": "Let us return to the problem of recording the number of runs scored in every ball of an IPL match. A typical innings of a T20 match has 20 overs, each over having 6 balls. Let us assume that all balls bowled are fair deliveries that do not concede any extras, a rather liberal assumption. This leaves us with exactly 120 numbers that we need to record, all lying between 0 and 6. How can this information be stored in a Python program that makes it suitable for further processing? A list is a good candidate.\nLet us now simulate an innings. For this, we take the help of the random library:\nimport random\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], k = 120)\nprint(type(runs))\nprint(len(runs))\nchoices is a function in the random library. It uniformly samples from the seven numbers (0 to 6) given in the input list with replacement. If that sounded too cryptic, this is what it does:\n\nPick a number from the list [0, 1, 2, 3, 4, 5, 6] at random. Each of the seven numbers is equally likely to be picked.\nAdd this to the output list. The original list remains undisturbed, i.e., we are not moving an element from the input list to the output list, we are only copying it.\nRepeat this process 120 times.\n\nLet us verify if the counts are approximately the same:\nfor run in [0, 1, 2, 3, 4, 5, 6]:\n    print('{} appears {} times'.format(run, runs.count(run)))\nruns.count(run) returns the number of times the element run appears in the list runs. count is a method defined for the list type. This gives the following output:\n0 appears 19 times\n1 appears 20 times\n2 appears 19 times\n3 appears 16 times\n4 appears 18 times\n5 appears 11 times\n6 appears 17 times\nThe counts are quite close. But this is not very practical:\n\n5 runs are seldom observed in cricket matches.\n0, 1 and 2 are much more common than 3, 4 and 6.\n\nWe can give our preferences using a weights keyword-argument:\nimport random\n# choices is distributed over multiple lines\n# this is done to improve readability\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], \n                      weights = [30, 30, 20, 5, 10, 0, 5], \n                      k = 120)\nfor run in [0, 1, 2, 3, 4, 5, 6]:\n    print('{} appears {} times'.format(run, runs.count(run)))\nprint(f'Total number of runs scored = {sum(runs)}')\nThis gives the following output:\n0 appears 32 times\n1 appears 34 times\n2 appears 32 times\n3 appears 7 times\n4 appears 12 times\n5 appears 0 times\n6 appears 3 times\nTotal number of runs scored = 185\nWe have used sum(runs) to get the sum of the elements in the list. sum is a built-in function. The way to understand the weights keyword-argument is using the following table:\n\n\n\nRun\nWeight\n\n\n\n\n0\n30\n\n\n1\n30\n\n\n2\n20\n\n\n3\n5\n\n\n4\n10\n\n\n5\n0\n\n\n6\n5\n\n\nTotal\n100\n\n\n\nThe weight is the importance given to a run. From the table given above, we see that 0 and 1 occur 30% of the times, 6 occurs 5% of the times and so on. choices function will keep this distribution in mind while picking up items from the input-list.\nLet us now start analyzing this innings. We have already seen how to count the number of occurrences of singles, doubles, fours and sixes. What about the first occurrence of a six? In which ball was the first six scored?\nfirst_six_ball = runs.index(6) + 1\nprint(first_six_ball)\nindex is a method that accepts an element as input and returns the first occurrence of this element in the list. For example, runs.index(6) returns the first index where a six occurs in the list runs. Since the number of balls is one more than the index, 1 has been added. What happens if we pass an input that is not present in the list:\nfirst_five_ball = runs.index(5)\nprint(first_five_ball)\nIn this case, 5 never occurs in the list. So this throws a ValueError with the following message: 5 is not in list. One must be careful while using the index method. We could have done this using another method:\nfor ball, run in enumerate(runs):\n    if run == 6:\n        print(f'The first six was hit at ball number {ball + 1}')\n        break\nThe enumerate object can be very handy when we want to access both the element and its index while iterating through a list. The enumerate object yields pairs: (index, list[index]). In some sense, we have two loop variables: the first is the index of the element in the list while the second is the element itself. Coming back to cricket, what if we want to find the number of balls it took to score the last 50 runs in the innings? It would be easier to reverse the list and then iterate through it:\nballs = 0\nlast_runs = 0\nfor run in reversed(runs):\n    last_runs += run\n    balls += 1\n    if last_runs &gt;= 50:\n        print(f'It took {balls} balls to score the last 50 runs.')\n        break\nThe reversed object helps us iterate through the list in the reversed order. Note that it doesn’t make any changes to the original list. One final question: we wish to find if the batsmen have run three runs at any point in the match. We don’t want to know at which point in the innings this has happened.\nthree_existence = 3 in runs\nprint(three_existence)\nRecall that we used the in keyword to check for the presence of one string in another. Something similar is happening here. The code given above prints True if 3 is an element in runs and False otherwise."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.3.html#lists",
    "href": "notes/chapter-5/lesson-5.3.html#lists",
    "title": "Lesson-5.3",
    "section": "",
    "text": "Let us return to the problem of recording the number of runs scored in every ball of an IPL match. A typical innings of a T20 match has 20 overs, each over having 6 balls. Let us assume that all balls bowled are fair deliveries that do not concede any extras, a rather liberal assumption. This leaves us with exactly 120 numbers that we need to record, all lying between 0 and 6. How can this information be stored in a Python program that makes it suitable for further processing? A list is a good candidate.\nLet us now simulate an innings. For this, we take the help of the random library:\nimport random\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], k = 120)\nprint(type(runs))\nprint(len(runs))\nchoices is a function in the random library. It uniformly samples from the seven numbers (0 to 6) given in the input list with replacement. If that sounded too cryptic, this is what it does:\n\nPick a number from the list [0, 1, 2, 3, 4, 5, 6] at random. Each of the seven numbers is equally likely to be picked.\nAdd this to the output list. The original list remains undisturbed, i.e., we are not moving an element from the input list to the output list, we are only copying it.\nRepeat this process 120 times.\n\nLet us verify if the counts are approximately the same:\nfor run in [0, 1, 2, 3, 4, 5, 6]:\n    print('{} appears {} times'.format(run, runs.count(run)))\nruns.count(run) returns the number of times the element run appears in the list runs. count is a method defined for the list type. This gives the following output:\n0 appears 19 times\n1 appears 20 times\n2 appears 19 times\n3 appears 16 times\n4 appears 18 times\n5 appears 11 times\n6 appears 17 times\nThe counts are quite close. But this is not very practical:\n\n5 runs are seldom observed in cricket matches.\n0, 1 and 2 are much more common than 3, 4 and 6.\n\nWe can give our preferences using a weights keyword-argument:\nimport random\n# choices is distributed over multiple lines\n# this is done to improve readability\nruns = random.choices([0, 1, 2, 3, 4, 5, 6], \n                      weights = [30, 30, 20, 5, 10, 0, 5], \n                      k = 120)\nfor run in [0, 1, 2, 3, 4, 5, 6]:\n    print('{} appears {} times'.format(run, runs.count(run)))\nprint(f'Total number of runs scored = {sum(runs)}')\nThis gives the following output:\n0 appears 32 times\n1 appears 34 times\n2 appears 32 times\n3 appears 7 times\n4 appears 12 times\n5 appears 0 times\n6 appears 3 times\nTotal number of runs scored = 185\nWe have used sum(runs) to get the sum of the elements in the list. sum is a built-in function. The way to understand the weights keyword-argument is using the following table:\n\n\n\nRun\nWeight\n\n\n\n\n0\n30\n\n\n1\n30\n\n\n2\n20\n\n\n3\n5\n\n\n4\n10\n\n\n5\n0\n\n\n6\n5\n\n\nTotal\n100\n\n\n\nThe weight is the importance given to a run. From the table given above, we see that 0 and 1 occur 30% of the times, 6 occurs 5% of the times and so on. choices function will keep this distribution in mind while picking up items from the input-list.\nLet us now start analyzing this innings. We have already seen how to count the number of occurrences of singles, doubles, fours and sixes. What about the first occurrence of a six? In which ball was the first six scored?\nfirst_six_ball = runs.index(6) + 1\nprint(first_six_ball)\nindex is a method that accepts an element as input and returns the first occurrence of this element in the list. For example, runs.index(6) returns the first index where a six occurs in the list runs. Since the number of balls is one more than the index, 1 has been added. What happens if we pass an input that is not present in the list:\nfirst_five_ball = runs.index(5)\nprint(first_five_ball)\nIn this case, 5 never occurs in the list. So this throws a ValueError with the following message: 5 is not in list. One must be careful while using the index method. We could have done this using another method:\nfor ball, run in enumerate(runs):\n    if run == 6:\n        print(f'The first six was hit at ball number {ball + 1}')\n        break\nThe enumerate object can be very handy when we want to access both the element and its index while iterating through a list. The enumerate object yields pairs: (index, list[index]). In some sense, we have two loop variables: the first is the index of the element in the list while the second is the element itself. Coming back to cricket, what if we want to find the number of balls it took to score the last 50 runs in the innings? It would be easier to reverse the list and then iterate through it:\nballs = 0\nlast_runs = 0\nfor run in reversed(runs):\n    last_runs += run\n    balls += 1\n    if last_runs &gt;= 50:\n        print(f'It took {balls} balls to score the last 50 runs.')\n        break\nThe reversed object helps us iterate through the list in the reversed order. Note that it doesn’t make any changes to the original list. One final question: we wish to find if the batsmen have run three runs at any point in the match. We don’t want to know at which point in the innings this has happened.\nthree_existence = 3 in runs\nprint(three_existence)\nRecall that we used the in keyword to check for the presence of one string in another. Something similar is happening here. The code given above prints True if 3 is an element in runs and False otherwise."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.6.html",
    "href": "notes/chapter-5/lesson-5.6.html",
    "title": "Lesson-5.6",
    "section": "",
    "text": "A tuple is an immutable sequence of values:\nfamily = ('father', 'mother', 'child')\nprint(type(family))\nprint(isinstance(family, tuple))\nTuples share a close resemblance to lists. They can be indexed and sliced just like lists:\nprint(family[0])\nprint(family[:2])\nThe main point of difference between lists and tuples is that tuples cannot be updated in-place since they are immutable. So, the following operation will throw an error:\n##### Alarm! Wrong code snippet! #####\nnumbers = ('one', 'two', 'four')\nnumbers[2] = 'three'\n##### Alarm! Wrong code snippet! #####\nThe interpreter throws a TypeError with the following message: TypeError: 'tuple' object does not support item assignment. As a consequence, we cannot append or insert elements into a tuple. Likewise, elements in a tuple cannot be deleted. count and index are the only two methods which are defined for tuple and they carry the usual meaning:\nnumbers = (1, 2, 3, 1, 1)\nprint(numbers.count(1))\nprint(numbers.index(2))\nWe can iterate through a tuple using for:\nfor num in (1, 2, 3):\n    print(num)\nSince tuples are immutable, they are passed by value in functions similar to other immutable types such as strings and numbers. As for functions that operate on tuples, sum, max, min are useful ones.\n\n\n\nA few more points on tuples.\n\nA singleton tuple should be defined as follows:\n\ni_am_single = (1, )\nprint(len(i_am_single))\nprint(isinstance(i_am_single, tuple))\nNote the presence of a comma after the element. Let us see what happens if it is removed:\ni_am_single = (1)\nprint(isinstance(i_am_single, int))\nIt is an integer!\n\nA list can be converted into a tuple and vice versa:\n\na_list = [1, 2, 3]\na_tuple = tuple(a_list)\nb_tuple = (1, 2, 3)\nb_list = list(b_tuple)\n\nA tuple can hold a non-homogeneous sequence of items:\n\na_tuple = (1, 'cool', True)\n\nMembership can be determined using the in keyword:\n\n1 in (1, 2, 3)\n'hello' not in ('some', 'random', 'sequence')\n\nTuples can be nested:\n\na = ((1, 2, 3), (4, 5, 6))\nprint(a[0][2])\n\nA tuple can hold mutable objects.\n\na_tuple = ([0, 1, 2], [4, 5, 6])\na_tuple[0][0] = 100\nThe code given above runs without any errors. But we are trying to update the tuple in line-2. Aren’t tuples immutable? Though a_tuple is immutable, the element inside it is mutable. In any case, we aren’t trying to change the sequence of objects inside the tuple, i.e., a_tuple[0] continues to point to the same object. Let us verify this:\na_tuple = ([0, 1, 2], [4, 5, 6])\nprint(id(a_tuple[0]))\na_tuple[0][0] = 100\nprint(id(a_tuple[0]))\nWe see that the id of the element inside the tuple remains unchanged. Thus the identities of the sequence of objects that make up a tuple can never change, and the interpreter will never allow that to change. If the objects inside the sequence are mutable — such as lists — then the values that they hold might change, but they continue to retain their identities.\n\n\n\nWe have seen the close kinship between lists and tuples. Here is a brief summary that highlights the points of agreement and disagreement:\n\n\n\n\n\n\n\nList\nTuple\n\n\n\n\nMutable\nImmutable\n\n\nL = [1, 2, 3]\nT = (1, 2, 3)\n\n\nSupports indexing and slicing\nSupports indexing and slicing\n\n\nSupports item assignment\nDoesn’t support item assignment\n\n\nSupported methods: count, index, append, insert, remove, pop and others\nSupported methods: count, index\n\n\nTo get a list: list(obj)\nTo get a tuple: tuple(obj)\n\n\n\nThe partnership between lists and tuples is quite interesting and can be explored further with another example.\n\nPopulate a list that contains all ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs.\n\nSolution\npairs = [ ]\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            pairs.append((a, b))\nprint(pairs)\npairs is a list of tuples. We could have stored each pair as a list. But a tuple is the better choice here since the two elements in the pair have a well defined relationship and we don’t want to accidentally modify them.\n\n\n\nAt first sight, tuples might seem redundant members in the Python family, but they do occupy a significant place. For that, we have to look at tuples in more detail. Consider the following code:\nT = 1, 2, 3\nprint(T)\nprint(isinstance(T, tuple))\nAt first sight, line-1 seems to be an error. We have seen multiple assignment on the same line, perhaps we are two variables short on the LHS? But on execution, we see that there is no error. T is in fact the tuple (1, 2, 3). This is called tuple packing. The values 1, 2 and 3 are packed into a tuple. The reverse operation is called sequence unpacking:\nx, y, z = T\nprint(x, y, z)\nHere, the tuple T is unpacked into the corresponding variables x, y and z. This is the principle behind multiple assignment. From the Python documentation, we have refer\n\nMultiple assignment is a combination of tuple packing and sequence unpacking.\n\nx, y, z = 1, 2, 3\nIn the line given above, the RHS is first packed into a tuple and the sequence is then unpacked into the variables x, y and z. But why does the unpacking operation have the qualifier sequence before it? This is because any sequence can be unpacked:\nl1, l2, l3, l4 = 'good'         # string\nnum1, num2, num3 = [1, 2, 3]    # list\nb1, b2 = (True, False)          # tuple\nx, y, z = range(3)              # range\nThat’s fun! The same operations are invoked when multiple values are returned from functions:\ndef max_min(a, b):\n    if a &gt; b:\n        return a, b\n    return b, a\n\nx = max_min(1, 2)\nprint(x)\nprint(isinstance(x, tuple))\nWe see that x is a tuple. In the return statements at lines 3 and 4, multiple values are packed into tuples. So, the function is essentially returning a tuple."
  },
  {
    "objectID": "notes/chapter-5/lesson-5.6.html#tuples",
    "href": "notes/chapter-5/lesson-5.6.html#tuples",
    "title": "Lesson-5.6",
    "section": "",
    "text": "A tuple is an immutable sequence of values:\nfamily = ('father', 'mother', 'child')\nprint(type(family))\nprint(isinstance(family, tuple))\nTuples share a close resemblance to lists. They can be indexed and sliced just like lists:\nprint(family[0])\nprint(family[:2])\nThe main point of difference between lists and tuples is that tuples cannot be updated in-place since they are immutable. So, the following operation will throw an error:\n##### Alarm! Wrong code snippet! #####\nnumbers = ('one', 'two', 'four')\nnumbers[2] = 'three'\n##### Alarm! Wrong code snippet! #####\nThe interpreter throws a TypeError with the following message: TypeError: 'tuple' object does not support item assignment. As a consequence, we cannot append or insert elements into a tuple. Likewise, elements in a tuple cannot be deleted. count and index are the only two methods which are defined for tuple and they carry the usual meaning:\nnumbers = (1, 2, 3, 1, 1)\nprint(numbers.count(1))\nprint(numbers.index(2))\nWe can iterate through a tuple using for:\nfor num in (1, 2, 3):\n    print(num)\nSince tuples are immutable, they are passed by value in functions similar to other immutable types such as strings and numbers. As for functions that operate on tuples, sum, max, min are useful ones.\n\n\n\nA few more points on tuples.\n\nA singleton tuple should be defined as follows:\n\ni_am_single = (1, )\nprint(len(i_am_single))\nprint(isinstance(i_am_single, tuple))\nNote the presence of a comma after the element. Let us see what happens if it is removed:\ni_am_single = (1)\nprint(isinstance(i_am_single, int))\nIt is an integer!\n\nA list can be converted into a tuple and vice versa:\n\na_list = [1, 2, 3]\na_tuple = tuple(a_list)\nb_tuple = (1, 2, 3)\nb_list = list(b_tuple)\n\nA tuple can hold a non-homogeneous sequence of items:\n\na_tuple = (1, 'cool', True)\n\nMembership can be determined using the in keyword:\n\n1 in (1, 2, 3)\n'hello' not in ('some', 'random', 'sequence')\n\nTuples can be nested:\n\na = ((1, 2, 3), (4, 5, 6))\nprint(a[0][2])\n\nA tuple can hold mutable objects.\n\na_tuple = ([0, 1, 2], [4, 5, 6])\na_tuple[0][0] = 100\nThe code given above runs without any errors. But we are trying to update the tuple in line-2. Aren’t tuples immutable? Though a_tuple is immutable, the element inside it is mutable. In any case, we aren’t trying to change the sequence of objects inside the tuple, i.e., a_tuple[0] continues to point to the same object. Let us verify this:\na_tuple = ([0, 1, 2], [4, 5, 6])\nprint(id(a_tuple[0]))\na_tuple[0][0] = 100\nprint(id(a_tuple[0]))\nWe see that the id of the element inside the tuple remains unchanged. Thus the identities of the sequence of objects that make up a tuple can never change, and the interpreter will never allow that to change. If the objects inside the sequence are mutable — such as lists — then the values that they hold might change, but they continue to retain their identities.\n\n\n\nWe have seen the close kinship between lists and tuples. Here is a brief summary that highlights the points of agreement and disagreement:\n\n\n\n\n\n\n\nList\nTuple\n\n\n\n\nMutable\nImmutable\n\n\nL = [1, 2, 3]\nT = (1, 2, 3)\n\n\nSupports indexing and slicing\nSupports indexing and slicing\n\n\nSupports item assignment\nDoesn’t support item assignment\n\n\nSupported methods: count, index, append, insert, remove, pop and others\nSupported methods: count, index\n\n\nTo get a list: list(obj)\nTo get a tuple: tuple(obj)\n\n\n\nThe partnership between lists and tuples is quite interesting and can be explored further with another example.\n\nPopulate a list that contains all ordered pairs of positive integers whose product is 100. Note that order matters: (2, 50) and (50, 2) are two different pairs.\n\nSolution\npairs = [ ]\nfor a in range(1, 101):\n    for b in range(1, 101):\n        if a * b == 100:\n            pairs.append((a, b))\nprint(pairs)\npairs is a list of tuples. We could have stored each pair as a list. But a tuple is the better choice here since the two elements in the pair have a well defined relationship and we don’t want to accidentally modify them.\n\n\n\nAt first sight, tuples might seem redundant members in the Python family, but they do occupy a significant place. For that, we have to look at tuples in more detail. Consider the following code:\nT = 1, 2, 3\nprint(T)\nprint(isinstance(T, tuple))\nAt first sight, line-1 seems to be an error. We have seen multiple assignment on the same line, perhaps we are two variables short on the LHS? But on execution, we see that there is no error. T is in fact the tuple (1, 2, 3). This is called tuple packing. The values 1, 2 and 3 are packed into a tuple. The reverse operation is called sequence unpacking:\nx, y, z = T\nprint(x, y, z)\nHere, the tuple T is unpacked into the corresponding variables x, y and z. This is the principle behind multiple assignment. From the Python documentation, we have refer\n\nMultiple assignment is a combination of tuple packing and sequence unpacking.\n\nx, y, z = 1, 2, 3\nIn the line given above, the RHS is first packed into a tuple and the sequence is then unpacked into the variables x, y and z. But why does the unpacking operation have the qualifier sequence before it? This is because any sequence can be unpacked:\nl1, l2, l3, l4 = 'good'         # string\nnum1, num2, num3 = [1, 2, 3]    # list\nb1, b2 = (True, False)          # tuple\nx, y, z = range(3)              # range\nThat’s fun! The same operations are invoked when multiple values are returned from functions:\ndef max_min(a, b):\n    if a &gt; b:\n        return a, b\n    return b, a\n\nx = max_min(1, 2)\nprint(x)\nprint(isinstance(x, tuple))\nWe see that x is a tuple. In the return statements at lines 3 and 4, multiple values are packed into tuples. So, the function is essentially returning a tuple."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.2.html",
    "href": "notes/chapter-4/lesson-4.2.html",
    "title": "Lesson-4.2",
    "section": "",
    "text": "Python offers a number of options in terms of the way arguments can be passed to functions.\n\n\nAll functions that we have seen so far have used positional arguments. Here, the position of an argument in the function call determines the parameter to which it is passed. Let us take the following problem:\n!!! question ” ” Write a function that accepts three positive integers x, y and z. Return True if the three integers form the sides of a right triangle with x and y as its legs and z as the hypotenuse, and False otherwise.\nSolution\ndef isRight(x, y, z):\n    if x ** 2 + y ** 2 == z ** 2:\n        return True\n    return False\n\nprint(isRight(3, 4, 5)) # 3 is passed to x, 4 is passed to y, 5 is passed to z\nprint(isRight(5, 4, 3)) # 5 is passed to x, 4 is passed to y, 3 is passed to z\nThe output is:\nTrue\nFalse\nArguments are passed to the parameters of the function based on the position they occupy in the function call. Look at the comments in the above code to get a clear picture. Positional arguments are also called required arguments, i.e., they cannot be left out. Likewise, adding more arguments than there are parameters will throw an error. When positional arguments are involved, there should be exactly as many arguments in the function call as there are parameters in the function definition. Try to execute the following code and study the error message:\n##### Alarm! Wrong code snippet!\nisRight(3, 4)\nisRight(3, 4, 5, 6)\n##### Alarm! Wrong code snippet!\n\n\n\nKeyword arguments introduce more flexibility while passing arguments. Let us take up the same problem that we saw in the previous section and just modify the function calls:\n# The following is just a function call.\n# We are not printing anything here.\nisRight(x = 3, y = 4, z = 5)\nThe function call in line 3 uses what are known as keyword arguments. In this method, the names of the parameters are explicitly specified and the arguments are assigned to it using the #!py = operator. This is different from positional arguments where the position of the argument in the function call determines the parameter to which it is bound. One advantage of using keyword arguments is that it reduces the possibility of entering the arguments in an incorrect order. For example:\nisRight(3, 4, 5)    # intended call\nisRight(5, 4, 3)    # actuall call\nisRight(x = 3, y = 4, z = 5) # same as intended call\nisRight(z = 5, y = 4, x = 3) # same as intended call\nKeyword arguments and positional arguments can be combined in a single call:\nisRight(3, y = 4, z = 5)\nNow try this out:\n#### Alarm! Wrong code snippet! ####\nisRight(x = 3, 4, 5)\n#### Alarm! Wrong code snippet! ####\nThe interpreter throws a TypeError with the following message: positional argument follows keyword arguments. That is, in our function call, the positional arguments — #!py 4 and #!py 5 — come after the keyword argument #!py x = 3. Why does the interpreter objects to this? Whenever both positional and keyword arguments are present in a function call, the keyword arguments must always come at the end. This is quite reasonable: positional arguments are extremely sensitive to position, so it is best to have them at the beginning.\nHow about the following call?\n#### Alarm! Wrong code snippet! ####\nisRight(3, x = 3, y = 4, z = 5)\n#### Alarm! Wrong code snippet! ####\nThe interpreter objects by throwing a TypeError with the following message: isRight() got multiple values for argument x. Objection granted! Another reasonable requirement from the Python interpreter: there must be exactly one argument in the function call for each parameter in the function definition, nothing more, nothing less. This could be a positional argument or a default argument, but not both.\n\n\n\nConsider the following scenario. The image that you see here is a map of your neighborhood. The grid lines are roads that can be used by cars. You wish to reach the point \\(P\\) from \\(O\\). There are no restrictions if you are on foot. The easiest way is to move along the line \\(OP\\). This is called the Euclidean distance between points \\(O\\) and \\(P\\). If you are in a car, then you are forced to move along the grid lines. The distance you would have to cover in a car is \\(OM + MP\\). This distance is called the Manhattan distance between points \\(O\\) and \\(P\\).\n\nLet us say that a self-driving car startup operating in your neighborhood uses both these metrics while computing distances. Assume that its code base invokes the Euclidean distance 10 times and the Manhattan distance 1000 times. Since these metrics are used repeatedly, it is a good idea to represent them as functions in the code base:\n# Assume that O is the origin\n# All distances are computed from the origin\ndef euclidean(x, y):\n    return pow(x ** 2 + y ** 2, 0.5)\n\ndef manhattan(x, y):\n    return abs(x) + abs(y)\nWhile the above code is fine, it ignores the fact that the Manhattan distance is being used hundred times more frequently compared to the Euclidean distance. Default arguments can come in handy in such situations:\ndef distance(x, y, metric = 'manhattan'):\n    if metric == 'manhattan':\n        return abs(x) + abs(y)\n    elif metric == 'euclidean':\n        return pow(x ** 2 + y ** 2, 0.5)\nThe parameter metric has #!py 'manhattan' as the default value. Let us try calling the function without passing any argument to the metric parameter:\nprint(distance(3, 4))\nThis gives 7 as the output. Since no value was provided in the function call, the default value of #!py 'manhattan' was assigned to the metric parameter. In the code base, wherever the Manhattan distance is invoked, we can just replace it with the function call distance(x, y).\nThe following points are important to keep in mind:\n\nParameters that are assigned a value in the function definition are called default parameters.\nDefault parameters always come at the end of the parameter list in a function definition.\nThe argument corresponding to a default parameter is optional in a function call.\nAn argument corresponding to a default parameter can be passed as a positional argument or as a keyword argument.\n\nLet us illustrate some of these points:\n#### Alarm! Wrong code snippet! ####\ndef distance(metric = 'manhattan', x, y):\n    if metric == 'manhattan':\n        return abs(x) + abs(y)\n    elif metric == 'euclidean':\n        return pow(x ** 2 + y ** 2, 0.5)\n#### Alarm! Wrong code snippet! ####\nThe above code throws a SyntaxError with the following message: non-default argument follows default argument. In the function definition, the default parameter must always come at the end of the list of parameters. Now, for different ways of passing arguments in the presence of default parameters:\ndistance(3, 4)\ndistance(3, 4, 'manhattan')\ndistance(3, 4, metric = 'manhattan')\nAll three function calls are equivalent. The first one uses default value of metric. The second call explicitly passes 'manhattan' as the metric using a positional argument. The last call explicitly passes 'manhattan' as a keyword argument.\n\n\n\n\nConsider the following code:\ndef double(x):\n    x = x * 2\n    return x\n\na = 4\nprint(f'before function call, a = {a}')\ndouble(a)\nprint(f'after function call, a = {a}')\nThe output is:\nbefore function call, a = 4\nafter function call, a = 4\nWe see that the value of a is not disturbed by the function in any way. When the function call double(a) is invoked, the value in a is assigned to the parameter x in the function. Arguments are passed by assignment in Python, which means that something like #!py x = a happens when double(a) is invoked. This kind of a function call where the value in a variable is passed as argument to the function is called call by value.\nConsider the following code:\ndef square(x):\n    return x * x\n\nx = 10\nx_squared = square(x)\nWe are using the same name for both the parameter of the function square and the argument passed to it. This is a bad practice. It is always preferable to differentiate the names of the parameters from the names of the arguments that are passed in the function call. This avoids confusion and makes code more readable. At this stage, you might be wondering how the variable x inside the function is related to the variable x outside it. This issue will be taken up in the next lesson on scopes. The above code could be rewritten as follows:\ndef square(num):\n    return num * num\n\nx = 10\nx_squared = square(x)"
  },
  {
    "objectID": "notes/chapter-4/lesson-4.2.html#arguments",
    "href": "notes/chapter-4/lesson-4.2.html#arguments",
    "title": "Lesson-4.2",
    "section": "",
    "text": "Python offers a number of options in terms of the way arguments can be passed to functions.\n\n\nAll functions that we have seen so far have used positional arguments. Here, the position of an argument in the function call determines the parameter to which it is passed. Let us take the following problem:\n!!! question ” ” Write a function that accepts three positive integers x, y and z. Return True if the three integers form the sides of a right triangle with x and y as its legs and z as the hypotenuse, and False otherwise.\nSolution\ndef isRight(x, y, z):\n    if x ** 2 + y ** 2 == z ** 2:\n        return True\n    return False\n\nprint(isRight(3, 4, 5)) # 3 is passed to x, 4 is passed to y, 5 is passed to z\nprint(isRight(5, 4, 3)) # 5 is passed to x, 4 is passed to y, 3 is passed to z\nThe output is:\nTrue\nFalse\nArguments are passed to the parameters of the function based on the position they occupy in the function call. Look at the comments in the above code to get a clear picture. Positional arguments are also called required arguments, i.e., they cannot be left out. Likewise, adding more arguments than there are parameters will throw an error. When positional arguments are involved, there should be exactly as many arguments in the function call as there are parameters in the function definition. Try to execute the following code and study the error message:\n##### Alarm! Wrong code snippet!\nisRight(3, 4)\nisRight(3, 4, 5, 6)\n##### Alarm! Wrong code snippet!\n\n\n\nKeyword arguments introduce more flexibility while passing arguments. Let us take up the same problem that we saw in the previous section and just modify the function calls:\n# The following is just a function call.\n# We are not printing anything here.\nisRight(x = 3, y = 4, z = 5)\nThe function call in line 3 uses what are known as keyword arguments. In this method, the names of the parameters are explicitly specified and the arguments are assigned to it using the #!py = operator. This is different from positional arguments where the position of the argument in the function call determines the parameter to which it is bound. One advantage of using keyword arguments is that it reduces the possibility of entering the arguments in an incorrect order. For example:\nisRight(3, 4, 5)    # intended call\nisRight(5, 4, 3)    # actuall call\nisRight(x = 3, y = 4, z = 5) # same as intended call\nisRight(z = 5, y = 4, x = 3) # same as intended call\nKeyword arguments and positional arguments can be combined in a single call:\nisRight(3, y = 4, z = 5)\nNow try this out:\n#### Alarm! Wrong code snippet! ####\nisRight(x = 3, 4, 5)\n#### Alarm! Wrong code snippet! ####\nThe interpreter throws a TypeError with the following message: positional argument follows keyword arguments. That is, in our function call, the positional arguments — #!py 4 and #!py 5 — come after the keyword argument #!py x = 3. Why does the interpreter objects to this? Whenever both positional and keyword arguments are present in a function call, the keyword arguments must always come at the end. This is quite reasonable: positional arguments are extremely sensitive to position, so it is best to have them at the beginning.\nHow about the following call?\n#### Alarm! Wrong code snippet! ####\nisRight(3, x = 3, y = 4, z = 5)\n#### Alarm! Wrong code snippet! ####\nThe interpreter objects by throwing a TypeError with the following message: isRight() got multiple values for argument x. Objection granted! Another reasonable requirement from the Python interpreter: there must be exactly one argument in the function call for each parameter in the function definition, nothing more, nothing less. This could be a positional argument or a default argument, but not both.\n\n\n\nConsider the following scenario. The image that you see here is a map of your neighborhood. The grid lines are roads that can be used by cars. You wish to reach the point \\(P\\) from \\(O\\). There are no restrictions if you are on foot. The easiest way is to move along the line \\(OP\\). This is called the Euclidean distance between points \\(O\\) and \\(P\\). If you are in a car, then you are forced to move along the grid lines. The distance you would have to cover in a car is \\(OM + MP\\). This distance is called the Manhattan distance between points \\(O\\) and \\(P\\).\n\nLet us say that a self-driving car startup operating in your neighborhood uses both these metrics while computing distances. Assume that its code base invokes the Euclidean distance 10 times and the Manhattan distance 1000 times. Since these metrics are used repeatedly, it is a good idea to represent them as functions in the code base:\n# Assume that O is the origin\n# All distances are computed from the origin\ndef euclidean(x, y):\n    return pow(x ** 2 + y ** 2, 0.5)\n\ndef manhattan(x, y):\n    return abs(x) + abs(y)\nWhile the above code is fine, it ignores the fact that the Manhattan distance is being used hundred times more frequently compared to the Euclidean distance. Default arguments can come in handy in such situations:\ndef distance(x, y, metric = 'manhattan'):\n    if metric == 'manhattan':\n        return abs(x) + abs(y)\n    elif metric == 'euclidean':\n        return pow(x ** 2 + y ** 2, 0.5)\nThe parameter metric has #!py 'manhattan' as the default value. Let us try calling the function without passing any argument to the metric parameter:\nprint(distance(3, 4))\nThis gives 7 as the output. Since no value was provided in the function call, the default value of #!py 'manhattan' was assigned to the metric parameter. In the code base, wherever the Manhattan distance is invoked, we can just replace it with the function call distance(x, y).\nThe following points are important to keep in mind:\n\nParameters that are assigned a value in the function definition are called default parameters.\nDefault parameters always come at the end of the parameter list in a function definition.\nThe argument corresponding to a default parameter is optional in a function call.\nAn argument corresponding to a default parameter can be passed as a positional argument or as a keyword argument.\n\nLet us illustrate some of these points:\n#### Alarm! Wrong code snippet! ####\ndef distance(metric = 'manhattan', x, y):\n    if metric == 'manhattan':\n        return abs(x) + abs(y)\n    elif metric == 'euclidean':\n        return pow(x ** 2 + y ** 2, 0.5)\n#### Alarm! Wrong code snippet! ####\nThe above code throws a SyntaxError with the following message: non-default argument follows default argument. In the function definition, the default parameter must always come at the end of the list of parameters. Now, for different ways of passing arguments in the presence of default parameters:\ndistance(3, 4)\ndistance(3, 4, 'manhattan')\ndistance(3, 4, metric = 'manhattan')\nAll three function calls are equivalent. The first one uses default value of metric. The second call explicitly passes 'manhattan' as the metric using a positional argument. The last call explicitly passes 'manhattan' as a keyword argument."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.2.html#call-by-value",
    "href": "notes/chapter-4/lesson-4.2.html#call-by-value",
    "title": "Lesson-4.2",
    "section": "",
    "text": "Consider the following code:\ndef double(x):\n    x = x * 2\n    return x\n\na = 4\nprint(f'before function call, a = {a}')\ndouble(a)\nprint(f'after function call, a = {a}')\nThe output is:\nbefore function call, a = 4\nafter function call, a = 4\nWe see that the value of a is not disturbed by the function in any way. When the function call double(a) is invoked, the value in a is assigned to the parameter x in the function. Arguments are passed by assignment in Python, which means that something like #!py x = a happens when double(a) is invoked. This kind of a function call where the value in a variable is passed as argument to the function is called call by value.\nConsider the following code:\ndef square(x):\n    return x * x\n\nx = 10\nx_squared = square(x)\nWe are using the same name for both the parameter of the function square and the argument passed to it. This is a bad practice. It is always preferable to differentiate the names of the parameters from the names of the arguments that are passed in the function call. This avoids confusion and makes code more readable. At this stage, you might be wondering how the variable x inside the function is related to the variable x outside it. This issue will be taken up in the next lesson on scopes. The above code could be rewritten as follows:\ndef square(num):\n    return num * num\n\nx = 10\nx_squared = square(x)"
  },
  {
    "objectID": "notes/chapter-4/lesson-4.3.html",
    "href": "notes/chapter-4/lesson-4.3.html",
    "title": "Lesson-4.3",
    "section": "",
    "text": "Consider the following code:\ndef foo():\n    x = 1\n    print('This is a veritable fortress. None can enter here.')\n    print('\\N{smirking face}')\n    \nfoo()\nprint(x)\nThis will give the following output:\nThis is a veritable fortress. None can enter here.\n😏\nTraceback (most recent call last):\n  File \"main.py\", line 7, in &lt;module&gt;\n    print(x)\nNameError: name 'x' is not defined\nWhy did the interpreter throw an an error in line-7? It tried to look for the name x and was unable to find it. But isn’t x present in the function foo? Is the interpreter careless or are we missing something? The interpreter is never wrong! The region in the code where a name can be referenced is called its scope. If we try to reference a variable outside its scope, the interpreter will throw a NameError.\n\n\nIn the above example, the scope of the name x is local to the function; x has a meaningful existence only inside the function and any attempt to access it from outside the function is going to result in an error. Think about functions as black holes: they don’t let variables (light) escape the function’s definition (event-horizon)! Let us take another example:\ny = 10\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\nfoo()\nThe name y is accessible from within the function as well. We say that the scope of y is global. That is, it can be referenced from anywhere within the program — even inside a function — after it has been defined for the first time. There is a slight catch here: if another variable with the same name is defined within the function, then things change. We will take up this case later.\nAt this stage, we are ready to formulate the rules for local and global variables [refer]:\n\nLocal: Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable.\nGlobal: If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable.\n\nThe scope of the parameters in the function definition are local. The following code will throw a NameError when executed:\ndef double(x):\n    x = x * 2\n    return x\n\ndouble(2)\nprint(x)\n\n\n\nLet us now look at few more examples that bring out some fine points regarding local and global scope:\n### Variant-1\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\ny = 10\nfoo()\nNotice the difference between this code and the one at the beginning of the earlier section. Here, the variable y is defined after the function definition, while in the earlier version y was defined before the function definition. But both versions give the same output. All that matters is for y to be defined before the function call. What happens if y is defined after foo is called?\n### Variant-2\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\nfoo()\ny = 10\nThis throws a NameError at line-5, which is reasonable as y is not defined in the main program before foo is called. The scope of y is still global; it can be referenced anywhere in the program once it has been defined.\nNow, let us crank up the difficulty level:\ndef foo():\n    x = 10\n    print(f'x inside foo = {x}')\n\nx = 100\nfoo()\nprint(f'x outside foo = {x}')\nWe have the same name — x — appearing inside the function and outside the function. Are they the same or different? Let us check the output:\nx inside foo = 10\nx outside foo = 100\nThey are different! The x inside foo is different from the x outside foo.\n\nThe scope of the name x inside foo is local; it is a local variable. This is because of the first rule: a variable that is assigned a value inside the function becomes a local variable. Since x is assigned a value in line-2, it becomes a local variable.\nThe scope of the x outside foo is global. Though there is another x inside the function foo, that cannot be accessed outside the function.\n\nThis may start to get a little confusing. How does Python internally manage local and global variables? For this, we will briefly turn to the concept of namespaces. This will give a different perspective to the problem of name resolution.\n\n\n\n\nConsider the following snippet of code:\nx = 1.0\navar = 'cool'\ndef foo():\n    pass\nWe have used three different names here: x, avar and foo. The first two names represent variables that store literals. The last name represents a function. How does the Python interpreter internally process these names? It uses a concept called namespaces. A namespace can be thought of as a lookup table — dictionary to be precise — that maps names to objects.\n\n\n\nNamespace\n\n\n\n\nThere are different types of namespaces. The variables that we define in the main program are represented in the globals namespace. For example:\nx = 1.0\navar = 'cool'\ndef foo():\n    y = 2.0\n\nfoo()\nprint(globals())\nThis returns the following output:\n\nIgnore all the other details and just focus on the region highlighted in yellow. Notice that the names x, avar and foo are present in the namespace. x and avar are mapped to the objects 1 and cool respectively, while foo is mapped to some complex looking object: &lt;function foo at 0x7f8ecd2aa1f0&gt;. The number 0x7f8ecd2aa1f0 is the location in the memory where the function’s definition is stored [refer]. There is another way to check whether a given name is in a namespace:\nprint('x' in globals())\nprint('avar' in globals())\nprint('foo' in globals())\nAll three lines result in True.\n\n\n\nNotice something interesting in the previous code, the name y is not found in the globals namespace! We can verify this as follows:\nprint('y' in globals())\nThis results in False. Variables that are assigned a value inside a function are local to the function and cannot be accessed outside it. How does the Python interpreter handle names inside functions? It creates a separate namespace every time a function is called. This is called a local namespace. Now, consider the following code:\ndef foo():\n    y = 2.0\n    print('Is y in locals?', 'y' in locals())\n\nfoo()\nprint('Is y in globals?', 'y' in globals())\nIt returns the following output:\nIs y in locals? True\nIs y in globals? False\n\n\n\n\nFor every function call, the interpreter creates a local namespace that contains all names and their corresponding objects that are defined in the function. Let us take an example:\ndef foo():\n    print(y)\n    print(locals())\n    x = 1\n    print(locals())\n\ny = 10\nfoo()\nThis gives the output:\n10\n{}\n{'x': 1}\nSince y is only being referenced inside foo, it doesn’t become a part of the local namespace. It remains a global variable. Since x is being assigned a value inside foo, it is a local variable and therefore enters the local namespace. The moment control exits the function, the namespace corresponding to it is deleted.\nWhenever the interpreter comes across a name in a function it sticks to the following protocol:\n\nFirst peep into the local namespace created for that function call to see if the name is present in it. If it is present, then go ahead and use the value that this variable points to in the local namespace.\nIf it is not present, then look at the global namespace. If it is present in the global namespace, then use the value corresponding to this name.\nIf it is not present in the global namespace, then look into the built-in namespace. We will come back to the built-in namespace right at the end.\nIf it is not present in any of these namespaces, then raise a NameError.\n\nThe following image captures this idea. The built-in namespace has been ignored for now. Refer to the last section to get the complete image.\n\nWith this context, let us revisit the problem that we looked at the end of the first section:\ndef foo():\n    x = 10\n    print(f'x inside foo = {x}')\n\nx = 100\nfoo()\nprint(f'x outside foo = {x}')\nWhen the function is called at line-6, the interpreter creates a local namespace for foo. At line-2, x becomes a part of this namespace. When x is referenced at line-3, the interpreter first looks at the local namespace for foo. Since x is present there, it is going to use the value corresponding to it - in this case 10. Once control exits the function, the local namespace corresponding to it is deleted. At line-7, the interpreter will replace the name x with the value 100 which is present in the global namespace.\n\n\n\nLet us revisit the scope rules:\n\nLocal: Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable.\nGlobal: If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable.\n\nConsider the following code:\ndef foo():\n    print(x)\n    x = x + 1\n\nx = 10\nfoo()\nWhen the above code is executed, we get the following error: UnboundLocalError: local variable 'x' referenced before assignment [refer]. This code violates the first rule. x is being assigned a value in line-3 of the function; hence it becomes a local variable. At line-2 we are trying to reference a value that is yet to be defined. Note that the assignment statement in line-5 doesn’t count as the x there is not local to foo, but is a global variable.\nBut what if we want to reuse the global variable x inside the function foo? Python provides a keyword called global for this purpose:\ndef foo():\n    global x\n    print(f'x inside foo = {x}')\n    x = x + 1\n    print(f'x inside foo = {x}')\n    \nx = 10\nprint(f'x outside foo = {x}')\nfoo()\nThe output is:\nx outside foo = 10\nx inside foo = 10\nx inside foo = 11\nBy declaring x to be global inside foo, a new local variable x is not created even though it appears to the left of an assignment statement in line-4.\n\n\n\nSo far we have been freely using built-in functions like print, int, input and so on. At some level, these are also names in Python and these also get resolved during run-time. There is a separate namespace called builtins where these functions are defined.\nConsider the following code:\n##### Never do something like this! #####\nprint = 1\n##### Never do something like this! #####\nIf the above code is executed, we don’t get an error! This is somewhat surprising. But syntactically, there is nothing wrong here. But we will get into serious problems when we try to do the following:\n##### Alarm! Wrong code snippet! #####\nprint = 1\nprint(1)\n##### Alarm! Wrong code snippet! #####\nThis will throw a TypeError. The name print has been hijacked and is being used as an int variable. How does Python allow this to happen?\n\nWhen resolving names, the built-in namespace is the last stage in the interpreter’s journey. Syntactically, nothing prevents us from using the name of a built-in function, such as print, as the name of a variable. But this is a very bad practice that should be avoided at any cost!"
  },
  {
    "objectID": "notes/chapter-4/lesson-4.3.html#scope",
    "href": "notes/chapter-4/lesson-4.3.html#scope",
    "title": "Lesson-4.3",
    "section": "",
    "text": "Consider the following code:\ndef foo():\n    x = 1\n    print('This is a veritable fortress. None can enter here.')\n    print('\\N{smirking face}')\n    \nfoo()\nprint(x)\nThis will give the following output:\nThis is a veritable fortress. None can enter here.\n😏\nTraceback (most recent call last):\n  File \"main.py\", line 7, in &lt;module&gt;\n    print(x)\nNameError: name 'x' is not defined\nWhy did the interpreter throw an an error in line-7? It tried to look for the name x and was unable to find it. But isn’t x present in the function foo? Is the interpreter careless or are we missing something? The interpreter is never wrong! The region in the code where a name can be referenced is called its scope. If we try to reference a variable outside its scope, the interpreter will throw a NameError.\n\n\nIn the above example, the scope of the name x is local to the function; x has a meaningful existence only inside the function and any attempt to access it from outside the function is going to result in an error. Think about functions as black holes: they don’t let variables (light) escape the function’s definition (event-horizon)! Let us take another example:\ny = 10\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\nfoo()\nThe name y is accessible from within the function as well. We say that the scope of y is global. That is, it can be referenced from anywhere within the program — even inside a function — after it has been defined for the first time. There is a slight catch here: if another variable with the same name is defined within the function, then things change. We will take up this case later.\nAt this stage, we are ready to formulate the rules for local and global variables [refer]:\n\nLocal: Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable.\nGlobal: If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable.\n\nThe scope of the parameters in the function definition are local. The following code will throw a NameError when executed:\ndef double(x):\n    x = x * 2\n    return x\n\ndouble(2)\nprint(x)\n\n\n\nLet us now look at few more examples that bring out some fine points regarding local and global scope:\n### Variant-1\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\ny = 10\nfoo()\nNotice the difference between this code and the one at the beginning of the earlier section. Here, the variable y is defined after the function definition, while in the earlier version y was defined before the function definition. But both versions give the same output. All that matters is for y to be defined before the function call. What happens if y is defined after foo is called?\n### Variant-2\ndef foo():\n    x = 1\n    print('I can access both x and y')\n    print(f'x = {x}, y = {y}')\n\nfoo()\ny = 10\nThis throws a NameError at line-5, which is reasonable as y is not defined in the main program before foo is called. The scope of y is still global; it can be referenced anywhere in the program once it has been defined.\nNow, let us crank up the difficulty level:\ndef foo():\n    x = 10\n    print(f'x inside foo = {x}')\n\nx = 100\nfoo()\nprint(f'x outside foo = {x}')\nWe have the same name — x — appearing inside the function and outside the function. Are they the same or different? Let us check the output:\nx inside foo = 10\nx outside foo = 100\nThey are different! The x inside foo is different from the x outside foo.\n\nThe scope of the name x inside foo is local; it is a local variable. This is because of the first rule: a variable that is assigned a value inside the function becomes a local variable. Since x is assigned a value in line-2, it becomes a local variable.\nThe scope of the x outside foo is global. Though there is another x inside the function foo, that cannot be accessed outside the function.\n\nThis may start to get a little confusing. How does Python internally manage local and global variables? For this, we will briefly turn to the concept of namespaces. This will give a different perspective to the problem of name resolution."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.3.html#namespaces",
    "href": "notes/chapter-4/lesson-4.3.html#namespaces",
    "title": "Lesson-4.3",
    "section": "",
    "text": "Consider the following snippet of code:\nx = 1.0\navar = 'cool'\ndef foo():\n    pass\nWe have used three different names here: x, avar and foo. The first two names represent variables that store literals. The last name represents a function. How does the Python interpreter internally process these names? It uses a concept called namespaces. A namespace can be thought of as a lookup table — dictionary to be precise — that maps names to objects.\n\n\n\nNamespace\n\n\n\n\nThere are different types of namespaces. The variables that we define in the main program are represented in the globals namespace. For example:\nx = 1.0\navar = 'cool'\ndef foo():\n    y = 2.0\n\nfoo()\nprint(globals())\nThis returns the following output:\n\nIgnore all the other details and just focus on the region highlighted in yellow. Notice that the names x, avar and foo are present in the namespace. x and avar are mapped to the objects 1 and cool respectively, while foo is mapped to some complex looking object: &lt;function foo at 0x7f8ecd2aa1f0&gt;. The number 0x7f8ecd2aa1f0 is the location in the memory where the function’s definition is stored [refer]. There is another way to check whether a given name is in a namespace:\nprint('x' in globals())\nprint('avar' in globals())\nprint('foo' in globals())\nAll three lines result in True.\n\n\n\nNotice something interesting in the previous code, the name y is not found in the globals namespace! We can verify this as follows:\nprint('y' in globals())\nThis results in False. Variables that are assigned a value inside a function are local to the function and cannot be accessed outside it. How does the Python interpreter handle names inside functions? It creates a separate namespace every time a function is called. This is called a local namespace. Now, consider the following code:\ndef foo():\n    y = 2.0\n    print('Is y in locals?', 'y' in locals())\n\nfoo()\nprint('Is y in globals?', 'y' in globals())\nIt returns the following output:\nIs y in locals? True\nIs y in globals? False"
  },
  {
    "objectID": "notes/chapter-4/lesson-4.3.html#scope-and-namespaces",
    "href": "notes/chapter-4/lesson-4.3.html#scope-and-namespaces",
    "title": "Lesson-4.3",
    "section": "",
    "text": "For every function call, the interpreter creates a local namespace that contains all names and their corresponding objects that are defined in the function. Let us take an example:\ndef foo():\n    print(y)\n    print(locals())\n    x = 1\n    print(locals())\n\ny = 10\nfoo()\nThis gives the output:\n10\n{}\n{'x': 1}\nSince y is only being referenced inside foo, it doesn’t become a part of the local namespace. It remains a global variable. Since x is being assigned a value inside foo, it is a local variable and therefore enters the local namespace. The moment control exits the function, the namespace corresponding to it is deleted.\nWhenever the interpreter comes across a name in a function it sticks to the following protocol:\n\nFirst peep into the local namespace created for that function call to see if the name is present in it. If it is present, then go ahead and use the value that this variable points to in the local namespace.\nIf it is not present, then look at the global namespace. If it is present in the global namespace, then use the value corresponding to this name.\nIf it is not present in the global namespace, then look into the built-in namespace. We will come back to the built-in namespace right at the end.\nIf it is not present in any of these namespaces, then raise a NameError.\n\nThe following image captures this idea. The built-in namespace has been ignored for now. Refer to the last section to get the complete image.\n\nWith this context, let us revisit the problem that we looked at the end of the first section:\ndef foo():\n    x = 10\n    print(f'x inside foo = {x}')\n\nx = 100\nfoo()\nprint(f'x outside foo = {x}')\nWhen the function is called at line-6, the interpreter creates a local namespace for foo. At line-2, x becomes a part of this namespace. When x is referenced at line-3, the interpreter first looks at the local namespace for foo. Since x is present there, it is going to use the value corresponding to it - in this case 10. Once control exits the function, the local namespace corresponding to it is deleted. At line-7, the interpreter will replace the name x with the value 100 which is present in the global namespace."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.3.html#global-keyword",
    "href": "notes/chapter-4/lesson-4.3.html#global-keyword",
    "title": "Lesson-4.3",
    "section": "",
    "text": "Let us revisit the scope rules:\n\nLocal: Whenever a variable is assigned a value anywhere within a function, its scope becomes local to that function. In other words, whenever a variable appears on the left side of an assignment statement anywhere within a function, it becomes a local variable.\nGlobal: If a variable is only referenced inside a function and is never assigned a value inside it, it is implicitly treated as a global variable.\n\nConsider the following code:\ndef foo():\n    print(x)\n    x = x + 1\n\nx = 10\nfoo()\nWhen the above code is executed, we get the following error: UnboundLocalError: local variable 'x' referenced before assignment [refer]. This code violates the first rule. x is being assigned a value in line-3 of the function; hence it becomes a local variable. At line-2 we are trying to reference a value that is yet to be defined. Note that the assignment statement in line-5 doesn’t count as the x there is not local to foo, but is a global variable.\nBut what if we want to reuse the global variable x inside the function foo? Python provides a keyword called global for this purpose:\ndef foo():\n    global x\n    print(f'x inside foo = {x}')\n    x = x + 1\n    print(f'x inside foo = {x}')\n    \nx = 10\nprint(f'x outside foo = {x}')\nfoo()\nThe output is:\nx outside foo = 10\nx inside foo = 10\nx inside foo = 11\nBy declaring x to be global inside foo, a new local variable x is not created even though it appears to the left of an assignment statement in line-4."
  },
  {
    "objectID": "notes/chapter-4/lesson-4.3.html#built-ins",
    "href": "notes/chapter-4/lesson-4.3.html#built-ins",
    "title": "Lesson-4.3",
    "section": "",
    "text": "So far we have been freely using built-in functions like print, int, input and so on. At some level, these are also names in Python and these also get resolved during run-time. There is a separate namespace called builtins where these functions are defined.\nConsider the following code:\n##### Never do something like this! #####\nprint = 1\n##### Never do something like this! #####\nIf the above code is executed, we don’t get an error! This is somewhat surprising. But syntactically, there is nothing wrong here. But we will get into serious problems when we try to do the following:\n##### Alarm! Wrong code snippet! #####\nprint = 1\nprint(1)\n##### Alarm! Wrong code snippet! #####\nThis will throw a TypeError. The name print has been hijacked and is being used as an int variable. How does Python allow this to happen?\n\nWhen resolving names, the built-in namespace is the last stage in the interpreter’s journey. Syntactically, nothing prevents us from using the name of a built-in function, such as print, as the name of a variable. But this is a very bad practice that should be avoided at any cost!"
  },
  {
    "objectID": "feedback.html",
    "href": "feedback.html",
    "title": "Feedback",
    "section": "",
    "text": "Kindly consider filling this form if you happen to land on this page. The form is entirely anonymous. You can enter your email id and name, both of which are optional. Comments can also be directly mailed to karthik@study.iitm.ac.in."
  }
]